{"version":3,"file":"reduceToClassNameForSlots.esm.js","sources":["../../../../packages/core/src/runtime/reduceToClassNameForSlots.ts"],"sourcesContent":["import { DEFINITION_LOOKUP_TABLE } from '../constants';\nimport { hashSequence } from './utils/hashSequence';\nimport type { CSSClassesMapBySlot, CSSClassesMap, CSSClasses } from '../types';\n\n/**\n * Reduces a classname map for slot to a classname string. Uses classnames according to text directions.\n *\n * @private\n */\nexport function reduceToClassName(classMap: CSSClassesMap, dir: 'ltr' | 'rtl'): string {\n  let className = '';\n\n  // eslint-disable-next-line guard-for-in\n  for (const propertyHash in classMap) {\n    const classNameMapping: CSSClasses = classMap[propertyHash];\n\n    if (classNameMapping) {\n      const hasRTLClassName = Array.isArray(classNameMapping);\n\n      if (dir === 'rtl') {\n        className += (hasRTLClassName ? classNameMapping[1] : classNameMapping) + ' ';\n      } else {\n        className += (hasRTLClassName ? classNameMapping[0] : classNameMapping) + ' ';\n      }\n    }\n  }\n\n  return className.slice(0, -1);\n}\n\n/**\n * Reduces classname maps for slots to classname strings. Registers them in a definition cache to be used by\n * `mergeClasses()`.\n *\n * @internal\n */\nexport function reduceToClassNameForSlots<Slots extends string | number>(\n  classesMapBySlot: CSSClassesMapBySlot<Slots>,\n  dir: 'ltr' | 'rtl',\n): Record<Slots, string> {\n  const classNamesForSlots = {} as Record<Slots, string>;\n\n  // eslint-disable-next-line guard-for-in\n  for (const slotName in classesMapBySlot) {\n    const slotClasses = reduceToClassName(classesMapBySlot[slotName], dir);\n\n    // Handles a case when there are no classes in a set i.e. \"makeStyles({ root: {} })\"\n    if (slotClasses === '') {\n      classNamesForSlots[slotName] = '';\n      continue;\n    }\n\n    const sequenceHash = hashSequence(slotClasses, dir);\n    const resultSlotClasses = sequenceHash + ' ' + slotClasses;\n\n    DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];\n    classNamesForSlots[slotName] = resultSlotClasses;\n  }\n\n  return classNamesForSlots;\n}\n"],"names":["reduceToClassName","classMap","dir","className","propertyHash","classNameMapping","hasRTLClassName","Array","isArray","slice","reduceToClassNameForSlots","classesMapBySlot","classNamesForSlots","slotName","slotClasses","sequenceHash","hashSequence","resultSlotClasses","DEFINITION_LOOKUP_TABLE"],"mappings":";;;AAIA;AACA;AACA;AACA;AACA;AACO,SAASA,iBAAiBA,CAACC,QAAuB,EAAEC,GAAkB,EAAU;EACrF,IAAIC,SAAS,GAAG,EAAE,CAAA;;AAElB;AACA,EAAA,KAAK,MAAMC,YAAY,IAAIH,QAAQ,EAAE;AACnC,IAAA,MAAMI,gBAA4B,GAAGJ,QAAQ,CAACG,YAAY,CAAC,CAAA;AAE3D,IAAA,IAAIC,gBAAgB,EAAE;AACpB,MAAA,MAAMC,eAAe,GAAGC,KAAK,CAACC,OAAO,CAACH,gBAAgB,CAAC,CAAA;MAEvD,IAAIH,GAAG,KAAK,KAAK,EAAE;QACjBC,SAAS,IAAI,CAACG,eAAe,GAAGD,gBAAgB,CAAC,CAAC,CAAC,GAAGA,gBAAgB,IAAI,GAAG,CAAA;AAC/E,OAAC,MAAM;QACLF,SAAS,IAAI,CAACG,eAAe,GAAGD,gBAAgB,CAAC,CAAC,CAAC,GAAGA,gBAAgB,IAAI,GAAG,CAAA;AAC/E,OAAA;AACF,KAAA;AACF,GAAA;EAEA,OAAOF,SAAS,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA;AAC/B,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,yBAAyBA,CACvCC,gBAA4C,EAC5CT,GAAkB,EACK;EACvB,MAAMU,kBAAkB,GAAG,EAA2B,CAAA;;AAEtD;AACA,EAAA,KAAK,MAAMC,QAAQ,IAAIF,gBAAgB,EAAE;IACvC,MAAMG,WAAW,GAAGd,iBAAiB,CAACW,gBAAgB,CAACE,QAAQ,CAAC,EAAEX,GAAG,CAAC,CAAA;;AAEtE;IACA,IAAIY,WAAW,KAAK,EAAE,EAAE;AACtBF,MAAAA,kBAAkB,CAACC,QAAQ,CAAC,GAAG,EAAE,CAAA;AACjC,MAAA,SAAA;AACF,KAAA;AAEA,IAAA,MAAME,YAAY,GAAGC,YAAY,CAACF,WAAW,EAAEZ,GAAG,CAAC,CAAA;AACnD,IAAA,MAAMe,iBAAiB,GAAGF,YAAY,GAAG,GAAG,GAAGD,WAAW,CAAA;IAE1DI,uBAAuB,CAACH,YAAY,CAAC,GAAG,CAACJ,gBAAgB,CAACE,QAAQ,CAAC,EAAEX,GAAG,CAAC,CAAA;AACzEU,IAAAA,kBAAkB,CAACC,QAAQ,CAAC,GAAGI,iBAAiB,CAAA;AAClD,GAAA;AAEA,EAAA,OAAOL,kBAAkB,CAAA;AAC3B;;;;"}