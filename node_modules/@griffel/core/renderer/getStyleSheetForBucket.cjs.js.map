{"version":3,"file":"getStyleSheetForBucket.cjs.js","sources":["../../../../packages/core/src/renderer/getStyleSheetForBucket.ts"],"sourcesContent":["import { DATA_BUCKET_ATTR } from '../constants';\nimport type { GriffelRenderer, IsomorphicStyleSheet, StyleBucketName } from '../types';\nimport { createIsomorphicStyleSheet } from './createIsomorphicStyleSheet';\n\n/**\n * Ordered style buckets using their short pseudo name.\n *\n * @internal\n */\nexport const styleBucketOrdering: StyleBucketName[] = [\n  // reset styles\n  'r',\n  // catch-all\n  'd',\n  // link\n  'l',\n  // visited\n  'v',\n  // focus-within\n  'w',\n  // focus\n  'f',\n  // focus-visible\n  'i',\n  // hover\n  'h',\n  // active\n  'a',\n  // at rules for reset styles\n  's',\n  // keyframes\n  'k',\n  // at-rules\n  't',\n  // @media rules\n  'm',\n  // @container rules\n  'c',\n];\n\n// avoid repeatedly calling `indexOf`to determine order during new insertions\nconst styleBucketOrderingMap = styleBucketOrdering.reduce((acc, cur, j) => {\n  acc[cur as StyleBucketName] = j;\n  return acc;\n}, {} as Record<StyleBucketName, number>);\n\n/**\n * Lazily adds a `<style>` bucket to the `<head>`. This will ensure that the style buckets are ordered.\n */\nexport function getStyleSheetForBucket(\n  bucketName: StyleBucketName,\n  targetDocument: Document | undefined,\n  insertionPoint: HTMLElement | null,\n  renderer: GriffelRenderer,\n  metadata: Record<string, unknown> = {},\n): IsomorphicStyleSheet {\n  const isMediaBucket = bucketName === 'm';\n  const stylesheetKey: StyleBucketName | string = isMediaBucket ? ((bucketName + metadata['m']) as string) : bucketName;\n\n  if (!renderer.stylesheets[stylesheetKey]) {\n    const tag: HTMLStyleElement | undefined = targetDocument && targetDocument.createElement('style');\n    const stylesheet = createIsomorphicStyleSheet(tag, bucketName, {\n      ...renderer.styleElementAttributes,\n      ...(isMediaBucket && { media: metadata['m'] as string }),\n    });\n\n    renderer.stylesheets[stylesheetKey] = stylesheet;\n\n    if (targetDocument && tag) {\n      targetDocument.head.insertBefore(\n        tag,\n        findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata),\n      );\n    }\n  }\n\n  return renderer.stylesheets[stylesheetKey]!;\n}\n\n/**\n * Finds an element before which the new bucket style element should be inserted following the bucket sort order.\n *\n * @param targetDocument - A document\n * @param insertionPoint - An element that will be used as an initial insertion point\n * @param targetBucket - The bucket that should be inserted to DOM\n * @param renderer - Griffel renderer\n * @param metadata - metadata for CSS rule\n * @returns - Smallest style element with greater sort order than the current bucket\n */\nfunction findInsertionPoint(\n  targetDocument: Document,\n  insertionPoint: HTMLElement | null,\n  targetBucket: StyleBucketName,\n  renderer: GriffelRenderer,\n  metadata?: Record<string, unknown>,\n): Node | null {\n  const targetOrder = styleBucketOrderingMap[targetBucket];\n\n  // Similar to javascript sort comparators where\n  // a positive value is increasing sort order\n  // a negative value is decreasing sort order\n  let comparer: (el: HTMLStyleElement) => number = el =>\n    targetOrder - styleBucketOrderingMap[el.getAttribute(DATA_BUCKET_ATTR) as StyleBucketName];\n\n  let styleElements = targetDocument.head.querySelectorAll<HTMLStyleElement>(`[${DATA_BUCKET_ATTR}]`);\n\n  if (targetBucket === 'm' && metadata) {\n    const mediaElements = targetDocument.head.querySelectorAll<HTMLStyleElement>(\n      `[${DATA_BUCKET_ATTR}=\"${targetBucket}\"]`,\n    );\n\n    // only reduce the scope of the search and change comparer\n    // if there are other media buckets already on the page\n    if (mediaElements.length) {\n      styleElements = mediaElements;\n      comparer = (el: HTMLStyleElement) => renderer.compareMediaQueries(metadata['m'] as string, el.media);\n    }\n  }\n\n  const length = styleElements.length;\n  let index = length - 1;\n\n  while (index >= 0) {\n    const styleElement = styleElements.item(index);\n\n    if (comparer(styleElement) > 0) {\n      return styleElement.nextSibling;\n    }\n\n    index--;\n  }\n\n  if (length > 0) {\n    return styleElements.item(0);\n  }\n\n  return insertionPoint ? insertionPoint.nextSibling : null;\n}\n"],"names":["styleBucketOrdering","styleBucketOrderingMap","reduce","acc","cur","j","getStyleSheetForBucket","bucketName","targetDocument","insertionPoint","renderer","metadata","isMediaBucket","stylesheetKey","stylesheets","tag","createElement","stylesheet","createIsomorphicStyleSheet","Object","assign","styleElementAttributes","media","head","insertBefore","findInsertionPoint","targetBucket","targetOrder","comparer","el","getAttribute","DATA_BUCKET_ATTR","styleElements","querySelectorAll","mediaElements","length","compareMediaQueries","index","styleElement","item","nextSibling"],"mappings":"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"}