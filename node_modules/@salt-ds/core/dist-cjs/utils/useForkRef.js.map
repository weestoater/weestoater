{"version":3,"file":"useForkRef.js","sources":["../src/utils/useForkRef.ts"],"sourcesContent":["import { Ref, useMemo } from \"react\";\nimport { setRef } from \"./setRef\";\n\nexport function useForkRef<Instance>(\n  refA: Ref<Instance> | null | undefined,\n  refB: Ref<Instance> | null | undefined\n): Ref<Instance> | null {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means React will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior\n   */\n  return useMemo(() => {\n    if (refA == null && refB == null) {\n      return () => null;\n    }\n    return (refValue) => {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}\n"],"names":["useMemo","setRef"],"mappings":";;;;;;;AAGgB,SAAA,UAAA,CACd,MACA,IACsB,EAAA;AAMtB,EAAA,OAAOA,cAAQ,MAAM;AACnB,IAAI,IAAA,IAAA,IAAQ,IAAQ,IAAA,IAAA,IAAQ,IAAM,EAAA;AAChC,MAAA,OAAO,MAAM,IAAA,CAAA;AAAA,KACf;AACA,IAAA,OAAO,CAAC,QAAa,KAAA;AACnB,MAAAC,aAAA,CAAO,MAAM,QAAQ,CAAA,CAAA;AACrB,MAAAA,aAAA,CAAO,MAAM,QAAQ,CAAA,CAAA;AAAA,KACvB,CAAA;AAAA,GACC,EAAA,CAAC,IAAM,EAAA,IAAI,CAAC,CAAA,CAAA;AACjB;;;;"}