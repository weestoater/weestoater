import { useState, useRef, useCallback, useEffect } from 'react';
import { useControlled } from '../utils/useControlled.js';
import '../utils/useFloatingUI/useFloatingUI.js';
import '../utils/useId.js';
import '../salt-provider/SaltProvider.js';
import '../viewport/ViewportProvider.js';
import 'clsx';
import '../accordion/AccordionGroup.js';
import '../accordion/AccordionPanel.js';
import '../accordion/Accordion.js';
import '../accordion/AccordionHeader.js';
import '../aria-announcer/AriaAnnouncerContext.js';
import 'react/jsx-runtime';
import '../avatar/Avatar.js';
import '../badge/Badge.js';
import '../banner/Banner.js';
import '../banner/BannerActions.js';
import '../banner/BannerContent.js';
import '../border-item/BorderItem.js';
import '../border-layout/BorderLayout.js';
import '../button/Button.js';
import '../card/Card.js';
import '../checkbox/Checkbox.js';
import '../checkbox/CheckboxGroup.js';
import '@salt-ds/styles';
import '@salt-ds/window';
import '@salt-ds/icons';
import '../combo-box/ComboBox.js';
import '../dialog/Dialog.js';
import '../dialog/DialogHeader.js';
import '../dialog/DialogActions.js';
import '../dialog/DialogContent.js';
import '../dialog/DialogContext.js';
import '../dialog/DialogCloseButton.js';
import '../drawer/Drawer.js';
import '../drawer/DrawerCloseButton.js';
import '../dropdown/Dropdown.js';
import '../file-drop-zone/FileDropZone.js';
import '../file-drop-zone/FileDropZoneIcon.js';
import '../file-drop-zone/FileDropZoneTrigger.js';
import '../flex-item/FlexItem.js';
import '../flex-layout/FlexLayout.js';
import '../flow-layout/FlowLayout.js';
import '../form-field/FormField.js';
import '../status-indicator/StatusIndicator.js';
import '../text/Text.js';
import '../text/Code.js';
import '../text/Display.js';
import '../text/Headings.js';
import '../text/Label.js';
import '../text/TextAction.js';
import '../text/TextNotation.js';
import '../form-field-context/FormFieldContext.js';
import '../grid-item/GridItem.js';
import '../grid-layout/GridLayout.js';
import '../input/Input.js';
import '../interactable-card/InteractableCard.js';
import '../interactable-card/InteractableCardGroup.js';
import '../interactable-card/InteractableCardGroupContext.js';
import '../link/Link.js';
import '../link-card/LinkCard.js';
import './ListControlContext.js';
import '../multiline-input/MultilineInput.js';
import '../navigation-item/NavigationItem.js';
import '../option/Option.js';
import '../option/OptionGroup.js';
import '../pagination/Pagination.js';
import '../pagination/Paginator.js';
import '../pagination/CompactInput.js';
import '../pagination/CompactPaginator.js';
import '../pagination/GoToInput.js';
import '../panel/Panel.js';
import '../pill/Pill.js';
import '../progress/CircularProgress/CircularProgress.js';
import '../progress/LinearProgress/LinearProgress.js';
import '../radio-button/RadioButton.js';
import '../radio-button/RadioButtonGroup.js';
import '../scrim/Scrim.js';
import '../segmented-button-group/SegmentedButtonGroup.js';
import '../spinner/Spinner.js';
import '../stack-layout/StackLayout.js';
import '../status-adornment/StatusAdornment.js';
import '../toast/Toast.js';
import '../toast/ToastContent.js';
import '../split-layout/SplitLayout.js';
import '../switch/Switch.js';
import '../toggle-button/ToggleButton.js';
import '../toggle-button-group/ToggleButtonGroup.js';
import '../toggle-button-group/ToggleButtonGroupContext.js';
import '../tooltip/Tooltip.js';
import '@floating-ui/react';

function defaultValueToString(item) {
  return typeof item === "string" ? item : "";
}
function useListControl(props) {
  const {
    open: openProp,
    defaultOpen,
    onOpenChange,
    multiselect,
    defaultSelected,
    selected: selectedProp,
    onSelectionChange,
    disabled,
    readOnly,
    valueToString = defaultValueToString
  } = props;
  const [focusedState, setFocusedState] = useState(false);
  const [focusVisibleState, setFocusVisibleState] = useState(false);
  const [activeState, setActiveState] = useState(
    void 0
  );
  const setActive = (option) => {
    if (option) {
      setActiveState(option);
    } else {
      setActiveState(void 0);
    }
  };
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: Boolean(defaultOpen),
    name: "ListControl",
    state: "open"
  });
  const openKey = useRef(void 0);
  const setOpen = (newOpen, reason, key) => {
    if (disabled || readOnly) {
      return;
    }
    setOpenState(newOpen);
    openKey.current = key;
    if (newOpen !== openState) {
      onOpenChange == null ? void 0 : onOpenChange(newOpen, reason);
    }
  };
  const [selectedState, setSelectedState] = useControlled({
    controlled: selectedProp,
    default: defaultSelected != null ? defaultSelected : [],
    name: "ListControl",
    state: "selected"
  });
  const select = (event, option) => {
    if (option.disabled || readOnly || disabled) {
      return;
    }
    let newSelected = [option.value];
    if (multiselect) {
      if (selectedState.includes(option.value)) {
        newSelected = selectedState.filter((item) => item !== option.value);
      } else {
        newSelected = selectedState.concat([option.value]);
      }
    }
    setSelectedState(newSelected);
    onSelectionChange == null ? void 0 : onSelectionChange(event, newSelected);
    if (!multiselect) {
      setOpen(false);
    }
  };
  const clear = (event) => {
    setSelectedState([]);
    if (selectedState.length !== 0) {
      onSelectionChange == null ? void 0 : onSelectionChange(event, []);
    }
  };
  const optionsRef = useRef([]);
  const register = useCallback(
    (optionValue, element) => {
      const { id } = optionValue;
      const option = optionsRef.current.find((item) => item.value.id === id);
      const index = optionsRef.current.findIndex((option2) => {
        return option2.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING;
      });
      if (!option) {
        if (index === -1) {
          optionsRef.current.push({ value: optionValue, element });
        } else {
          optionsRef.current.splice(index, 0, { value: optionValue, element });
        }
      }
      return () => {
        optionsRef.current = optionsRef.current.filter(
          (item) => item.value.id !== id
        );
      };
    },
    []
  );
  const getOptionAtIndex = (index) => {
    var _a;
    return (_a = optionsRef.current[index]) == null ? void 0 : _a.value;
  };
  const getIndexOfOption = (option) => {
    return optionsRef.current.findIndex((item) => item.value.id === option.id);
  };
  const getOptionsMatching = (predicate) => {
    return optionsRef.current.filter((item) => predicate(item.value)).map((item) => item.value);
  };
  const getOptionFromSearch = (search, startFrom) => {
    const collator = new Intl.Collator("en", {
      usage: "search",
      sensitivity: "base"
    });
    const startIndex = startFrom ? getIndexOfOption(startFrom) + 1 : 0;
    const searchList = optionsRef.current.map((item) => item.value);
    let matches = searchList.filter(
      (option) => collator.compare(
        valueToString(option.value).substring(0, search.length),
        search
      ) === 0
    );
    if (matches.length === 0) {
      const letters = search.split("");
      const allSameLetter = letters.length > 0 && letters.every((letter) => collator.compare(letter, letters[0]) === 0);
      if (allSameLetter) {
        matches = searchList.filter(
          (option) => collator.compare(
            valueToString(option.value)[0].toLowerCase(),
            letters[0]
          ) === 0
        );
      }
    }
    return matches.find((option) => getIndexOfOption(option) >= startIndex);
  };
  const listRef = useRef(null);
  useEffect(() => {
    var _a;
    if (listRef.current) {
      const activeElement = (_a = optionsRef.current.find(
        (option) => option.value === activeState
      )) == null ? void 0 : _a.element;
      if (!activeElement) {
        return;
      }
      const { scrollTop } = listRef.current;
      const { offsetTop, offsetHeight } = activeElement;
      const isVisible = offsetTop >= scrollTop && offsetTop + offsetHeight <= scrollTop + listRef.current.offsetHeight;
      if (!isVisible) {
        activeElement.scrollIntoView({
          block: "end",
          inline: "nearest"
        });
      }
    }
  }, [activeState]);
  return {
    multiselect: Boolean(multiselect),
    openState,
    setOpen,
    openKey,
    activeState,
    setActive,
    selectedState,
    setSelectedState,
    select,
    clear,
    focusVisibleState,
    setFocusVisibleState,
    focusedState,
    setFocusedState,
    listRef,
    options: optionsRef.current.map((option) => option.element),
    register,
    getOptionAtIndex,
    getIndexOfOption,
    getOptionsMatching,
    getOptionFromSearch,
    valueToString
  };
}

export { defaultValueToString, useListControl };
//# sourceMappingURL=ListControlState.js.map
