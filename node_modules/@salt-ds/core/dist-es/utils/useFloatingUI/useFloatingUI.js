import { jsx } from 'react/jsx-runtime';
import { FloatingPortal, FloatingFocusManager, flip, shift, limitShift, platform, useFloating, autoUpdate } from '@floating-ui/react';
import { forwardRef, createContext, useMemo, useContext } from 'react';
import { useTheme, UNSTABLE_SaltProviderNext, SaltProvider } from '../../salt-provider/SaltProvider.js';

const DefaultFloatingComponent = forwardRef(function DefaultFloatingComponent2(props, ref) {
  const {
    open,
    top,
    left,
    position,
    width,
    height,
    focusManagerProps,
    ...rest
  } = props;
  const style = {
    top,
    left,
    position
  };
  const { themeNext } = useTheme();
  const ChosenSaltProvider = themeNext ? UNSTABLE_SaltProviderNext : SaltProvider;
  if (focusManagerProps && open) {
    return /* @__PURE__ */ jsx(FloatingPortal, {
      children: /* @__PURE__ */ jsx(ChosenSaltProvider, {
        children: /* @__PURE__ */ jsx(FloatingFocusManager, {
          ...focusManagerProps,
          children: /* @__PURE__ */ jsx("div", {
            style,
            ...rest,
            ref
          })
        })
      })
    });
  }
  return open ? /* @__PURE__ */ jsx(FloatingPortal, {
    children: /* @__PURE__ */ jsx(ChosenSaltProvider, {
      children: /* @__PURE__ */ jsx("div", {
        style,
        ...rest,
        ref
      })
    })
  }) : null;
});
const FloatingComponentContext = createContext({
  Component: DefaultFloatingComponent
});
if (process.env.NODE_ENV !== "production") {
  FloatingComponentContext.displayName = "FloatingComponentContext";
}
function FloatingComponentProvider(props) {
  const { Component, children } = props;
  const value = useMemo(() => ({ Component }), [Component]);
  return /* @__PURE__ */ jsx(FloatingComponentContext.Provider, {
    value,
    children
  });
}
function useFloatingComponent() {
  return useContext(FloatingComponentContext);
}
const defaultGetMiddleware = (defaultMiddleware) => defaultMiddleware;
const defaultFloatingPlaform = {
  platform,
  middleware: defaultGetMiddleware,
  animationFrame: false
};
const FloatingPlatformContext = createContext(
  defaultFloatingPlaform
);
function FloatingPlatformProvider(props) {
  const {
    platform: platformProp,
    middleware,
    animationFrame,
    children
  } = props;
  const floatingPlatformContextValue = useMemo(
    () => ({
      platform: platformProp != null ? platformProp : platform,
      middleware: middleware != null ? middleware : defaultGetMiddleware,
      animationFrame: animationFrame || false
    }),
    [platformProp, middleware, animationFrame]
  );
  return /* @__PURE__ */ jsx(FloatingPlatformContext.Provider, {
    value: floatingPlatformContextValue,
    children
  });
}
function useFloatingPlatform() {
  return useContext(FloatingPlatformContext);
}
const DEFAULT_FLOATING_UI_MIDDLEWARE = [
  flip(),
  shift({ limiter: limitShift() })
];
function useFloatingUI(props) {
  const {
    placement,
    strategy,
    middleware = DEFAULT_FLOATING_UI_MIDDLEWARE,
    open = false,
    onOpenChange
  } = props;
  const handleOpenChange = (open2, boolean, reason) => {
    update();
    onOpenChange == null ? void 0 : onOpenChange(open2, boolean, reason);
  };
  const {
    platform: contextPlatform,
    middleware: contextMiddleware,
    animationFrame
  } = useFloatingPlatform();
  const { refs, update, ...rest } = useFloating({
    placement,
    strategy,
    middleware: contextMiddleware(middleware),
    open,
    onOpenChange: handleOpenChange,
    whileElementsMounted: (...args) => {
      const cleanup = autoUpdate(...args, { animationFrame });
      return cleanup;
    },
    platform: contextPlatform
  });
  return {
    reference: refs.setReference,
    floating: refs.setFloating,
    refs,
    update,
    ...rest
  };
}

export { DEFAULT_FLOATING_UI_MIDDLEWARE, FloatingComponentProvider, FloatingPlatformProvider, useFloatingComponent, useFloatingPlatform, useFloatingUI };
//# sourceMappingURL=useFloatingUI.js.map
