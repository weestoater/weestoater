import { makePrefixer, useControlled } from '@salt-ds/core';
import { clsx } from 'clsx';
import { isPlainObject } from '../utils/isPlainObject.js';
import 'react';
import { useCalendarContext } from './internal/CalendarContext.js';
import { isSameDay, CalendarDate } from '@internationalized/date';

function addOrRemoveFromArray(array = [], item) {
  if (Array.isArray(array)) {
    if (array.find((element) => isSameDay(element, item))) {
      return array.filter((element) => !isSameDay(element, item));
    }
    return array.concat(item);
  }
  return [item];
}
const defaultOffset = (date) => date;
function isRangeOrOffsetSelectionValue(selectionValue) {
  return selectionValue != null && isPlainObject(selectionValue);
}
const withBaseName = makePrefixer("saltCalendarDay");
function useSelectionCalendar(props) {
  const {
    hoveredDate: hoveredDateProp,
    selectedDate: selectedDateProp,
    defaultSelectedDate,
    onHoveredDateChange,
    isDaySelectable,
    selectionVariant
  } = props;
  const [selectedDate, setSelectedDateState] = useControlled({
    controlled: selectedDateProp,
    default: defaultSelectedDate,
    name: "Calendar",
    state: "selectedDate"
  });
  const getStartDateOffset = (date) => {
    if (props.selectionVariant === "offset" && props.startDateOffset) {
      return props.startDateOffset(date);
    } else {
      return defaultOffset(date);
    }
  };
  const getEndDateOffset = (date) => {
    if (props.selectionVariant === "offset" && props.endDateOffset) {
      return props.endDateOffset(date);
    } else {
      return defaultOffset(date);
    }
  };
  const setSelectedDate = (event, newSelectedDate) => {
    var _a, _b, _c, _d;
    if (isDaySelectable(newSelectedDate)) {
      switch (props.selectionVariant) {
        case "default":
          setSelectedDateState(newSelectedDate);
          (_a = props.onSelectedDateChange) == null ? void 0 : _a.call(props, event, newSelectedDate);
          break;
        case "multiselect":
          const newDates = addOrRemoveFromArray(selectedDate, newSelectedDate);
          setSelectedDateState(newDates);
          (_b = props.onSelectedDateChange) == null ? void 0 : _b.call(props, event, newDates);
          break;
        case "range":
          let base = selectedDate;
          if (isRangeOrOffsetSelectionValue(base)) {
            if ((base == null ? void 0 : base.startDate) && (base == null ? void 0 : base.endDate)) {
              base = { startDate: newSelectedDate };
            } else if ((base == null ? void 0 : base.startDate) && newSelectedDate.compare(base.startDate) > 0) {
              base = { ...base, endDate: newSelectedDate };
            } else {
              base = { startDate: newSelectedDate };
            }
          } else {
            base = { startDate: newSelectedDate };
          }
          setSelectedDateState(base);
          (_c = props.onSelectedDateChange) == null ? void 0 : _c.call(props, event, base);
          break;
        case "offset":
          const newRange = {
            startDate: getStartDateOffset(newSelectedDate),
            endDate: getEndDateOffset(newSelectedDate)
          };
          setSelectedDateState(newRange);
          (_d = props.onSelectedDateChange) == null ? void 0 : _d.call(props, event, newRange);
      }
    }
  };
  const isSelected = (date) => {
    switch (selectionVariant) {
      case "default":
        return selectedDate instanceof CalendarDate && isSameDay(selectedDate, date);
      case "multiselect":
        return Array.isArray(selectedDate) && !!selectedDate.find((element) => isSameDay(element, date));
      default:
        return false;
    }
  };
  const [hoveredDate, setHoveredDateState] = useControlled({
    controlled: hoveredDateProp,
    default: void 0,
    name: "Calendar",
    state: "hoveredDate"
  });
  const setHoveredDate = (event, date) => {
    setHoveredDateState(date);
    onHoveredDateChange == null ? void 0 : onHoveredDateChange(event, date);
  };
  const isHovered = (date) => {
    return !!hoveredDate && isSameDay(date, hoveredDate);
  };
  const isSelectedSpan = (date) => {
    if ((selectionVariant === "range" || selectionVariant === "offset") && isRangeOrOffsetSelectionValue(selectedDate) && (selectedDate == null ? void 0 : selectedDate.startDate) && (selectedDate == null ? void 0 : selectedDate.endDate)) {
      return date.compare(selectedDate.startDate) > 0 && date.compare(selectedDate.endDate) < 0;
    }
    return false;
  };
  const isHoveredSpan = (date) => {
    if ((selectionVariant === "range" || selectionVariant === "offset") && isRangeOrOffsetSelectionValue(selectedDate) && selectedDate.startDate && !selectedDate.endDate && hoveredDate) {
      const isForwardRange = hoveredDate.compare(selectedDate.startDate) > 0 && (date.compare(selectedDate.startDate) > 0 && date.compare(hoveredDate) < 0 || isSameDay(date, hoveredDate));
      const isValidDayHovered = isDaySelectable(hoveredDate);
      return isForwardRange && isValidDayHovered;
    }
    return false;
  };
  const isSelectedStart = (date) => {
    if ((selectionVariant === "range" || selectionVariant === "offset") && isRangeOrOffsetSelectionValue(selectedDate) && selectedDate.startDate) {
      return isSameDay(selectedDate.startDate, date);
    }
    return false;
  };
  const isSelectedEnd = (date) => {
    if ((selectionVariant === "range" || selectionVariant === "offset") && isRangeOrOffsetSelectionValue(selectedDate) && selectedDate.endDate) {
      return isSameDay(selectedDate.endDate, date);
    }
    return false;
  };
  const isHoveredOffset = (date) => {
    if (hoveredDate && selectionVariant === "offset") {
      const startDate = getStartDateOffset(hoveredDate);
      const endDate = getEndDateOffset(hoveredDate);
      return date.compare(startDate) >= 0 && date.compare(endDate) <= 0 && isDaySelectable(date);
    }
    return false;
  };
  return {
    state: {
      selectedDate,
      hoveredDate
    },
    helpers: {
      setSelectedDate,
      isSelected,
      setHoveredDate,
      isHovered,
      isSelectedSpan,
      isHoveredSpan,
      isSelectedStart,
      isSelectedEnd,
      isHoveredOffset
    }
  };
}
function useSelectionDay({ date }) {
  const {
    helpers: {
      setSelectedDate,
      isSelected,
      setHoveredDate,
      isSelectedSpan,
      isHoveredSpan,
      isSelectedStart,
      isSelectedEnd,
      isHovered,
      isHoveredOffset,
      isDayUnselectable
    }
  } = useCalendarContext();
  const handleClick = (event) => {
    setSelectedDate(event, date);
  };
  const handleKeyDown = (event) => {
    switch (event.key) {
      case "Space":
      case "Enter":
        setSelectedDate(event, date);
        event.preventDefault();
    }
  };
  const handleMouseOver = (event) => {
    setHoveredDate(event, date);
  };
  const handleMouseLeave = (event) => {
    setHoveredDate(event, null);
  };
  const selected = isSelected(date);
  const selectedSpan = isSelectedSpan(date);
  const hoveredSpan = isHoveredSpan(date);
  const selectedStart = isSelectedStart(date);
  const selectedEnd = isSelectedEnd(date);
  const hovered = isHovered(date);
  const hoveredOffset = isHoveredOffset(date);
  return {
    handleClick,
    handleKeyDown,
    handleMouseOver,
    handleMouseLeave,
    status: {
      selected,
      selectedSpan,
      hoveredSpan,
      selectedStart,
      selectedEnd,
      hovered,
      hoveredOffset
    },
    dayProps: {
      className: clsx({
        [withBaseName("selected")]: selected,
        [withBaseName("selectedSpan")]: selectedSpan,
        [withBaseName("hoveredSpan")]: hoveredSpan,
        [withBaseName("selectedStart")]: selectedStart,
        [withBaseName("selectedEnd")]: selectedEnd,
        [withBaseName("hovered")]: hovered,
        [withBaseName("hoveredOffset")]: hoveredOffset
      }),
      "aria-pressed": selected || selectedEnd || selectedStart || selectedSpan ? "true" : void 0,
      "aria-disabled": !!isDayUnselectable(date) ? "true" : void 0
    }
  };
}

export { useSelectionCalendar, useSelectionDay };
//# sourceMappingURL=useSelection.js.map
