import { useRef, useCallback, isValidElement } from 'react';
import '@salt-ds/core';
import '../common-hooks/collectionProvider.js';
import '../common-hooks/keyUtils.js';
import { useCollapsibleGroups } from '../common-hooks/useCollapsibleGroups.js';
import { closestListItemIndex } from '../common-hooks/list-dom-utils.js';
import { useKeyboardNavigation } from '../common-hooks/useKeyboardNavigation.js';
import { useSelection } from '../common-hooks/useSelection.js';
import { useTypeahead } from '../common-hooks/useTypeahead.js';
import { useViewportTracking } from '../common-hooks/useViewportTracking.js';

const useList = ({
  collapsibleHeaders,
  collectionHook: dataHook,
  containerRef,
  contentRef,
  defaultHighlightedIndex,
  defaultSelected,
  disabled,
  disableAriaActiveDescendant,
  disableHighlightOnFocus,
  disableTypeToSelect,
  highlightedIndex: highlightedIndexProp,
  label = "",
  listHandlers: listHandlersProp,
  onSelect,
  onSelectionChange,
  onHighlight,
  onKeyboardNavigation,
  onKeyDown,
  restoreLastFocus,
  selected,
  selectionStrategy,
  selectionKeys,
  stickyHeaders,
  tabToSelect
}) => {
  const lastSelection = useRef(selected || defaultSelected);
  const handleKeyboardNavigation = (evt, nextIndex) => {
    var _a, _b;
    (_b = (_a = selectionHook.listHandlers).onKeyboardNavigation) == null ? void 0 : _b.call(_a, evt, nextIndex);
    onKeyboardNavigation == null ? void 0 : onKeyboardNavigation(evt, nextIndex);
  };
  const handleSelect = useCallback(
    (evt, selectedItem) => {
      if (onSelect) {
        if (isValidElement(selectedItem.value)) {
          onSelect(evt, selectedItem.label);
        } else if (selectedItem.value !== null) {
          onSelect(evt, selectedItem.value);
        }
      }
    },
    [onSelect]
  );
  const handleSelectionChange = useCallback(
    (evt, selected2) => {
      if (onSelectionChange) {
        onSelectionChange(
          evt,
          Array.isArray(selected2) ? selected2.map(
            (s) => isValidElement(s.value) ? s.label : s.value
          ) : selected2 && (isValidElement(selected2.value) ? selected2.label : selected2.value)
        );
      }
    },
    [onSelectionChange]
  );
  const {
    highlightedIndex,
    listProps: {
      onKeyDown: navigationKeyDown,
      onMouseMove: navigationMouseMove,
      ...navigationControlProps
    },
    setHighlightedIndex,
    ...keyboardHook
  } = useKeyboardNavigation({
    containerRef,
    defaultHighlightedIndex,
    disableHighlightOnFocus,
    highlightedIndex: highlightedIndexProp,
    indexPositions: dataHook.data,
    label,
    onHighlight,
    onKeyboardNavigation: handleKeyboardNavigation,
    restoreLastFocus,
    selected: lastSelection.current
  });
  const collapsibleHook = useCollapsibleGroups({
    collapsibleHeaders,
    highlightedIdx: highlightedIndex,
    collectionHook: dataHook
  });
  const selectionHook = useSelection({
    defaultSelected,
    highlightedIdx: highlightedIndex,
    indexPositions: dataHook.data,
    label,
    onSelect: handleSelect,
    onSelectionChange: handleSelectionChange,
    selected,
    selectionStrategy,
    selectionKeys,
    tabToSelect
  });
  const { onKeyDown: typeaheadOnKeyDown } = useTypeahead({
    disableTypeToSelect,
    highlightedIdx: highlightedIndex,
    highlightItemAtIndex: setHighlightedIndex,
    typeToNavigate: true,
    items: dataHook.data
  });
  const handleKeyDown = useCallback(
    (evt) => {
      var _a, _b, _c;
      if (!evt.defaultPrevented) {
        typeaheadOnKeyDown == null ? void 0 : typeaheadOnKeyDown(evt);
      }
      navigationKeyDown(evt);
      if (!evt.defaultPrevented) {
        (_b = (_a = selectionHook.listHandlers).onKeyDown) == null ? void 0 : _b.call(_a, evt);
      }
      if (!evt.defaultPrevented) {
        (_c = collapsibleHook == null ? void 0 : collapsibleHook.onKeyDown) == null ? void 0 : _c.call(collapsibleHook, evt);
      }
      if (!evt.defaultPrevented) {
        onKeyDown == null ? void 0 : onKeyDown(evt);
      }
    },
    [
      collapsibleHook,
      navigationKeyDown,
      onKeyDown,
      selectionHook.listHandlers,
      typeaheadOnKeyDown
    ]
  );
  const { isScrolling, scrollIntoView } = useViewportTracking({
    containerRef,
    contentRef,
    highlightedIdx: highlightedIndex,
    indexPositions: dataHook.data,
    stickyHeaders
  });
  const handleMouseMove = useCallback(
    (evt) => {
      if (!isScrolling.current && !disabled) {
        navigationMouseMove();
        const idx = closestListItemIndex(evt.target);
        if (idx !== highlightedIndex) {
          const item = dataHook.data[idx];
          if (!item || item.disabled) {
            setHighlightedIndex(-1);
          } else {
            setHighlightedIndex(idx);
          }
        }
      }
    },
    [
      isScrolling,
      disabled,
      setHighlightedIndex,
      navigationMouseMove,
      highlightedIndex,
      dataHook.data
    ]
  );
  const getActiveDescendant = () => {
    var _a;
    return highlightedIndex === void 0 || highlightedIndex === -1 || disableAriaActiveDescendant ? void 0 : (_a = dataHook.data[highlightedIndex]) == null ? void 0 : _a.id;
  };
  lastSelection.current = selectionHook.selected;
  const listControlProps = {
    "aria-activedescendant": getActiveDescendant(),
    onBlur: navigationControlProps.onBlur,
    onFocus: navigationControlProps.onFocus,
    onKeyDown: handleKeyDown,
    onMouseDownCapture: navigationControlProps.onMouseDownCapture,
    onMouseLeave: navigationControlProps.onMouseLeave
  };
  const listHandlers = listHandlersProp || {
    onClick: selectionHook.listHandlers.onClick,
    onMouseMove: handleMouseMove
  };
  return {
    focusVisible: keyboardHook.focusVisible,
    controlledHighlighting: keyboardHook.controlledHighlighting,
    highlightedIndex,
    keyboardNavigation: keyboardHook.keyboardNavigation,
    listHandlers,
    listItemHeaderHandlers: collapsibleHook,
    listControlProps,
    scrollIntoView,
    selected: selectionHook.selected,
    setHighlightedIndex,
    setIgnoreFocus: keyboardHook.setIgnoreFocus,
    setSelected: selectionHook.setSelected
  };
};

export { useList };
//# sourceMappingURL=useList.js.map
