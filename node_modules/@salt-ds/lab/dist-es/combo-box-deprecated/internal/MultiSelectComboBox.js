import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { flip, shift, limitShift, size } from '@floating-ui/react';
import { useAriaAnnouncer, useForkRef, useFloatingUI } from '@salt-ds/core';
import { useRef, useEffect, useState } from 'react';
import { Portal } from '../../portal/Portal.js';
import '../../list-deprecated/List.js';
import { ListBase } from '../../list-deprecated/ListBase.js';
import '../../list-deprecated/ListItemBase.js';
import '../../list-deprecated/ListItem.js';
import '../../list-deprecated/ListItemContext.js';
import { ListStateContext } from '../../list-deprecated/ListStateContext.js';
import '../../tokenized-input/TokenizedInput.js';
import { TokenizedInputBase } from '../../tokenized-input/TokenizedInputBase.js';
import 'clipboard-copy';
import '../../form-field-context-legacy/FormFieldLegacyContext.js';
import { getAnnouncement } from './getAnnouncement.js';
import { useMultiSelectComboBox } from './useMultiSelectComboBox.js';
import { isDesktop, useWindow } from '../../window/WindowContext.js';
import '../../window/ElectronWindow.js';

function MultiSelectComboBox(props) {
  const {
    ListItem,
    WindowProps,
    rootRef,
    listRef: listRefProp,
    rootWidth,
    listWidth,
    inputRef: inputRefProp,
    ...restProps
  } = props;
  const { announce } = useAriaAnnouncer({ debounce: 1e3 });
  const expandButtonRef = useRef(null);
  const listRef = useRef(null);
  const setListRef = useForkRef(listRef, listRefProp);
  const { inputRef, listContext, inputProps, listProps, inputHelpers } = useMultiSelectComboBox({
    ...restProps,
    expandButtonRef
  });
  const { allowAnnouncement, disabled, value, ...restInputProps } = inputProps;
  const { isListOpen, itemCount, itemToString, source, ...restListProps } = listProps;
  const firstItem = null;
  const allowAnnouncementRef = useRef(allowAnnouncement);
  useEffect(() => {
    allowAnnouncementRef.current = allowAnnouncement;
  }, [allowAnnouncement]);
  useEffect(() => {
    if (allowAnnouncementRef.current && value && firstItem) {
      announce(getAnnouncement(itemCount, firstItem));
    }
  }, [value, firstItem, itemCount, announce]);
  const [maxListHeight, setMaxListHeight] = useState(
    void 0
  );
  const middleware = isDesktop ? [] : [
    flip({
      fallbackPlacements: ["bottom-start", "top-start"]
    }),
    shift({ limiter: limitShift() }),
    size({
      apply({ availableHeight }) {
        setMaxListHeight(availableHeight);
      }
    })
  ];
  const { reference, floating, x, y, strategy } = useFloatingUI({
    placement: "bottom-start",
    middleware
  });
  useEffect(() => {
    if (rootRef.current) {
      reference(rootRef.current);
    }
  }, [rootRef, reference]);
  const Window = useWindow();
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx(TokenizedInputBase, {
        disabled,
        expandButtonRef,
        inputRef: useForkRef(inputRef, inputRefProp),
        value,
        helpers: inputHelpers,
        ...restInputProps
      }),
      rootRef.current && isListOpen && /* @__PURE__ */ jsx(Portal, {
        children: /* @__PURE__ */ jsx(Window, {
          style: {
            top: y != null ? y : 0,
            left: x != null ? x : 0,
            position: strategy,
            maxHeight: maxListHeight != null ? maxListHeight : ""
          },
          ...WindowProps,
          ref: floating,
          children: /* @__PURE__ */ jsx(ListStateContext.Provider, {
            value: listContext,
            children: /* @__PURE__ */ jsx(ListBase, {
              ...{
                ListItem,
                disabled,
                itemCount,
                itemToString,
                width: listWidth || rootWidth,
                source,
                ...restListProps,
                listRef: setListRef
              },
              maxHeight: maxListHeight || listProps.maxHeight
            })
          })
        })
      })
    ]
  });
}

export { MultiSelectComboBox };
//# sourceMappingURL=MultiSelectComboBox.js.map
