import { useId, useControlled, useIsFocusVisible, useForkRef } from '@salt-ds/core';
import { useState, useRef, useMemo, useCallback, useEffect } from 'react';
import '../../list-deprecated/List.js';
import '../../list-deprecated/ListBase.js';
import '../../list-deprecated/ListItemBase.js';
import '../../list-deprecated/ListItem.js';
import '../../list-deprecated/ListItemContext.js';
import '../../list-deprecated/ListStateContext.js';
import { useList } from '../../list-deprecated/useList.js';
import { defaultItemToString } from '../../tokenized-input/internal/defaultItemToString.js';
import { getDefaultFilterRegex, getDefaultFilter } from '../filterHelpers.js';
import { usePopperStatus, isToggleList } from './usePopperStatus.js';

const useComboBox = (props) => {
  const {
    initialOpen,
    initialSelectedItem,
    allowFreeText,
    displayedItemCount,
    virtualized,
    disabled,
    onBlur,
    onFocus,
    onChange,
    onSelect,
    onInputChange,
    onInputFocus,
    onInputBlur,
    onInputSelect,
    id: idProp,
    source: sourceProp = [],
    selectedItem: selectedItemProp,
    inputValue: inputValueProp,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    getFilterRegex = getDefaultFilterRegex,
    itemToString = defaultItemToString,
    stringToItem: stringToItemProp = (value) => value ? value.trim() : value,
    InputProps: inputProps = {
      onBlur: onBlur || onInputBlur,
      onFocus: onFocus || onInputFocus,
      onChange: onInputChange,
      onSelect: onInputSelect
    },
    ListProps = {},
    ...restProps
  } = props;
  const id = useId(idProp);
  const inputId = `${id}-input`;
  const listId = `${id}-list`;
  const [inputValue, setInputValue] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: "ComboBox",
    state: "inputValue"
  });
  const [selectionChanged, setSelectionChanged] = useState(false);
  const inputRef = useRef(null);
  const [allowAnnouncement, setAllowAnnouncement] = useState(false);
  const labels = useMemo(
    () => sourceProp.map(itemToString),
    [sourceProp, itemToString]
  );
  const source = useMemo(() => {
    if (inputValue && inputValue.trim().length) {
      const itemFilter = getDefaultFilter(inputValue, getFilterRegex);
      return sourceProp.filter((item) => itemFilter(itemToString(item)));
    }
    return sourceProp;
  }, [inputValue, sourceProp, getFilterRegex, itemToString]);
  const itemTextHighlightPattern = useMemo(
    () => inputValue && inputValue.trim().length ? getFilterRegex(inputValue) : void 0,
    [inputValue, getFilterRegex]
  );
  const { focusedRef, state, helpers, listProps } = useList({
    ...ListProps,
    source,
    disabled,
    virtualized,
    itemToString,
    initialSelectedItem,
    selectedItem: selectedItemProp,
    displayedItemCount,
    onChange,
    onSelect,
    id: listId,
    tabToSelect: true,
    disableFocus: true,
    disableMouseDown: true,
    "aria-labelledby": ariaLabelledBy
  });
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const handleFocusVisibleRef = useForkRef(focusVisibleRef, focusedRef);
  const handleInputRef = useForkRef(inputRef, handleFocusVisibleRef);
  const { "aria-activedescendant": ariaActiveDescendant, ...restListProps } = listProps;
  const { selectedItem, highlightedIndex } = state;
  const [quickSelection, setQuickSelection] = useState(false);
  const { setFocusVisible, setSelectedItem, setHighlightedIndex } = helpers;
  const reconcileInput = useCallback(() => {
    setInputValue(selectedItem == null ? "" : itemToString(selectedItem));
  }, [selectedItem, itemToString, setInputValue]);
  const selectInputValue = (event) => {
    const nextIndex = inputValue ? labels.indexOf(inputValue.trim()) : -1;
    const nextItem = nextIndex >= 0 ? sourceProp[nextIndex] : stringToItemProp(inputValue);
    if (onSelect) {
      onSelect(event, nextItem);
    }
    if (nextItem !== selectedItem) {
      setSelectedItem(nextItem);
      onChange && onChange(event, nextItem);
    }
  };
  const { isOpen: isListOpen, notifyPopper } = usePopperStatus({
    initialOpen
  });
  useEffect(reconcileInput, [reconcileInput]);
  useEffect(() => {
    if (!isListOpen) {
      setHighlightedIndex(void 0);
      setQuickSelection(false);
    }
  }, [isListOpen, setHighlightedIndex, quickSelection]);
  const initHighlightedIndex = () => {
    setHighlightedIndex(selectedItem ? source.indexOf(selectedItem) : -1);
  };
  const handleInputFocus = (event) => {
    handleFocusVisible(event);
    if (isFocusVisibleRef.current) {
      setFocusVisible(true);
    }
    if (highlightedIndex == null) {
      initHighlightedIndex();
    }
    if (inputProps.onFocus) {
      inputProps.onFocus(event);
    }
    notifyPopper(event);
  };
  const handleInputBlur = (event) => {
    console.log("BLUR");
    handleBlurVisible();
    setAllowAnnouncement(false);
    if (allowFreeText) {
      selectInputValue(event);
    } else {
      reconcileInput();
    }
    if (restListProps.onBlur) {
      restListProps.onBlur(event);
    }
    if (inputProps.onBlur) {
      inputProps.onBlur(event);
    }
    notifyPopper(event);
  };
  const handleInputChange = (event) => {
    const newValue = event.target.value;
    setInputValue(newValue);
    setHighlightedIndex(void 0);
    setQuickSelection(newValue.length > 0 && !allowFreeText);
    if (newValue.length === 0) {
      setSelectedItem(void 0);
      onChange && onChange(event, null);
    }
    if (inputProps.onChange) {
      inputProps.onChange(event, "");
    }
  };
  const handleInputSelect = (event) => {
    console.log(`handleInputSelect setSelectionChanged = true`);
    setSelectionChanged(true);
    if (inputProps.onSelect) {
      inputProps.onSelect(event);
    }
  };
  const handleInputKeyDown = (event) => {
    if ("Escape" === event.key) {
      setHighlightedIndex(void 0);
      if (allowFreeText) {
        setInputValue("");
      } else {
        reconcileInput();
      }
    }
    if (inputProps.onKeyDown) {
      inputProps.onKeyDown(event);
    }
  };
  const handleFirstItemSelection = (event) => {
    if (!allowFreeText && event.key === "Enter" && quickSelection) {
      setSelectedItem(source[0]);
      onSelect && onSelect(event, source[0]);
      onChange && onChange(event, source[0]);
    }
  };
  const handleKeyDown = (event) => {
    if (isToggleList(event)) {
      notifyPopper(event);
      return;
    }
    if (["ArrowUp", "ArrowDown"].indexOf(event.key) !== -1 && highlightedIndex == null) {
      initHighlightedIndex();
    }
    handleFirstItemSelection(event);
    if ([" ", "Home", "End"].indexOf(event.key) === -1) {
      if (restListProps.onKeyDown) {
        restListProps.onKeyDown(event);
      }
      console.log(`handleKeyDown ${event.key} setSelectionCHanged = false`);
      setSelectionChanged(false);
    }
    setAllowAnnouncement("Backspace" !== event.key);
    handleInputKeyDown(event);
    notifyPopper(event);
  };
  const handleListClick = (event) => {
    console.log("handle list click");
    const inputEl = inputRef.current;
    if (inputEl != null) {
      inputEl.focus();
    }
    if (restListProps.onClick) {
      restListProps.onClick(event);
    }
    notifyPopper(event);
  };
  const mergedInputProps = {
    ...inputProps.inputProps,
    role: "combobox",
    "aria-owns": listId,
    "aria-label": ariaLabel,
    "aria-expanded": isListOpen,
    "aria-activedescendant": isListOpen && selectionChanged ? null : ariaActiveDescendant
  };
  return {
    inputRef: handleInputRef,
    listContext: {
      state,
      helpers
    },
    inputProps: {
      ...restProps,
      ...inputProps,
      disabled,
      allowAnnouncement,
      id: inputId,
      value: inputValue,
      onFocus: handleInputFocus,
      onBlur: handleInputBlur,
      onChange: handleInputChange,
      onKeyDown: handleKeyDown,
      onSelect: handleInputSelect,
      inputProps: mergedInputProps
    },
    listProps: {
      ...restListProps,
      source,
      itemToString,
      itemTextHighlightPattern,
      onClick: handleListClick,
      isListOpen: isListOpen && Boolean(source.length)
    }
  };
};

export { useComboBox };
//# sourceMappingURL=useComboBox.js.map
