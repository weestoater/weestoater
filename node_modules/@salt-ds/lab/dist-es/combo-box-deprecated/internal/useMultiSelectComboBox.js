import { useId, useControlled, useIsFocusVisible, useForkRef, usePrevious, useIsomorphicLayoutEffect } from '@salt-ds/core';
import { useState, useRef, useMemo, useEffect } from 'react';
import '../../list-deprecated/List.js';
import '../../list-deprecated/ListBase.js';
import '../../list-deprecated/ListItemBase.js';
import '../../list-deprecated/ListItem.js';
import '../../list-deprecated/ListItemContext.js';
import '../../list-deprecated/ListStateContext.js';
import { useList } from '../../list-deprecated/useList.js';
import '../../tokenized-input/TokenizedInput.js';
import '../../tokenized-input/TokenizedInputBase.js';
import { useTokenizedInput } from '../../tokenized-input/useTokenizedInput.js';
import { defaultItemToString } from '../../tokenized-input/internal/defaultItemToString.js';
import { getDefaultFilterRegex, getDefaultFilter } from '../filterHelpers.js';
import { usePopperStatus, isToggleList } from './usePopperStatus.js';

const REQUIRE_PREV_HIGHLIGHT = ["ArrowUp", "ArrowDown", "PageUp", "PageDown"];
const useMultiSelectComboBox = (props) => {
  const {
    allowFreeText,
    displayedItemCount,
    virtualized,
    disabled,
    expandButtonRef,
    onBlur,
    onFocus,
    onChange,
    onSelect,
    onInputChange,
    onInputFocus,
    onInputBlur,
    onInputSelect,
    id: idProp,
    source: sourceProp,
    selectedItem: selectedItemProp,
    inputValue: inputValueProp,
    initialOpen,
    initialSelectedItem: initialSelectedItems,
    "aria-labelledby": ariaLabelledBy,
    getFilterRegex = getDefaultFilterRegex,
    itemToString = defaultItemToString,
    stringToItem: stringToItemProp = (_, value) => value.trim(),
    InputProps = {
      onBlur,
      onFocus,
      onInputBlur,
      onInputFocus,
      onInputChange,
      onInputSelect
    },
    ListProps = {},
    ...restProps
  } = props;
  const id = useId(idProp);
  const inputId = `${id}-input`;
  const listId = `${id}-list`;
  const [inputValue, setInputValue] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: "MultiSelectComboBox",
    state: "inputValue"
  });
  const { isOpen: isListOpen, notifyPopper } = usePopperStatus({
    initialOpen,
    isMultiSelect: true
  });
  const [selectionChanged, setSelectionChanged] = useState(false);
  const inputBlurTimeout = useRef(null);
  const [allowAnnouncement, setAllowAnnouncement] = useState(false);
  const labels = useMemo(
    () => sourceProp.map(itemToString),
    [sourceProp, itemToString]
  );
  const source = useMemo(() => {
    if (inputValue && inputValue.trim().length) {
      const itemFilter = getDefaultFilter(inputValue, getFilterRegex);
      return sourceProp.filter((item) => itemFilter(itemToString(item)));
    }
    return sourceProp;
  }, [inputValue, sourceProp, getFilterRegex, itemToString]);
  const itemTextHighlightPattern = useMemo(
    () => inputValue && inputValue.trim().length ? getFilterRegex(inputValue) : void 0,
    [inputValue, getFilterRegex]
  );
  const {
    focusedRef,
    listProps,
    state: listState,
    helpers: listHelpers
  } = useList({
    ...ListProps,
    source,
    disabled,
    virtualized,
    itemToString,
    displayedItemCount,
    onChange,
    onSelect,
    id: listId,
    disableFocus: true,
    disableMouseDown: true,
    selectionVariant: "multiple",
    initialSelectedItem: initialSelectedItems,
    selectedItem: selectedItemProp,
    "aria-labelledby": ariaLabelledBy
  });
  const { "aria-activedescendant": ariaActiveDescendant, ...restListProps } = listProps;
  const { selectedItem } = listState;
  const [quickSelection, setQuickSelection] = useState(false);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const selectedItems = selectedItem;
  const {
    setSelectedItem: setSelectedItems,
    setHighlightedIndex: setHighlightedListIndex
  } = listHelpers;
  const handleInputFocus = (event) => {
    handleFocusVisible(event);
    if (isFocusVisibleRef.current) {
      listHelpers.setFocusVisible(true);
    }
    if (InputProps.onInputFocus) {
      InputProps.onInputFocus(event);
    }
    notifyPopper(event);
  };
  const handleInputBlur = (event) => {
    handleBlurVisible();
    setAllowAnnouncement(false);
    setInputValue("");
    if (restListProps.onBlur) {
      restListProps.onBlur(event);
    }
    if (InputProps.onInputBlur) {
      InputProps.onInputBlur(event);
    }
    notifyPopper(event);
  };
  const handleInputChange = (event) => {
    setInputValue(event.target.value);
    setQuickSelection(event.target.value.length > 0 && !allowFreeText);
    if (InputProps.onInputChange) {
      InputProps.onInputChange(event);
    }
  };
  const handleItemsChange = (newItems) => {
    const uniqueItems = Array.from(new Set(newItems));
    setSelectedItems(uniqueItems);
    onChange && onChange(null, uniqueItems);
  };
  const handleInputSelect = (event) => {
    event.persist();
    setSelectionChanged(true);
    if (InputProps.onInputSelect) {
      InputProps.onInputSelect(event);
    }
  };
  const handleClear = () => {
    setSelectedItems([]);
  };
  const stringToItem = (selected, value) => {
    const trimmed = value.trim();
    const item = stringToItemProp(selected, trimmed);
    const isSelected = selected.map(itemToString).indexOf(trimmed) !== -1;
    return !isSelected && (allowFreeText || labels.indexOf(trimmed) !== -1) ? item : null;
  };
  const {
    inputRef,
    inputProps,
    state: inputState,
    helpers: inputHelpers
  } = useTokenizedInput({
    ...restProps,
    ...InputProps,
    disabled,
    itemToString,
    stringToItem,
    selectedItems,
    initialSelectedItems,
    onInputFocus: handleInputFocus,
    onInputBlur: handleInputBlur,
    onInputChange: handleInputChange,
    onInputSelect: handleInputSelect,
    onChange: handleItemsChange,
    onClear: handleClear,
    onKeyDown: InputProps.onKeyDown
  });
  const handleFocusVisibleRef = useForkRef(focusVisibleRef, focusedRef);
  const handleInputRef = useForkRef(inputRef, handleFocusVisibleRef);
  const { setHighlightedIndex: setHighlightedPillIndex } = inputHelpers;
  useEffect(() => {
    if (!isListOpen) {
      setHighlightedListIndex(void 0);
      setQuickSelection(false);
    }
  }, [isListOpen, setHighlightedListIndex, setQuickSelection]);
  const previousSelectedItems = usePrevious(selectedItems);
  useIsomorphicLayoutEffect(() => {
    if (selectedItems.some(
      (item) => !(previousSelectedItems || []).includes(item)
    )) {
      setInputValue("");
    }
    if (!selectedItems.length) {
      setHighlightedListIndex(void 0);
    }
  }, [
    selectedItems,
    previousSelectedItems,
    setInputValue,
    setHighlightedListIndex
  ]);
  useEffect(() => {
    if (inputState.highlightedIndex != null && inputState.highlightedIndex >= 0) {
      setHighlightedListIndex(void 0);
      setQuickSelection(false);
    }
  }, [inputState.highlightedIndex, setHighlightedListIndex, setQuickSelection]);
  const highlightedIndex = listState && listState.highlightedIndex;
  useEffect(() => {
    if (highlightedIndex != null && highlightedIndex >= 0) {
      setHighlightedPillIndex(void 0);
    }
  }, [highlightedIndex, setHighlightedPillIndex]);
  useEffect(() => {
    setHighlightedListIndex(void 0);
  }, [source, setHighlightedListIndex]);
  const handleFirstItemSelection = (event) => {
    if (!allowFreeText && event.key === "Enter" && quickSelection) {
      const newItem = source[0];
      const newSelectedItems = selectedItems.indexOf(newItem) === -1 ? selectedItems.concat(source.slice(0, 1)) : selectedItems.filter((item) => item !== newItem);
      setSelectedItems(newSelectedItems);
      onSelect && onSelect(event, newItem);
      onChange && onChange(event, newSelectedItems);
    }
  };
  const handleListOpenKeyDown = (event) => {
    if ("Escape" === event.key && inputProps.expanded) {
      setTimeout(() => {
        if (expandButtonRef.current) {
          expandButtonRef.current.focus();
        }
      }, 250);
    }
    handleFirstItemSelection(event);
    if ("Home" !== event.key && "End" !== event.key && !(" " === event.key && !event.ctrlKey)) {
      if (restListProps.onKeyDown) {
        restListProps.onKeyDown(event);
      }
      setSelectionChanged(false);
    }
  };
  const handleInputKeyDown = (event) => {
    if ("Escape" === event.key) {
      setInputValue("");
      setHighlightedListIndex(void 0);
    }
    if (" " === event.key && !event.ctrlKey) {
      setHighlightedPillIndex(void 0);
    } else {
      if (inputProps.onKeyDown) {
        inputProps.onKeyDown(
          event
        );
      }
    }
    if (!isToggleList(event) && listState.highlightedIndex == null && REQUIRE_PREV_HIGHLIGHT.indexOf(event.key) !== -1) {
      event.preventDefault();
      setHighlightedListIndex(
        Math.min(quickSelection ? 1 : 0, source.length - 1)
      );
      setQuickSelection(false);
      setSelectionChanged(false);
    } else if (isListOpen) {
      handleListOpenKeyDown(event);
    }
    setAllowAnnouncement("Backspace" !== event.key);
    notifyPopper(event);
  };
  const handleListClick = (event) => {
    clearTimeout(
      inputBlurTimeout.current == null ? void 0 : inputBlurTimeout.current
    );
    const inputEl = inputRef && inputRef.current;
    if (inputEl) {
      inputEl.focus();
    }
    if (restListProps.onClick) {
      restListProps.onClick(event);
    }
  };
  const mergedInputProps = {
    ...inputProps.InputProps,
    inputProps: {
      ...(inputProps.InputProps || {}).inputProps,
      role: "textbox",
      "aria-roledescription": "MultiSelect Combobox"
    }
  };
  if (ariaActiveDescendant && !selectionChanged) {
    mergedInputProps.inputProps["aria-activedescendant"] = ariaActiveDescendant;
  }
  const expandButtonProps = {
    accessibleText: void 0,
    role: "button",
    "aria-roledescription": "Expand combobox button",
    "aria-labelledby": [ariaLabelledBy, `${inputId}-input`].filter(Boolean).join(" ")
  };
  return {
    inputHelpers,
    inputRef: handleInputRef,
    listContext: {
      state: listState,
      helpers: listHelpers
    },
    inputProps: {
      ...inputProps,
      selectedItems,
      allowAnnouncement,
      id: inputId,
      value: inputValue,
      ExpandButtonProps: expandButtonProps,
      InputProps: mergedInputProps,
      onKeyDown: handleInputKeyDown
    },
    listProps: {
      ...restListProps,
      source,
      itemToString,
      itemTextHighlightPattern,
      onClick: handleListClick,
      isListOpen: isListOpen && Boolean(source.length)
    }
  };
};

export { useMultiSelectComboBox };
//# sourceMappingURL=useMultiSelectComboBox.js.map
