import { useMemo } from 'react';

const updateValueItemNotPushable = (oldValue, index, valueItem, min, max) => {
  const newValue = [...oldValue];
  if (valueItem < oldValue[index]) {
    const constraint = index === 0 ? min : newValue[index - 1];
    newValue[index] = Math.max(constraint, valueItem);
  } else {
    const constraint = index === newValue.length - 1 ? max : newValue[index + 1];
    newValue[index] = Math.min(constraint, valueItem);
  }
  return newValue;
};
const updateValueItemPushable = (oldValue, index, valueItem, min, max, pushDistance) => {
  const newValue = [...oldValue];
  newValue[index] = valueItem;
  if (valueItem < oldValue[index]) {
    for (let i = index - 1; i >= 0; --i) {
      if (newValue[i + 1] - newValue[i] < pushDistance) {
        newValue[i] = newValue[i + 1] - pushDistance;
      } else {
        break;
      }
    }
    const distToMin = newValue[0] - min;
    if (distToMin < 0) {
      for (let i = index; i >= 0; --i) {
        newValue[i] -= distToMin;
      }
    }
  } else {
    for (let i = index + 1; i < newValue.length; ++i) {
      if (newValue[i] - newValue[i - 1] < pushDistance) {
        newValue[i] = newValue[i - 1] + pushDistance;
      } else {
        break;
      }
    }
    const distToMax = max - newValue[newValue.length - 1];
    if (distToMax < 0) {
      for (let i = index; i < newValue.length; ++i) {
        newValue[i] += distToMax;
      }
    }
  }
  return newValue;
};
function useValueUpdater(pushable, pushDistance, min, max) {
  return useMemo(() => {
    const updater = pushable ? (oldValue, index, valueItem) => updateValueItemPushable(
      oldValue,
      index,
      valueItem,
      min,
      max,
      pushDistance
    ) : (oldValue, index, valueItem) => updateValueItemNotPushable(oldValue, index, valueItem, min, max);
    return (oldValue, index, valueItem) => {
      if (!Array.isArray(oldValue)) {
        return valueItem;
      }
      if (oldValue[index] === valueItem) {
        return oldValue;
      }
      const newValue = updater(oldValue, index, valueItem);
      if (-1 === newValue.findIndex((v, i) => oldValue[i] !== v)) {
        return oldValue;
      }
      return newValue;
    };
  }, [pushable, pushDistance, min, max]);
}
const roundValue = (v, step) => Math.round(v / step) * step;
const clampValue = (v, min, max) => {
  if (v < min) {
    return min;
  }
  if (v > max) {
    return max;
  }
  return v;
};
function getSliderAriaLabel(count, index) {
  if (count < 2) {
    return;
  }
  if (count === 2) {
    return index === 0 ? "Min" : "Max";
  }
  if (index >= 0 && index < 10) {
    return [
      "First",
      "Second",
      "Third",
      "Fourth",
      "Fifth",
      "Sixth",
      "Seventh",
      "Eighth",
      "Ninth",
      "Tenth"
    ][index];
  }
  return;
}
function getHandleIndex(element) {
  const handleIndexAttribute = element.getAttribute("data-handle-index");
  if (handleIndexAttribute) {
    return parseInt(handleIndexAttribute, 10);
  }
  return getHandleIndex(element.parentElement);
}
function isLabeledMark(mark) {
  return typeof mark !== "number";
}
function isMarkAtMax(max, mark) {
  return max === (isLabeledMark(mark) ? mark.value : mark);
}

export { clampValue, getHandleIndex, getSliderAriaLabel, isLabeledMark, isMarkAtMax, roundValue, useValueUpdater };
//# sourceMappingURL=utils.js.map
