import { useDensity, useId, useControlled, ownerWindow } from '@salt-ds/core';
import copy from 'clipboard-copy';
import { useState, useRef, useCallback, useEffect } from 'react';
import { escapeRegExp } from '../utils/escapeRegExp.js';
import { useEventCallback } from '../utils/useEventCallback.js';
import { defaultItemToString } from './internal/defaultItemToString.js';
import { getCursorPosition } from './internal/getCursorPosition.js';
import '../form-field-context-legacy/FormFieldLegacyContext.js';
import { useFormFieldLegacyProps } from '../form-field-context-legacy/useFormFieldLegacyProps.js';

const BLUR_TIMEOUT = 200;
const SINGLE_LINE_HEIGHT_MAP = {
  touch: 45,
  low: 36,
  medium: 28,
  high: 23
};
function isValidItem(data) {
  return typeof data === "string" && Boolean(data.length) || typeof data !== "string" && data != null;
}
function useTokenizedInput(props) {
  validateProps(props);
  const {
    inFormField,
    popoutMode,
    popoutActions,
    setIsPoppedOut,
    setManagedPopout,
    setIntendedHeight,
    a11yProps: {
      "aria-labelledby": ariaLabelledBy,
      disabled: formFieldDisabled
    } = {}
  } = useFormFieldLegacyProps();
  const density = useDensity();
  const {
    delimiter = ",",
    initialSelectedItems = [],
    itemToString = defaultItemToString,
    stringToItem = (_, value2) => value2.trim(),
    disabled = formFieldDisabled,
    disableAddOnBlur,
    onFocus,
    onBlur,
    onClick,
    onExpand,
    onCollapse,
    onKeyUp,
    onKeyDown,
    onInputSelect,
    onInputChange,
    onInputFocus,
    onInputBlur,
    onClear,
    id: idProp,
    value: valueProp,
    expanded: expandedProp,
    selectedItems: selectedItemsProp,
    onChange: onChangeProp,
    "aria-label": ariaLabel,
    ...restProps
  } = props;
  const id = useId(idProp);
  const [value, setValue, isInputControlled] = useControlled({
    controlled: valueProp,
    default: "",
    name: "TokenizedInput",
    state: "value"
  });
  const [
    selectedItems = [],
    setSelectedItems,
    isSelectionControlled
  ] = useControlled({
    controlled: selectedItemsProp,
    default: initialSelectedItems,
    name: "TokenizedInput",
    state: "selectedItems"
  });
  const [expanded, setExpanded, isExpandedControlled] = useControlled({
    controlled: expandedProp,
    default: false,
    name: "TokenizedInput",
    state: "expanded"
  });
  const [activeIndices, setActiveIndices] = useState([]);
  const [highlightedIndex, setHighlightedIndex] = useState(
    void 0
  );
  const [focused, setFocusedState] = useState(false);
  const inputRef = useRef(null);
  const blurTimeout = useRef(null);
  const preventBlurOnCopy = useRef(false);
  const hasActiveItems = Boolean(activeIndices.length);
  const delimiters = [].concat(delimiter);
  const primaryDelimiter = delimiters[0];
  const delimiterRegex = new RegExp(
    delimiters.map(escapeRegExp).join("|"),
    "gi"
  );
  const onChange = useEventCallback((selectedItems2) => {
    if (onChangeProp) {
      onChangeProp(selectedItems2);
    }
  });
  const cancelBlur = useCallback(() => {
    if (blurTimeout.current) {
      clearTimeout(blurTimeout.current);
    }
    blurTimeout.current = null;
  }, []);
  const focusInput = useCallback(() => {
    if (inputRef.current) {
      inputRef.current.focus();
      if (popoutMode && setIsPoppedOut) {
        setIsPoppedOut(true);
      }
    }
  }, [popoutMode, setIsPoppedOut]);
  useEffect(
    () => () => {
      cancelBlur();
    },
    [cancelBlur]
  );
  useEffect(() => {
    if (expanded) {
      focusInput();
    }
  }, [expanded, focusInput]);
  useEffect(() => {
    if (popoutMode && setManagedPopout) {
      setManagedPopout(true);
      setIntendedHeight(SINGLE_LINE_HEIGHT_MAP[density]);
    }
  }, [density, popoutMode, setIntendedHeight, setManagedPopout]);
  const updateInputValue = (newValue) => {
    if (!isInputControlled) {
      setValue(newValue);
    }
  };
  const updateSelectedItems = useCallback(
    (action) => {
      if (!isSelectionControlled) {
        setSelectedItems((prevSelectedItems) => {
          const newItems = typeof action === "function" ? action(prevSelectedItems) : action;
          if (newItems !== prevSelectedItems) {
            onChange(newItems);
          }
          return newItems;
        });
      } else {
        onChange(typeof action === "function" ? action(selectedItems) : action);
      }
    },
    [isSelectionControlled, setSelectedItems, onChange, selectedItems]
  );
  const updateExpanded = (newExpanded) => {
    if (!isExpandedControlled) {
      setExpanded(newExpanded);
    }
    if (newExpanded) {
      onExpand && onExpand();
    } else {
      onCollapse && onCollapse();
    }
    if (popoutMode && popoutActions) {
      popoutActions.refresh();
    }
  };
  const setFocused = (newState) => {
    setFocusedState(newState);
  };
  const resetInput = () => {
    updateInputValue("");
    setHighlightedIndex(void 0);
    setActiveIndices([]);
  };
  const removeItems = useCallback(
    (itemIndices) => {
      updateSelectedItems(
        (prevSelectedItems) => prevSelectedItems && (prevSelectedItems.length === 0 ? prevSelectedItems : prevSelectedItems.filter(
          (_, index) => itemIndices.indexOf(index) === -1
        ))
      );
    },
    [updateSelectedItems]
  );
  const handleInputFocus = (event) => {
    event.stopPropagation();
    if (preventBlurOnCopy.current) {
      preventBlurOnCopy.current = false;
      setActiveIndices(
        Array.from(
          { length: selectedItems ? selectedItems.length : 0 },
          (_, index) => index
        )
      );
      return;
    }
    setFocused(true);
    if (onInputFocus) {
      onInputFocus(event);
    }
    if (blurTimeout.current !== null) {
      cancelBlur();
    } else {
      updateExpanded(true);
      if (onFocus) {
        onFocus(event);
      }
    }
  };
  const handleInputBlur = (event) => {
    event.stopPropagation();
    setFocused(false);
    setHighlightedIndex(void 0);
    setActiveIndices([]);
    if (onInputBlur) {
      onInputBlur(event);
    }
    handleBlur(event);
  };
  const handleBlur = (event) => {
    if (preventBlurOnCopy.current) {
      return focusInput();
    }
    event.persist();
    blurTimeout.current = setTimeout(() => {
      blurTimeout.current = null;
      updateExpanded(false);
      if (!disableAddOnBlur) {
        handleAddItems(value, true);
      }
      if (onBlur) {
        onBlur(event);
      }
      if (popoutMode && setIsPoppedOut) {
        setIsPoppedOut(false);
      }
    }, BLUR_TIMEOUT);
  };
  const handleClick = (event) => {
    updateExpanded(true);
    setActiveIndices([]);
    focusInput();
    if (onClick) {
      onClick(event);
    }
  };
  const handleInputChange = (event) => {
    setHighlightedIndex(void 0);
    if (onInputChange) {
      onInputChange(event);
    }
    const newValue = event.target.value;
    if (delimiterRegex.test(newValue)) {
      handleAddItems(newValue);
    } else {
      updateInputValue(newValue);
    }
  };
  const handleAddItems = (newValue, appendOnly) => {
    if (!newValue || newValue.length === 0) {
      return;
    }
    resetInput();
    const newItems = newValue.split(delimiterRegex).reduce((values, part) => {
      const newItem = stringToItem(
        hasActiveItems ? values : selectedItems.concat(values),
        part
      );
      return isValidItem(newItem) ? values.concat(newItem) : values;
    }, []);
    if (newItems.length) {
      updateSelectedItems(
        (prevSelectedItems = []) => hasActiveItems && !appendOnly ? newItems : prevSelectedItems.concat(newItems)
      );
    }
  };
  const handleRemoveItem = useCallback(
    (itemIndex) => {
      focusInput();
      if (itemIndex) {
        removeItems([itemIndex]);
      }
    },
    [focusInput, removeItems]
  );
  const handleClear = (event) => {
    updateSelectedItems([]);
    resetInput();
    focusInput();
    if (onClear) {
      onClear(event);
    }
    if (popoutMode && popoutActions) {
      popoutActions.refresh();
    }
  };
  const cursorAtInputStart = () => getCursorPosition(inputRef) === 0 && Boolean(selectedItems.length);
  const highlightAtPillGroupEnd = () => highlightedIndex === selectedItems.length - 1;
  const pillGroupKeyDownHandlers = {
    ArrowLeft: (event) => {
      event.preventDefault();
      setHighlightedIndex(
        (prevHighlightedIndex) => prevHighlightedIndex == null ? selectedItems.length - 1 : Math.max(0, prevHighlightedIndex - 1)
      );
    },
    ArrowRight: (event) => {
      if (highlightAtPillGroupEnd()) {
        return setHighlightedIndex(void 0);
      }
      event.preventDefault();
      setHighlightedIndex(
        (prevHighlightedIndex) => prevHighlightedIndex == null ? prevHighlightedIndex : Math.min(selectedItems.length - 1, prevHighlightedIndex + 1)
      );
    },
    Backspace: (event) => {
      event.preventDefault();
      handleRemoveItem(highlightedIndex);
      setHighlightedIndex(
        (prevHighlightedIndex) => prevHighlightedIndex == null ? prevHighlightedIndex : Math.max(0, prevHighlightedIndex - 1)
      );
    },
    Home: (event) => {
      event.preventDefault();
      setHighlightedIndex(0);
    },
    End: (event) => {
      event.preventDefault();
      setHighlightedIndex(selectedItems.length - 1);
    },
    Enter: (event) => {
      event.preventDefault();
      handleRemoveItem(highlightedIndex);
    },
    Delete: (event) => {
      event.preventDefault();
      handleRemoveItem(highlightedIndex);
    },
    " ": (event) => {
      event.preventDefault();
      handleRemoveItem(highlightedIndex);
    }
  };
  const inputKeyDownHandlers = {
    ArrowLeft: (event) => {
      if (cursorAtInputStart()) {
        event.preventDefault();
        setHighlightedIndex(selectedItems.length - 1);
      }
    },
    Backspace: () => {
      if (hasActiveItems) {
        removeItems(activeIndices);
      } else if (cursorAtInputStart()) {
        setHighlightedIndex(selectedItems.length - 1);
      }
    },
    Delete: () => {
      if (hasActiveItems) {
        removeItems(activeIndices);
      }
    },
    Enter: (event) => {
      event.preventDefault();
      if (hasActiveItems) {
        removeItems(activeIndices);
      } else {
        handleAddItems(value);
      }
    }
  };
  const handleCtrlModifierKeyDown = (event) => {
    const win = ownerWindow(event.target);
    const supportClipboard = win.navigator && win.navigator.clipboard;
    switch (event.key.toUpperCase()) {
      case "A":
        setHighlightedIndex(void 0);
        setActiveIndices(
          Array.from({ length: selectedItems.length }, (_, index) => index)
        );
        break;
      case "C":
        copy(
          activeIndices.map((index) => itemToString(selectedItems[index])).concat(value != null ? String(value).trim() : "").filter(Boolean).join(primaryDelimiter)
        ).then((result) => {
          preventBlurOnCopy.current = !supportClipboard;
          return result;
        }).catch((error) => {
          console.error(error);
        });
        break;
      case "V":
        break;
      case "ARROWLEFT":
        pillGroupKeyDownHandlers.ArrowLeft(event);
        break;
      case "ARROWRIGHT":
        pillGroupKeyDownHandlers.ArrowRight(event);
        break;
      case "BACKSPACE":
        if (cursorAtInputStart()) {
          handleRemoveItem(selectedItems.length - 1);
        }
        break;
      case "CONTROL":
      case "META":
        break;
      default:
        setActiveIndices([]);
    }
  };
  const handleCommonKeyDown = (event) => {
    const eventKey = event.key.toUpperCase();
    if (eventKey === "ESCAPE") {
      event.preventDefault();
      resetInput();
    } else if (eventKey === "TAB" && !disableAddOnBlur) {
      handleAddItems(value);
    }
  };
  const handleKeyDown = (event) => {
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.ctrlKey || event.metaKey || ["CONTROL", "META"].indexOf(event.key.toUpperCase()) !== -1) {
      handleCtrlModifierKeyDown(event);
    } else {
      let handler;
      if (highlightedIndex == null) {
        handler = inputKeyDownHandlers[event.key];
        setActiveIndices([]);
      } else {
        handler = pillGroupKeyDownHandlers[event.key];
      }
      if (handler != null) {
        handler(event);
      } else {
        handleCommonKeyDown(event);
      }
    }
    if (popoutMode && popoutActions) {
      popoutActions.refresh();
    }
  };
  const state = {
    value,
    selectedItems,
    activeIndices,
    highlightedIndex,
    expanded,
    focused: !inFormField && focused
  };
  const eventHandlers = {
    onFocus,
    onBlur: expanded ? handleBlur : onBlur,
    onClick: handleClick,
    onInputSelect,
    onInputChange: handleInputChange,
    onInputFocus: handleInputFocus,
    onInputBlur: handleInputBlur,
    onKeyDown: handleKeyDown,
    onRemoveItem: handleRemoveItem,
    onClear: handleClear
  };
  return {
    inputRef,
    state,
    helpers: {
      cancelBlur,
      setValue,
      setSelectedItems,
      setHighlightedIndex,
      setFocused,
      updateExpanded
    },
    inputProps: {
      id,
      itemToString,
      disabled,
      "aria-labelledby": ariaLabelledBy,
      "aria-label": ariaLabel,
      ...state,
      ...restProps,
      ...disabled ? {} : eventHandlers
    }
  };
}
const validateProps = function validateProps2(props) {
  if (process.env.NODE_ENV !== "production") {
    const { delimiter } = props;
    const invalidDelimiter = Array.isArray(delimiter) ? delimiter.every(isChar) : isChar(delimiter);
    useEffect(() => {
      console.warn(
        "TokenizedInput delimiter should be a single character or an array of single characters"
      );
    }, [invalidDelimiter]);
  }
};
const isChar = (value) => typeof value === "string" && value.length === 1;

export { useTokenizedInput };
//# sourceMappingURL=useTokenizedInput.js.map
