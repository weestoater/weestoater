import { useForkRef, useControlled } from '@salt-ds/core';
import { useRef, useState, useMemo } from 'react';
import { usePopperStatus } from './internal/usePopperStatus.js';
import 'react/jsx-runtime';
import '../responsive/useResizeObserver.js';
import { useWidth } from '../responsive/useWidth.js';

function useQueryInput(props, forwardedRef) {
  const bodyRef = useRef(null);
  const popperRef = useRef(null);
  const inputRef = useRef(null);
  const [widthBodyRef, bodyWidth] = useWidth(true);
  const forkedRef1 = useForkRef(
    forwardedRef,
    bodyRef
  );
  const queryInputBodyRef = useForkRef(
    forkedRef1,
    widthBodyRef
  );
  const [selectedItems, setSelectedItems] = useControlled({
    controlled: props.selectedItems,
    default: props.defaultSelectedItems || [],
    name: "QueryInput",
    state: "selectedItems"
  });
  const [booleanOperator, setBooleanOperator] = useControlled({
    controlled: props.booleanOperator,
    default: props.defaultBooleanOperator || "and",
    name: "QueryInput",
    state: "booleanOperator"
  });
  const popperStatus = usePopperStatus({
    initialOpen: false,
    autoClose: props.autoClose
  });
  const [isFocused, setIsFocused] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState(0);
  const [highlightedCategoryIndex, setHighlightedCategoryIndex] = useState(0);
  const [highlightedValueIndex, setHighlightedValueIndex] = useState(0);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const searchListIndexPositions = useRef(
    []
  );
  const onInputFocus = (event) => {
    popperStatus.onFocus(event);
    setIsFocused(true);
  };
  const onInputBlur = (event) => {
    if (!inputRef.current) {
      return;
    }
    const relatedTarget = event.relatedTarget;
    const isBodyFocused = bodyRef.current === relatedTarget;
    if (isBodyFocused) {
      inputRef.current.focus();
      return;
    }
    const isFocusWithinBody = bodyRef.current && bodyRef.current.contains(relatedTarget);
    if (isFocusWithinBody) {
      return;
    }
    const isFocusWithinPopper = popperRef.current && popperRef.current.contains(relatedTarget);
    if (isFocusWithinPopper) {
      inputRef.current.focus();
      return;
    }
    setIsFocused(false);
    popperStatus.onBlur(event);
  };
  const onFocus = (event) => {
    setIsFocused(true);
    popperStatus.onFocus(event);
  };
  const onBlur = (event) => {
    let relatedTarget = event.relatedTarget;
    const isBodyFocused = bodyRef.current === relatedTarget;
    if (isBodyFocused) {
      return;
    }
    const isFocusWithinBody = bodyRef.current && bodyRef.current.contains(relatedTarget);
    if (isFocusWithinBody) {
      return;
    }
    const isFocusWithinPopper = popperRef.current && popperRef.current.contains(relatedTarget);
    if (isFocusWithinPopper) {
      return;
    }
    setIsFocused(false);
    popperStatus.onBlur(event);
  };
  const onSelectedItemsChange = (newItems) => {
    const newItem = newItems && newItems.find(
      (item) => item.category == null && item.value === inputValue
    );
    if (newItem) {
      setInputValue("");
    }
    setSelectedItems(newItems || []);
    if (props.onChange) {
      props.onChange(newItems || []);
    }
    popperStatus.onChange();
  };
  const onBooleanOperatorChange = (operator) => {
    setBooleanOperator(operator);
    if (props.onBooleanOperatorChange) {
      props.onBooleanOperatorChange(operator);
    }
  };
  const onSelectedCategoryChange = (category) => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
    setSelectedCategory(category);
  };
  const [inputValue, setInputValue] = useState("");
  const searchListItems = useMemo(() => {
    const [searchListItems2, indexPositions] = filterCategories(
      props.categories,
      inputValue
    );
    searchListIndexPositions.current = indexPositions;
    return searchListItems2;
  }, [props.categories, inputValue]);
  const onInputChange = (event) => {
    const newInputValue = event.target.value;
    setInputValue(newInputValue);
    setHighlightedIndex(searchListIndexPositions.current.length === 0 ? 0 : 1);
  };
  const searchListItemCount = useMemo(() => {
    return searchListItems.reduce(
      (acc, category) => acc + category.values.length,
      0
    );
  }, [searchListItems]);
  const onInputClear = () => {
    onSelectedItemsChange([]);
  };
  const onInputClick = () => {
    popperStatus.onClick();
  };
  const newItemFromSelected = () => {
    const i = highlightedIndex;
    for (const category of searchListItems) {
      if (i < category.values.length) {
        const value = category.values[i];
        return {
          category: category.name,
          value
        };
      }
    }
  };
  const { displayedItemCount = 10 } = props;
  const onSearchListKeyDown = (key) => {
    switch (key) {
      case "Home":
        setHighlightedIndex(0);
        return;
      case "End":
        setHighlightedIndex(searchListItemCount);
        return;
      case "ArrowUp":
        setHighlightedIndex(
          (i) => prevSearchItemIndex(i, searchListIndexPositions.current)
        );
        return;
      case "ArrowDown":
        setHighlightedIndex(
          (i) => nextSearchItemIndex(i, searchListIndexPositions.current)
        );
        return;
      case "PageDown":
        setHighlightedIndex(
          (i) => Math.min(searchListItemCount, i + displayedItemCount)
        );
        return;
      case "PageUp":
        setHighlightedIndex((i) => Math.max(0, i - displayedItemCount));
        return;
      case "Enter":
        if (highlightedIndex === searchListItemCount) {
          const newItems = [
            ...selectedItems,
            { category: null, value: inputValue }
          ];
          onSelectedItemsChange(newItems);
        } else {
          if (highlightedIndex >= 0 && highlightedIndex < searchListItemCount) {
            const newItem = newItemFromSelected();
            if (newItem) {
              const newItems = [...selectedItems, newItem];
              onSelectedItemsChange(newItems);
            }
          }
          setInputValue("");
        }
        return;
      default:
        return;
    }
  };
  const onCategoryListKeyDown = (key) => {
    switch (key) {
      case "Home":
        setHighlightedCategoryIndex(0);
        return;
      case "End":
        setHighlightedCategoryIndex(props.categories.length - 1);
        return;
      case "ArrowUp":
        setHighlightedCategoryIndex((i) => Math.max(0, i - 1));
        return;
      case "ArrowDown":
        setHighlightedCategoryIndex(
          (i) => Math.min(props.categories.length - 1, i + 1)
        );
        return;
      case "PageUp":
        setHighlightedCategoryIndex((i) => Math.max(0, i - displayedItemCount));
        return;
      case "PageDown":
        setHighlightedCategoryIndex(
          (i) => Math.min(props.categories.length - 1, i + displayedItemCount)
        );
        return;
      case "Enter":
        if (highlightedCategoryIndex >= 0 && highlightedCategoryIndex < props.categories.length) {
          const category = props.categories[highlightedCategoryIndex];
          setSelectedCategory(category);
        }
        return;
      case "ArrowRight":
        if (highlightedCategoryIndex >= 0 && highlightedCategoryIndex < props.categories.length) {
          const category = props.categories[highlightedCategoryIndex];
          setSelectedCategory(category);
        }
        return;
      default:
        return;
    }
  };
  const onValueListKeyDown = (key) => {
    switch (key) {
      case "Home":
        setHighlightedValueIndex(0);
        return;
      case "End":
        setHighlightedValueIndex(selectedCategory.values.length);
        return;
      case "ArrowUp":
        setHighlightedValueIndex((i) => Math.max(0, i - 1));
        return;
      case "ArrowDown":
        setHighlightedValueIndex(
          (i) => Math.min(selectedCategory.values.length, i + 1)
        );
        return;
      case "PageUp":
        setHighlightedValueIndex((i) => Math.max(0, i - displayedItemCount));
        return;
      case "PageDown":
        setHighlightedValueIndex(
          (i) => Math.min(selectedCategory.values.length, i + displayedItemCount)
        );
        return;
      case "Enter":
        if (highlightedValueIndex === 0) {
          setSelectedCategory(null);
        } else {
          const value = selectedCategory.values[highlightedValueIndex - 1];
          const newItems = selectedItems.filter(
            (item) => !(item.category === selectedCategory.name && item.value === value)
          );
          if (newItems.length === selectedItems.length) {
            newItems.push({ category: selectedCategory.name, value });
          }
          onSelectedItemsChange(newItems);
        }
        return;
      case "ArrowLeft":
        setSelectedCategory(null);
        return;
      default:
        return;
    }
  };
  const onKeyDown = (event) => {
    popperStatus.onKeyDown(event);
    let key = event.key;
    if (event.key === " " && event.ctrlKey) {
      key = "Enter";
    }
    const isSearchListActive = inputValue !== "";
    const isCategoryListActive = !isSearchListActive && !selectedCategory;
    const isValueListActive = !isSearchListActive && !isCategoryListActive;
    if (isSearchListActive) {
      onSearchListKeyDown(key);
    } else if (isCategoryListActive) {
      onCategoryListKeyDown(key);
    } else {
      onValueListKeyDown(key);
    }
    switch (event.key) {
      case "ArrowUp":
      case "ArrowDown":
      case "Enter":
        event.preventDefault();
        break;
      case "ArrowLeft":
        if (isValueListActive) {
          event.preventDefault();
        }
        break;
      case "ArrowRight":
        if (isCategoryListActive) {
          event.preventDefault();
        }
        break;
      case "Escape":
        setInputValue("");
    }
  };
  const onValueToggle = (category, value) => {
    const newItems = selectedItems.filter(
      (item) => !(item.category === category.name && item.value === value)
    );
    if (newItems.length === selectedItems.length) {
      newItems.push({ category: category.name, value });
    }
    onSelectedItemsChange(newItems);
  };
  return {
    queryInputBodyRef,
    queryInputProps: {
      onFocus,
      onBlur
    },
    queryInputBodyProps: {
      inputRef,
      disabled: props.disabled,
      selectedItems,
      onFocus,
      onBlur,
      onInputClick,
      onInputFocus,
      onInputBlur,
      onInputClear,
      inputValue,
      onInputChange,
      onSelectedItemsChange,
      onKeyDown,
      isFocused,
      booleanOperator,
      onBooleanOperatorChange
    },
    valueSelectorProps: {
      isOpen: popperStatus.isOpen,
      categories: props.categories,
      selectedCategory,
      selectedItems,
      onValueToggle,
      onSearchListChange: onSelectedItemsChange,
      anchorElement: bodyRef.current,
      width: bodyWidth,
      onSelectedCategoryChange,
      popperRef,
      inputValue,
      highlightedIndex,
      visibleCategories: searchListItems,
      highlightedCategoryIndex,
      highlightedValueIndex,
      setHighlightedCategoryIndex,
      setHighlightedValueIndex,
      setHighlightedIndex
    }
  };
}
function filterCategories(categories, inputValue) {
  if (!inputValue) {
    return [categories, []];
  }
  const query = inputValue.toUpperCase();
  const visibleCategories = [];
  const indexPositions = [];
  for (const c of categories) {
    const values = c.values.filter((v) => v.toUpperCase().includes(query));
    if (values.length > 0) {
      const queryInputCategory = {
        name: c.name,
        values
      };
      visibleCategories.push(queryInputCategory);
      indexPositions.push(queryInputCategory, ...values);
    }
  }
  return [visibleCategories, indexPositions];
}
function nextSearchItemIndex(index, indexPositions) {
  const nextIndex = index + 1;
  if (nextIndex === indexPositions.length + 1) {
    return index;
  } else if (nextIndex === indexPositions.length) {
    return nextIndex;
  } else if (typeof indexPositions[nextIndex] === "string") {
    return nextIndex;
  } else {
    return nextIndex + 1;
  }
}
function prevSearchItemIndex(index, indexPositions) {
  const nextIndex = index - 1;
  if (nextIndex === 0) {
    return index;
  } else if (typeof indexPositions[nextIndex] === "string") {
    return nextIndex;
  } else {
    return nextIndex - 1;
  }
}

export { useQueryInput };
//# sourceMappingURL=useQueryInput.js.map
