import { jsx, jsxs } from 'react/jsx-runtime';
import { makePrefixer, useForkRef, useControlled } from '@salt-ds/core';
import clsx from 'clsx';
import { forwardRef, useRef, useState, useCallback, useMemo } from 'react';
import { useComponentCssInjection } from '@salt-ds/styles';
import { useWindow } from '@salt-ds/window';
import { Overflow } from '@fluentui/react-overflow';
import { OverflowMenu } from './OverflowMenu.js';
import css_248z from './TabstripNext.css.js';
import { TabsContext } from './TabNextContext.js';

const withBaseName = makePrefixer("saltTabstripNext");
const TabstripNext = forwardRef(
  function TabstripNext2(props, ref) {
    const {
      activeColor = "primary",
      align = "left",
      children,
      className,
      value: valueProp,
      defaultValue,
      onChange,
      onKeyDown,
      style,
      variant = "main",
      ...rest
    } = props;
    const targetWindow = useWindow();
    useComponentCssInjection({
      testId: "salt-tabstrip-next",
      css: css_248z,
      window: targetWindow
    });
    const tabstripRef = useRef(null);
    const handleRef = useForkRef(tabstripRef, ref);
    const [value, setValue] = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "TabstripNext",
      state: "selected"
    });
    const [focusable, setFocusableState] = useState(value);
    const [overflowOpen, setOverflowOpen] = useState(false);
    const activate = useCallback(
      (event) => {
        const newValue = event.currentTarget.value;
        setValue(newValue);
        if (value !== newValue) {
          onChange == null ? void 0 : onChange(event, { value: newValue });
        }
      },
      [onChange, value, setValue]
    );
    const isActive = useCallback(
      (id) => {
        return value === id;
      },
      [value]
    );
    const setFocusable = useCallback((id) => {
      setFocusableState(id);
    }, []);
    const isFocusable = useCallback(
      (id) => {
        return focusable === id || !focusable;
      },
      [focusable]
    );
    const [tabList, setTabList] = useState([]);
    const registerTab = useCallback((tab) => {
      setTabList((list) => list.concat([tab]));
    }, []);
    const unregisterTab = useCallback((id) => {
      setTabList((list) => list.filter((item) => item.value !== id));
    }, []);
    const handleKeyDown = (event) => {
      var _a, _b, _c, _d, _e, _f;
      if (overflowOpen)
        return;
      const elements = Array.from(
        (_b = (_a = tabstripRef.current) == null ? void 0 : _a.querySelectorAll(
          `div:not([data-overflowing]) > [role="tab"]:not([disabled])`
        )) != null ? _b : []
      );
      const currentIndex = elements.findIndex(
        (element) => element === (targetWindow == null ? void 0 : targetWindow.document.activeElement)
      );
      if (currentIndex < 0)
        return;
      switch (event.key) {
        case "ArrowDown":
        case "ArrowRight":
          (_c = elements[Math.min(currentIndex + 1, elements.length)]) == null ? void 0 : _c.focus();
          break;
        case "ArrowUp":
        case "ArrowLeft":
          (_d = elements[Math.max(0, currentIndex - 1)]) == null ? void 0 : _d.focus();
          break;
        case "Home":
          (_e = elements[0]) == null ? void 0 : _e.focus();
          break;
        case "End":
          (_f = elements[elements.length - 1]) == null ? void 0 : _f.focus();
      }
      onKeyDown == null ? void 0 : onKeyDown(event);
    };
    const handleOverflowItemClick = (event, item) => {
      if (item) {
        setValue(item.value);
        requestAnimationFrame(() => {
          var _a;
          const element = (_a = tabstripRef.current) == null ? void 0 : _a.querySelector(
            `[value="${item.value}"]`
          );
          if (element instanceof HTMLElement) {
            element == null ? void 0 : element.focus();
          }
        });
        if (value !== item.value) {
          onChange == null ? void 0 : onChange(event, { value: item.value });
        }
      }
    };
    const handleOverflowOpenChange = (isOpen) => {
      setOverflowOpen(isOpen);
    };
    const contextValue = useMemo(
      () => ({
        activate,
        isActive,
        setFocusable,
        isFocusable,
        registerTab,
        unregisterTab,
        variant,
        activeColor
      }),
      [
        activate,
        isActive,
        setFocusable,
        isFocusable,
        registerTab,
        unregisterTab,
        variant,
        activeColor
      ]
    );
    const tabstripStyle = {
      "--tabstripNext-justifyContent": align,
      ...style
    };
    return /* @__PURE__ */ jsx(TabsContext.Provider, {
      value: contextValue,
      children: /* @__PURE__ */ jsx("div", {
        className: clsx(withBaseName("container"), withBaseName(variant)),
        children: /* @__PURE__ */ jsx(Overflow, {
          ref: handleRef,
          children: /* @__PURE__ */ jsxs("div", {
            role: "tablist",
            className: clsx(
              withBaseName(),
              withBaseName("horizontal"),
              className
            ),
            onKeyDown: handleKeyDown,
            style: tabstripStyle,
            ...rest,
            children: [
              children,
              /* @__PURE__ */ jsx(OverflowMenu, {
                tabs: tabList,
                onOpenChange: handleOverflowOpenChange,
                onSelectionChange: handleOverflowItemClick
              })
            ]
          })
        })
      })
    });
  }
);

export { TabstripNext };
//# sourceMappingURL=TabstripNext.js.map
