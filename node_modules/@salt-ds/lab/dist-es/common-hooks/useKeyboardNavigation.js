import { useControlled } from '@salt-ds/core';
import { useRef, useState, useCallback, useMemo } from 'react';
import { PageDown, ArrowUp, ArrowDown, Home, End, PageUp, isNavigationKey, isCharacterKey } from './keyUtils.js';
import { hasSelection, getFirstSelectedItem } from './selectionTypes.js';

const LIST_FOCUS_VISIBLE = -2;
function nextItemIdx(count, key, idx) {
  if (key === ArrowUp || key === End) {
    if (idx > 0) {
      return idx - 1;
    } else {
      return idx;
    }
  } else {
    if (idx === null) {
      return 0;
    } else if (idx === count - 1) {
      return idx;
    } else {
      return idx + 1;
    }
  }
}
const getIndexOfSelectedItem = (items, selected) => {
  const selectedItem = getFirstSelectedItem(selected);
  if (selectedItem) {
    return items.indexOf(selectedItem);
  } else {
    return -1;
  }
};
const getStartIdx = (key, idx, selectedIdx, length) => {
  if (key === End) {
    return length;
  } else if (key === Home) {
    return -1;
  } else if (idx !== -1) {
    return idx;
  } else {
    return selectedIdx;
  }
};
const getItemRect = (item) => {
  const el = document.getElementById(item.id);
  if (el) {
    return el.getBoundingClientRect();
  } else {
    throw Error(
      `useKeyboardNavigation.getItemRect no element found for item  #${item == null ? void 0 : item.id}`
    );
  }
};
const pageDown = (containerEl, itemEl, indexPositions, index) => {
  const { top: itemTop } = itemEl.getBoundingClientRect();
  const { scrollTop, clientHeight, scrollHeight } = containerEl;
  const lastIndexPosition = indexPositions.length - 1;
  const newScrollTop = Math.min(
    scrollTop + clientHeight,
    scrollHeight - clientHeight
  );
  if (newScrollTop !== scrollTop && index < lastIndexPosition) {
    containerEl.scrollTo(0, newScrollTop);
    let nextIdx = index;
    let nextRect;
    do {
      nextIdx += 1;
      nextRect = getItemRect(indexPositions[nextIdx]);
    } while (nextRect.top < itemTop && nextIdx < lastIndexPosition);
    return nextIdx;
  }
};
const pageUp = async (containerEl, itemEl, indexPositions, index) => {
  const { top: itemTop } = itemEl.getBoundingClientRect();
  const { scrollTop, clientHeight } = containerEl;
  const newScrollTop = Math.max(scrollTop - clientHeight, 0);
  if (newScrollTop !== scrollTop && index > 0) {
    containerEl.scrollTo(0, newScrollTop);
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        let nextIdx = index;
        let nextRect;
        do {
          nextIdx -= 1;
          nextRect = getItemRect(indexPositions[nextIdx]);
        } while (nextRect.top > itemTop && nextIdx > 0);
        resolve(nextIdx);
      });
    });
  }
};
const isLeaf = (item) => !item.header && !item.childNodes;
const isFocusable = (item) => isLeaf(item) || item.expanded !== void 0;
const useKeyboardNavigation = ({
  containerRef,
  defaultHighlightedIndex = -1,
  disableHighlightOnFocus,
  highlightedIndex: highlightedIndexProp,
  indexPositions,
  onHighlight,
  onKeyboardNavigation,
  restoreLastFocus,
  selected
}) => {
  const lastFocus = useRef(-1);
  const [, forceRender] = useState({});
  const [highlightedIndex, setHighlightedIdx, isControlledHighlighting] = useControlled({
    controlled: highlightedIndexProp,
    default: defaultHighlightedIndex,
    name: "UseKeyboardNavigation"
  });
  const setHighlightedIndex = useCallback(
    (idx, fromKeyboard = false) => {
      onHighlight == null ? void 0 : onHighlight(idx);
      setHighlightedIdx(idx);
      if (fromKeyboard) {
        lastFocus.current = idx;
      }
    },
    [onHighlight, setHighlightedIdx]
  );
  const nextPageItemIdx = useCallback(
    async (e, index) => {
      const { id } = indexPositions[index];
      let result;
      if (id) {
        const itemEl = document.getElementById(id);
        const { current: containerEl } = containerRef;
        if (itemEl && containerEl) {
          result = e.key === PageDown ? pageDown(containerEl, itemEl, indexPositions, index) : await pageUp(containerEl, itemEl, indexPositions, index);
        }
      }
      return result != null ? result : index;
    },
    [containerRef, indexPositions]
  );
  const nextFocusableItemIdx = useCallback(
    (key = ArrowDown, idx = key === ArrowDown ? -1 : indexPositions.length) => {
      if (indexPositions.length === 0) {
        return -1;
      } else {
        const indexOfSelectedItem = getIndexOfSelectedItem(
          indexPositions,
          selected
        );
        const startIdx = getStartIdx(
          key,
          idx,
          indexOfSelectedItem,
          indexPositions.length
        );
        let nextIdx = nextItemIdx(indexPositions.length, key, startIdx);
        if (nextIdx === 0 && key === ArrowUp && !isFocusable(indexPositions[0])) {
          return idx;
        }
        while (((key === ArrowDown || key === Home) && nextIdx < indexPositions.length || (key === ArrowUp || key === End) && nextIdx > 0) && !isFocusable(indexPositions[nextIdx])) {
          nextIdx = nextItemIdx(indexPositions.length, key, nextIdx);
        }
        return nextIdx;
      }
    },
    [indexPositions, selected]
  );
  const keyboardNavigation = useRef(false);
  const ignoreFocus = useRef(false);
  const setIgnoreFocus = (value) => ignoreFocus.current = value;
  const handleFocus = useCallback(
    (e) => {
      if (ignoreFocus.current) {
        ignoreFocus.current = false;
      } else {
        keyboardNavigation.current = true;
        if (indexPositions.length === 0) {
          setHighlightedIndex(LIST_FOCUS_VISIBLE);
        } else if (highlightedIndex !== -1) {
          forceRender({});
        } else if (restoreLastFocus) {
          if (lastFocus.current !== -1) {
            setHighlightedIndex(lastFocus.current);
          } else {
            const selectedItemIdx = getIndexOfSelectedItem(
              indexPositions,
              selected
            );
            if (selectedItemIdx !== -1) {
              setHighlightedIndex(selectedItemIdx);
            } else {
              setHighlightedIndex(0);
            }
          }
        } else if (hasSelection(selected)) {
          const selectedItemIdx = getIndexOfSelectedItem(
            indexPositions,
            selected
          );
          setHighlightedIndex(selectedItemIdx);
        } else if (disableHighlightOnFocus !== true) {
          setHighlightedIndex(nextFocusableItemIdx());
        }
      }
    },
    [
      disableHighlightOnFocus,
      highlightedIndex,
      indexPositions,
      nextFocusableItemIdx,
      restoreLastFocus,
      selected,
      setHighlightedIndex
    ]
  );
  const navigateChildItems = useCallback(
    async (e) => {
      const nextIdx = e.key === PageDown || e.key === PageUp ? await nextPageItemIdx(e, highlightedIndex) : nextFocusableItemIdx(e.key, highlightedIndex);
      if (nextIdx !== highlightedIndex) {
        setHighlightedIndex(nextIdx, true);
      }
      onKeyboardNavigation == null ? void 0 : onKeyboardNavigation(e, nextIdx);
    },
    [
      highlightedIndex,
      nextFocusableItemIdx,
      nextPageItemIdx,
      onKeyboardNavigation,
      setHighlightedIndex
    ]
  );
  const handleKeyDown = useCallback(
    (e) => {
      if (indexPositions.length > 0 && isNavigationKey(e)) {
        e.preventDefault();
        e.stopPropagation();
        keyboardNavigation.current = true;
        void navigateChildItems(e);
      } else if (isCharacterKey(e)) {
        keyboardNavigation.current = true;
      }
    },
    [indexPositions, navigateChildItems]
  );
  const listProps = useMemo(() => {
    return {
      onBlur: (e) => {
        const sourceTarget = e.target.closest(".saltList");
        const destTarget = e.relatedTarget;
        if (sourceTarget && !(sourceTarget == null ? void 0 : sourceTarget.contains(destTarget))) {
          keyboardNavigation.current = false;
          setHighlightedIdx(-1);
          if (!restoreLastFocus) {
            lastFocus.current = -1;
          }
        }
      },
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      onMouseDownCapture: () => {
        keyboardNavigation.current = false;
        setIgnoreFocus(true);
      },
      onMouseMove: () => {
        if (keyboardNavigation.current) {
          keyboardNavigation.current = false;
        }
      },
      onMouseLeave: () => {
        keyboardNavigation.current = false;
        setIgnoreFocus(false);
        setHighlightedIndex(-1);
      }
    };
  }, [
    handleFocus,
    handleKeyDown,
    restoreLastFocus,
    setHighlightedIdx,
    setHighlightedIndex
  ]);
  return {
    focusVisible: keyboardNavigation.current ? highlightedIndex : -1,
    controlledHighlighting: isControlledHighlighting,
    highlightedIndex,
    setHighlightedIndex,
    keyboardNavigation,
    listProps,
    setIgnoreFocus
  };
};

export { LIST_FOCUS_VISIBLE, useKeyboardNavigation };
//# sourceMappingURL=useKeyboardNavigation.js.map
