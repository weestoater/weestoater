import { isValidElement, Children } from 'react';
import { ListItemGroup } from '../../list/ListItemGroup.js';
import { ListItemHeader } from '../../list/ListItemHeader.js';
import { itemToString } from '../itemToString.js';

const sourceItemHasProp = (item, propertyName) => {
  return item !== null && Object.prototype.hasOwnProperty.call(item, propertyName);
};
const isHeader = (item) => sourceItemHasProp(item, "header");
const isGroupNode = (item) => sourceItemHasProp(item, "childNodes");
const childItemHasProp = (item, propertyName) => {
  return item && Object.prototype.hasOwnProperty.call(item.props, propertyName);
};
const isDisabled = (item) => {
  if (isValidElement(item)) {
    if (childItemHasProp(item, "disabled")) {
      return item.props.disabled === true;
    }
  } else if (sourceItemHasProp(item, "disabled")) {
    return item.disabled === true;
  }
  return false;
};
const isFocusable = (item) => {
  if (isValidElement(item)) {
    if (childItemHasProp(item, "focusable")) {
      return item.props.focusable;
    }
  }
  return true;
};
const countChildItems = (item, items, idx) => {
  if (item.childNodes) {
    return item.childNodes.length;
  } else if (item.header) {
    let i = idx + 1;
    let count = 0;
    while (i < items.length && !items[i].header) {
      count++;
      i++;
    }
    return count;
  } else {
    return 0;
  }
};
const getChildLabel = (element) => {
  if (typeof element.props.children === "string") {
    return element.props.children;
  } else if (element.props.title) {
    return element.props.title;
  } else if (element.props.label) {
    return element.props.label;
  }
};
const childIsHeader = (child) => child.type === ListItemHeader || childItemHasProp(child, "data-header");
const childIsGroup = (child) => child.type === ListItemGroup || childItemHasProp(child, "data-group");
const childIsSelectable = (child) => {
  if (childItemHasProp(child, "selectable")) {
    return child.props.selectable === true;
  } else {
    return !childIsGroup(child) && !childIsHeader(child);
  }
};
const getChildNodes = (element) => {
  if (childIsGroup(element)) {
    const {
      props: { children }
    } = element;
    if (typeof children !== "string") {
      return childItems(children);
    }
  }
};
const mapReactElementChildren = (children, fn) => {
  const childElements = [];
  Children.forEach(children, (child) => {
    if (isValidElement(child)) {
      childElements.push(fn(child));
    }
  });
  return childElements;
};
const sourceItems = (source, options) => {
  if (Array.isArray(source)) {
    if (source.length === 0 && (options == null ? void 0 : options.noChildrenLabel)) {
      return [
        {
          label: options.noChildrenLabel,
          value: null
        }
      ];
    } else {
      return source.map(
        (item, index) => {
          var _a, _b;
          return {
            childNodes: sourceItems(
              item.childNodes,
              options
            ),
            description: item.description,
            expanded: item.expanded,
            value: item,
            label: (_b = (_a = options == null ? void 0 : options.itemToString) == null ? void 0 : _a.call(options, item)) != null ? _b : itemToString(item)
          };
        }
      );
    }
  } else if (source) {
    throw Error("list-child-items expects source to be an array");
  }
};
const childItems = (children) => {
  if (children) {
    return mapReactElementChildren(children, (child) => {
      const {
        "data-id": dataId,
        disabled,
        id = dataId,
        "data-expanded": dataExpanded,
        expanded = dataExpanded
      } = child.props;
      return {
        childNodes: getChildNodes(child),
        disabled,
        expanded,
        header: childIsHeader(child),
        id,
        label: getChildLabel(child),
        selectable: childIsSelectable(child),
        value: child
      };
    });
  }
};
const PathSeparators = /* @__PURE__ */ new Set(["/", "-", "."]);
const isPathSeparator = (char) => PathSeparators.has(char);
const isParentPath = (parentPath, childPath) => childPath.startsWith(parentPath) && isPathSeparator(childPath[parentPath.length]);
const PATH_SEPARATORS = /* @__PURE__ */ new Set([".", "/"]);
function isDescendantOf(basePath, targetPath) {
  if (!targetPath.startsWith(basePath)) {
    return false;
  } else {
    return PATH_SEPARATORS.has(targetPath.charAt(basePath.length));
  }
}
function replaceCollectionItem(nodes, id, props) {
  let childNodes;
  const newNodes = nodes.map((node) => {
    if (node.id === id) {
      return {
        ...node,
        ...props
      };
    } else if (isDescendantOf(node.id, id) && node.childNodes) {
      childNodes = replaceCollectionItem(node.childNodes, id, props);
      return {
        ...node,
        childNodes
      };
    } else {
      return node;
    }
  });
  return newNodes;
}

export { childIsGroup, childItems, countChildItems, getChildLabel, getChildNodes, isDisabled, isFocusable, isGroupNode, isHeader, isParentPath, replaceCollectionItem, sourceItemHasProp, sourceItems };
//# sourceMappingURL=collection-item-utils.js.map
