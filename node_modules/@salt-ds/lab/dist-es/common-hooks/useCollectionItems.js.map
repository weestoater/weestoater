{"version":3,"file":"useCollectionItems.js","sources":["../src/common-hooks/useCollectionItems.ts"],"sourcesContent":["import { useCallback, useMemo, useRef, useState, isValidElement } from \"react\";\nimport {\n  CollectionItem,\n  CollectionIndexer,\n  CollectionHookProps,\n  CollectionHookResult,\n} from \"./collectionTypes\";\nimport {\n  isHeader,\n  isGroupNode,\n  childItems,\n  countChildItems,\n  FilterPredicate,\n  getDefaultFilter,\n  getDefaultFilterRegex,\n  isDisabled,\n  isFocusable,\n  isParentPath,\n  replaceCollectionItem,\n  sourceItems,\n} from \"./utils\";\nimport { itemToString as defaultItemToString } from \"./itemToString\";\n\nimport { SelectionStrategy, SingleSelectionStrategy } from \"./selectionTypes\";\nimport { useCollection } from \"./collectionProvider\";\n\nconst defaultCollectionOptions = {};\n\nexport const useCollectionItems = <Item>({\n  children,\n  id: idRoot,\n  label = \"\",\n  options = defaultCollectionOptions,\n  // revealSelected = false,\n  source,\n}: CollectionHookProps<Item>): CollectionHookResult<Item> => {\n  const { getItemId } = options;\n\n  const [, forceUpdate] = useState<unknown>(null);\n  const inheritedCollectionHook = useCollection<Item>();\n  const dataRef = useRef<CollectionItem<Item>[]>([]);\n  const flattenedDataRef = useRef<CollectionItem<Item>[]>([]);\n  const EMPTY_COLLECTION: CollectionItem<Item>[] = useMemo(() => [], []);\n  const filterPattern = useRef<string>(options.filterPattern ?? \"\");\n\n  // destructure individual option values so we can safely reference them in dependency arrays\n  const {\n    getFilterRegex = getDefaultFilterRegex,\n    noChildrenLabel,\n    itemToString = defaultItemToString,\n  } = options;\n\n  const isExpanded = useCallback(\n    (path: string) => {\n      // We can't do this here because itemToId won't work until we complete this phase\n      // if (Array.isArray(revealSelected)) {\n      //   const selectedIds = revealSelected.map(itemToId);\n      //   return selectedIds.some((id) => isParentPath(path, id));\n      // }\n      return options.defaultExpanded || false;\n    },\n    [options.defaultExpanded]\n  );\n\n  const addMetadataToItems = useCallback(\n    <Item>(\n      items: CollectionItem<Item>[],\n      indexer: CollectionIndexer,\n      level = 1,\n      path = \"\",\n      results: CollectionItem<Item>[] = [],\n      flattenedCollection: CollectionItem<Item>[] = [],\n      flattenedSource: (Item | null)[] = []\n    ): [CollectionItem<Item>[], (Item | null)[], CollectionItem<Item>[]] => {\n      items.forEach((item, i, all) => {\n        const isCollapsibleHeader = item.header && options.collapsibleHeaders;\n        const isNonCollapsibleGroupNode =\n          item.childNodes && options.collapsibleHeaders === false;\n        const isLeaf = !item.childNodes || item.childNodes.length === 0;\n        const nonCollapsible =\n          isNonCollapsibleGroupNode || (isLeaf && !isCollapsibleHeader);\n        const childPath = path ? `${path}.${i}` : `item-${i}`;\n        // getItemId is backward compatible with earlier List implementation.\n        // It is not appropriate for a nested source structure, where index\n        // will not always be an absolute offset.\n        const id =\n          item.id ?? (getItemId ? getItemId(i) : `${idRoot}-${childPath}`);\n\n        const expanded = nonCollapsible\n          ? undefined\n          : item.expanded ?? isExpanded(id);\n        //TODO dev time check - if id is provided by user, make sure\n        // hierarchical pattern is consistent\n        const normalisedItem: CollectionItem<Item> = {\n          ...item,\n          childNodes: undefined,\n          count:\n            !isNonCollapsibleGroupNode && expanded === undefined\n              ? 0\n              : countChildItems(item, all, i),\n          description: item.description,\n          disabled: isDisabled(item.value),\n          focusable: isFocusable(item.value) ? undefined : false,\n          id,\n          index: indexer.value,\n          expanded,\n          level,\n        };\n        results.push(normalisedItem);\n        flattenedCollection.push(normalisedItem);\n        flattenedSource.push(items[i].value);\n\n        indexer.value += 1;\n\n        // if ((isNonCollapsibleGroupNode || expanded !== undefined) && !isCollapsibleHeader) {\n        if (item.childNodes) {\n          const [children] = addMetadataToItems<Item>(\n            item.childNodes,\n            indexer,\n            level + 1,\n            childPath,\n            [],\n            flattenedCollection,\n            flattenedSource\n          );\n          normalisedItem.childNodes = children;\n        }\n      });\n      return [results, flattenedSource, flattenedCollection];\n    },\n    [options.collapsibleHeaders, getItemId, idRoot, isExpanded]\n  );\n\n  const getFilter = useCallback(() => {\n    if (filterPattern.current) {\n      return getDefaultFilter(filterPattern.current, getFilterRegex);\n    } else {\n      return null;\n    }\n  }, [getFilterRegex]);\n\n  const collectVisibleItems = useCallback(\n    (\n      items: CollectionItem<Item>[],\n      filter: null | FilterPredicate = getFilter(),\n      results: CollectionItem<Item>[] = [],\n      idx: { value: number } = { value: 0 }\n    ): CollectionItem<Item>[] => {\n      let skipToNextHeader = false;\n      for (const item of items) {\n        if (!(skipToNextHeader && !isHeader(item))) {\n          if (\n            item.value !== null &&\n            (filter === null || filter(itemToString(item.value)))\n          ) {\n            results[idx.value] = item;\n            idx.value += 1;\n          }\n          skipToNextHeader = false;\n          if (isHeader(item) && item.expanded === false) {\n            skipToNextHeader = true;\n          } else if (isGroupNode(item)) {\n            if (item.expanded !== false && item.childNodes) {\n              collectVisibleItems(item.childNodes, filter, results, idx);\n            }\n          }\n        }\n      }\n      return results;\n    },\n    [getFilter, itemToString]\n  );\n\n  // Stage 1 - convert source or children to CollectionItems.\n  const partialCollectionItems = useMemo(() => {\n    return inheritedCollectionHook\n      ? EMPTY_COLLECTION\n      : sourceItems<Item>(source, { itemToString, noChildrenLabel }) ||\n          childItems(children) ||\n          [];\n  }, [\n    inheritedCollectionHook,\n    EMPTY_COLLECTION,\n    source,\n    itemToString,\n    noChildrenLabel,\n    children,\n  ]);\n\n  // Stage 2 - extend the collectionItems with additional metadata\n  const [collectionItems, flattenedSource, flattenedCollection] = useMemo(\n    () =>\n      inheritedCollectionHook\n        ? [EMPTY_COLLECTION, EMPTY_COLLECTION, EMPTY_COLLECTION]\n        : //@ts-ignore\n          addMetadataToItems<Item>(partialCollectionItems, { value: 0 }),\n    [\n      EMPTY_COLLECTION,\n      addMetadataToItems,\n      inheritedCollectionHook,\n      partialCollectionItems,\n    ]\n  );\n  flattenedDataRef.current = flattenedCollection;\n\n  // Stage 3 prepare the list of visible items, this is what will be rendered\n  useMemo(\n    () =>\n      inheritedCollectionHook\n        ? EMPTY_COLLECTION\n        : (dataRef.current = collectVisibleItems(collectionItems)),\n    [\n      EMPTY_COLLECTION,\n      collectVisibleItems,\n      collectionItems,\n      inheritedCollectionHook,\n    ]\n  );\n\n  const collectionItemsRef = useRef(collectionItems);\n\n  const setFilterPattern = useCallback(\n    (pattern = \"\") => {\n      if (typeof pattern === \"string\") {\n        filterPattern.current = pattern;\n        dataRef.current = collectVisibleItems(collectionItems);\n        forceUpdate({});\n      }\n    },\n    [collectionItems, collectVisibleItems]\n  );\n\n  const itemById = useCallback(\n    (\n      id: string,\n      target: CollectionItem<Item>[] = collectionItems\n    ): Item | never => {\n      const sourceWithId = target.find(\n        (i) => i.id === id || (i?.childNodes?.length && isParentPath(i.id, id))\n      );\n      if (sourceWithId?.id === id) {\n        //TODO do we need the flattered source at all ?\n        return flattenedSource?.[sourceWithId.index!] as Item;\n      } else if (sourceWithId) {\n        return itemById(id, sourceWithId.childNodes);\n      }\n      throw Error(`useCollectionData itemById, id ${id} not found `);\n    },\n    [flattenedSource, collectionItems]\n  );\n\n  const toCollectionItem = useCallback(\n    (item: Item): CollectionItem<Item> | never => {\n      // TODO what about Tree structures, we need to search flattened source\n      const collectionItem = flattenedDataRef.current.find((i) =>\n        // const collectionItem = collectionItemsRef.current.find((i) =>\n        //@ts-ignore\n        isValidElement(i.value) ? i.label === item : i.value === item\n      );\n      if (collectionItem) {\n        return collectionItem;\n      }\n      throw Error(`useCollectionData toCollectionItem, item not found `);\n    },\n    []\n  );\n\n  // TODO types need more work, these are correct but we\n  // don't really want references to Selection in here\n  const itemToCollectionItem = useCallback(\n    <\n      Selection extends SelectionStrategy,\n      U extends Item | Item[] | null | undefined\n    >(\n      sel: U\n    ): Selection extends SingleSelectionStrategy\n      ? CollectionItem<Item> | null\n      : CollectionItem<Item>[] => {\n      type returnType = Selection extends SingleSelectionStrategy\n        ? CollectionItem<Item> | null\n        : CollectionItem<Item>[];\n\n      if (sel === null) {\n        return null as returnType;\n      } else if (Array.isArray(sel)) {\n        const result: CollectionItem<Item>[] = [];\n        for (const item of sel) {\n          const collectionItem = toCollectionItem(item);\n          result.push(collectionItem);\n        }\n        return result as returnType;\n      } else if (sel !== undefined) {\n        return toCollectionItem(sel as Item) as returnType;\n      }\n\n      return undefined as unknown as returnType;\n    },\n    [toCollectionItem]\n  );\n\n  const stringToCollectionItem = useCallback(\n    <Selection extends SelectionStrategy>(\n      value: string | null | undefined\n    ): Selection extends SingleSelectionStrategy\n      ? CollectionItem<Item> | null\n      : CollectionItem<Item>[] => {\n      type returnType = Selection extends SingleSelectionStrategy\n        ? CollectionItem<Item> | null\n        : CollectionItem<Item>[];\n\n      const toCollectionItem = (\n        item: string\n      ): undefined | CollectionItem<Item> | never => {\n        // TODO what about Tree structures, we need to search flattened source\n        const collectionItem = flattenedDataRef.current.find((i) =>\n          // const collectionItem = collectionItemsRef.current.find((i) =>\n          //@ts-ignore\n          isValidElement(i.value)\n            ? i.label === item\n            : i.value !== null && itemToString(i.value) === item\n        );\n        if (collectionItem) {\n          return collectionItem;\n        }\n      };\n\n      if (value === null) {\n        return null as returnType;\n      } else if (Array.isArray(value)) {\n        const result: CollectionItem<Item>[] = [];\n        for (const item of value) {\n          const collectionItem = toCollectionItem(item);\n          if (collectionItem) {\n            result.push(collectionItem);\n          }\n        }\n        return result as returnType;\n      } else if (value !== undefined) {\n        return toCollectionItem(value) as returnType;\n      }\n\n      return undefined as unknown as returnType;\n    },\n    [itemToString]\n  );\n\n  const itemToId = useCallback((item: Item): string => {\n    for (const collectionItem of collectionItemsRef.current) {\n      if (item === collectionItem.value) {\n        return collectionItem.id;\n      }\n    }\n    throw Error(\"useCollectionData itemToId, item not found\");\n  }, []);\n\n  const collapseGroupItem = useCallback(\n    (item: CollectionItem<Item>) => {\n      collectionItemsRef.current = replaceCollectionItem(\n        collectionItemsRef.current,\n        item.id,\n        {\n          expanded: false,\n        }\n      );\n      dataRef.current = collectVisibleItems(collectionItemsRef.current);\n      forceUpdate({});\n    },\n    [collectVisibleItems]\n  );\n\n  const expandGroupItem = useCallback(\n    (item: CollectionItem<Item>) => {\n      collectionItemsRef.current = replaceCollectionItem<Item>(\n        collectionItemsRef.current,\n        item.id,\n        {\n          expanded: true,\n        }\n      );\n      dataRef.current = collectVisibleItems(collectionItemsRef.current);\n      forceUpdate({});\n    },\n    [collectVisibleItems]\n  );\n\n  return (\n    inheritedCollectionHook || {\n      collapseGroupItem,\n      data: dataRef.current,\n      expandGroupItem, // why not toggle, or just rely on setdata ?\n      setFilterPattern,\n      itemById,\n      itemToId,\n      toCollectionItem,\n      itemToCollectionItem,\n      stringToCollectionItem,\n    }\n  );\n};\n"],"names":["itemToString","defaultItemToString","flattenedCollection","flattenedSource","_a","children","toCollectionItem"],"mappings":"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"}