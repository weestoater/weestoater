import { useControlled } from '@salt-ds/core';
import { useRef, useCallback } from 'react';

const GROUP_SELECTION_NONE = "none";
const defaultSelectionKeys = ["Enter", " "];
const isSelectable = (item) => item && item.disabled !== true && item.selectable !== false;
const byItemIndex = (i1, i2) => {
  var _a, _b;
  return ((_a = i1.index) != null ? _a : 0) - ((_b = i2.index) != null ? _b : 0);
};
const useSelection = ({
  defaultSelected,
  disableSelection = false,
  highlightedIdx,
  indexPositions,
  label = "",
  onSelect,
  onSelectionChange,
  selected: selectedProp,
  selectionStrategy,
  selectionKeys = defaultSelectionKeys,
  tabToSelect
}) => {
  const isDeselectable = selectionStrategy === "deselectable";
  const isMultipleSelect = selectionStrategy === "multiple";
  const isExtendedSelect = selectionStrategy === "extended";
  const lastActive = useRef(-1);
  const isSelectionEvent = useCallback(
    (evt) => selectionKeys.includes(evt.key),
    [selectionKeys]
  );
  const emptyValue = useCallback(() => {
    return isMultipleSelect || isExtendedSelect ? [] : null;
  }, [isMultipleSelect, isExtendedSelect]);
  const [selected, setSelected] = useControlled({
    controlled: selectedProp,
    default: defaultSelected != null ? defaultSelected : emptyValue(),
    name: "UseSelection",
    state: "selected"
  });
  const isItemSelected = useCallback(
    (item) => {
      return Array.isArray(selected) ? selected.includes(item) : selected === item;
    },
    [selected]
  );
  const selectDefault = useCallback((item) => item, []);
  const selectDeselectable = useCallback(
    (item) => isItemSelected(item) ? null : item,
    [isItemSelected]
  );
  const selectMultiple = useCallback(
    (item) => {
      const nextItems = isItemSelected(item) ? selected.filter((i) => i !== item) : selected.concat(item);
      nextItems.sort(byItemIndex);
      return nextItems;
    },
    [isItemSelected, selected]
  );
  const selectRange = useCallback(
    (idx, preserveExistingSelection) => {
      const currentSelection = preserveExistingSelection ? selected : [];
      const [lastSelectedItem] = selected.slice(-1);
      const lastSelectedItemIndex = lastSelectedItem ? indexPositions.indexOf(lastSelectedItem) : 0;
      const startRegion = Math.min(idx, lastSelectedItemIndex);
      const endRegion = Math.max(idx, lastSelectedItemIndex);
      const rangeSelection = indexPositions.slice(startRegion, endRegion + 1);
      const nextItems = [.../* @__PURE__ */ new Set([...currentSelection, ...rangeSelection])];
      nextItems.sort(byItemIndex);
      return nextItems;
    },
    [indexPositions, selected]
  );
  const selectItemAtIndex = useCallback(
    (evt, idx, item, rangeSelect, preserveExistingSelection) => {
      let newSelected;
      if (isMultipleSelect) {
        newSelected = selectMultiple(item);
      } else if (isExtendedSelect) {
        if (preserveExistingSelection && !rangeSelect) {
          newSelected = selectMultiple(item);
        } else if (rangeSelect) {
          newSelected = selectRange(
            idx,
            preserveExistingSelection
          );
        } else {
          newSelected = [item];
        }
      } else if (isDeselectable) {
        newSelected = selectDeselectable(item);
      } else {
        newSelected = selectDefault(item);
      }
      if (newSelected !== selected) {
        setSelected(newSelected);
      }
      onSelect == null ? void 0 : onSelect(evt, item);
      if (newSelected !== selected) {
        if (onSelectionChange) {
          onSelectionChange(evt, newSelected);
        }
      }
    },
    [
      isMultipleSelect,
      isExtendedSelect,
      isDeselectable,
      selected,
      onSelect,
      selectMultiple,
      selectRange,
      selectDeselectable,
      selectDefault,
      setSelected,
      onSelectionChange
    ]
  );
  const handleKeyDown = useCallback(
    (evt) => {
      const item = indexPositions[highlightedIdx];
      if (isSelectable(item)) {
        if (isSelectionEvent(evt) || tabToSelect && evt.key === "Tab") {
          if (evt.key !== "Tab") {
            evt.preventDefault();
          }
          selectItemAtIndex(
            evt,
            highlightedIdx,
            item,
            false,
            evt.ctrlKey || evt.metaKey
          );
          if (isExtendedSelect) {
            lastActive.current = highlightedIdx;
          }
        }
      }
    },
    [
      indexPositions,
      highlightedIdx,
      isSelectionEvent,
      tabToSelect,
      selectItemAtIndex,
      isExtendedSelect
    ]
  );
  const handleKeyboardNavigation = useCallback(
    (evt, currentIndex) => {
      if (isExtendedSelect && evt.shiftKey) {
        const item = indexPositions[currentIndex];
        if (isSelectable(item)) {
          selectItemAtIndex(evt, currentIndex, item, true);
        }
      }
    },
    [isExtendedSelect, indexPositions, selectItemAtIndex]
  );
  const handleClick = useCallback(
    (evt) => {
      const item = indexPositions[highlightedIdx];
      if (!disableSelection && isSelectable(item)) {
        evt.preventDefault();
        evt.stopPropagation();
        selectItemAtIndex(
          evt,
          highlightedIdx,
          item,
          evt.shiftKey,
          evt.ctrlKey || evt.metaKey
        );
        if (isExtendedSelect) {
          lastActive.current = highlightedIdx;
        }
      }
    },
    [
      disableSelection,
      isExtendedSelect,
      highlightedIdx,
      indexPositions,
      selectItemAtIndex
    ]
  );
  const listHandlers = {
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    onKeyboardNavigation: handleKeyboardNavigation
  };
  return {
    listHandlers,
    selected,
    setSelected
  };
};

export { GROUP_SELECTION_NONE, useSelection };
//# sourceMappingURL=useSelection.js.map
