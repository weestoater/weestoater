{"version":3,"file":"useOverflowLayout.js","sources":["../src/responsive/useOverflowLayout.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from \"react\";\nimport {\n  ElementRef,\n  ManagedListRef,\n  OverflowItem,\n  OverflowLayoutHookProps,\n} from \"./overflowTypes\";\n\nimport { getIsOverflowed, measureContainerOverflow } from \"./overflowUtils\";\nimport { useDynamicCollapse } from \"./useDynamicCollapse\";\nimport { useInstantCollapse } from \"./useInstantCollapse\";\nimport { useOverflow } from \"./useOverflow\";\nimport { useReclaimSpace } from \"./useReclaimSpace\";\nimport { ResizeHandler, useResizeObserver } from \"../responsive\";\n\nconst MONITORED_DIMENSIONS: { [key: string]: string[] } = {\n  horizontal: [\"width\", \"scrollHeight\"],\n  vertical: [\"height\", \"scrollWidth\"],\n  none: [],\n};\n\ntype overflowUpdate = (item1: OverflowItem, item2: OverflowItem) => void;\n\n// we need id, just to be able to assign id to overflowIndicator in useOverflow\nexport const useOverflowLayout = ({\n  collectionHook,\n  id,\n  orientation,\n  label = \"Toolbar\",\n  disableOverflow = false,\n}: OverflowLayoutHookProps): [ElementRef, overflowUpdate] => {\n  const overflowContainerRef: ElementRef = useRef(null);\n  const overflowItemsRef: ManagedListRef = useRef([]);\n  const measurement = useRef({ innerContainerSize: 0, rootContainerDepth: 0 });\n  const { innerContainerSize } = measurement.current;\n\n  const { dispatch, version: collectionVersion } = collectionHook;\n  overflowItemsRef.current = collectionHook.data;\n\n  const {\n    onResize: onOverflowResize,\n    resetMeasurements: resetOverflowMeasurements,\n  } = useOverflow({\n    collectionHook,\n    id,\n    label,\n    overflowItemsRef,\n    orientation,\n    overflowContainerRef,\n  });\n\n  const hasOverflowedItems = getIsOverflowed(collectionHook.data);\n  // const hasOverflowedItems = getIsOverflowed(managedItems);\n\n  const {\n    onResize: onDynamicResize,\n    resetMeasurements: resetDynamicMeasurements,\n  } = useDynamicCollapse({\n    collectionHook,\n    innerContainerSize,\n    label,\n    overflowItemsRef,\n    orientation,\n    overflowContainerRef,\n  });\n\n  const {\n    onResize: onInstantResize,\n    resetMeasurements: resetInstantMeasurements,\n  } = useInstantCollapse({\n    collectionHook,\n    hasOverflowedItems,\n    innerContainerSize,\n    label,\n    overflowItemsRef,\n    orientation,\n    overflowContainerRef,\n  });\n\n  const { onResize: onReclaimResize } = useReclaimSpace({\n    collectionHook,\n    label,\n    overflowItemsRef,\n    orientation,\n    overflowContainerRef,\n  });\n\n  const resizeHandler: ResizeHandler = useCallback(\n    ({\n      scrollHeight,\n      height = scrollHeight,\n      scrollWidth,\n      width = scrollWidth,\n    }) => {\n      const size = orientation === \"horizontal\" ? width : height;\n      if (typeof size === \"number\") {\n        const { innerContainerSize } = measurement.current;\n        const sizeDiff = size - innerContainerSize;\n        // Tiny size diffs seem to be down to the relative sub-pixel innaccuracy of\n        // ResizeObserver vs getBoundingClientRect\n        if (Math.abs(sizeDiff) > 0.5) {\n          measurement.current.innerContainerSize = size;\n          const containerHasGrown = size > innerContainerSize;\n          // Note: any one of these hooks may trigger a render which\n          // may affect the overflow state that the next hook sees.\n          // Hence, they all test for overflow internally and independently.\n          onDynamicResize(size, containerHasGrown);\n          onInstantResize(size, containerHasGrown);\n          onOverflowResize(size, containerHasGrown);\n          onReclaimResize(size, containerHasGrown);\n        }\n      }\n    },\n    [\n      onDynamicResize,\n      onInstantResize,\n      onOverflowResize,\n      onReclaimResize,\n      orientation,\n    ]\n  );\n\n  const measureAndInitialize = useCallback(() => {\n    const { isOverflowing, ...contentWidthAndDepth } = measureContainerOverflow(\n      overflowContainerRef,\n      orientation\n    );\n\n    measurement.current = contentWidthAndDepth;\n    const { innerContainerSize } = contentWidthAndDepth;\n    // TODO check this with complex combinations\n    let handled = resetInstantMeasurements(isOverflowing);\n    if (!handled) {\n      handled = resetDynamicMeasurements();\n      if (!handled) {\n        resetOverflowMeasurements?.(isOverflowing, innerContainerSize);\n      }\n    }\n  }, [\n    orientation,\n    resetInstantMeasurements,\n    resetDynamicMeasurements,\n    resetOverflowMeasurements,\n  ]);\n\n  const switchPriorities = useCallback(\n    (item1: OverflowItem, item2: OverflowItem) => {\n      const { priority: priority1 } = item1;\n      const { priority: priority2 } = item2;\n      if (priority1 !== priority2) {\n        dispatch({\n          type: \"update-items\",\n          overflowItems: [\n            { id: item1.id, priority: priority2 },\n            { id: item2.id, priority: priority1 },\n          ],\n        });\n        // Why do we need a timeout here when we don't inside resizeHandler ?\n        setTimeout(measureAndInitialize, 0);\n      }\n    },\n    [dispatch, measureAndInitialize]\n  );\n\n  // Important that we register our resize handler before we measure and\n  // initialize. The initialization may trigger changes which we want the\n  // resize observer to detect (when we have nested overflowables).\n  useResizeObserver(\n    overflowContainerRef,\n    MONITORED_DIMENSIONS[disableOverflow ? \"none\" : orientation],\n    resizeHandler\n  );\n\n  // This hook runs after a measurememnt cycle, not after every single change to\n  // collection data. The version attribute has been introduced specifically for this.\n  useEffect(() => {\n    if (!disableOverflow) {\n      measureAndInitialize();\n    }\n  }, [collectionVersion, disableOverflow, measureAndInitialize]);\n\n  return [overflowContainerRef, switchPriorities];\n};\n"],"names":["innerContainerSize"],"mappings":"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"}