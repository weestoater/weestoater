import { useIsomorphicLayoutEffect } from '@salt-ds/core';
import { useRef, useCallback } from 'react';

const WidthHeight = ["height", "width"];
const HeightOnly = ["height"];
const WidthOnly = ["width"];
const observedMap = /* @__PURE__ */ new WeakMap();
const getTargetSize = (element, contentRect, dimension) => {
  switch (dimension) {
    case "height":
      return contentRect.height;
    case "scrollHeight":
      return element.scrollHeight;
    case "scrollWidth":
      return element.scrollWidth;
    case "width":
      return contentRect.width;
    default:
      return 0;
  }
};
const resizeObserver = typeof ResizeObserver !== "undefined" ? new ResizeObserver((entries) => {
  for (const entry of entries) {
    const { target, contentRect } = entry;
    const observedTarget = observedMap.get(target);
    if (observedTarget) {
      const { onResize, measurements } = observedTarget;
      let sizeChanged = false;
      for (const [dimension, size] of Object.entries(measurements)) {
        const newSize = getTargetSize(
          target,
          contentRect,
          dimension
        );
        if (newSize !== size) {
          sizeChanged = true;
          measurements[dimension] = newSize;
        }
      }
      if (sizeChanged) {
        onResize && onResize(measurements);
      }
    }
  }
}) : null;
function useResizeObserver(ref, dimensions, onResize, reportInitialSize = false) {
  const dimensionsRef = useRef(dimensions);
  const measure = useCallback((target) => {
    const rect = target.getBoundingClientRect();
    return dimensionsRef.current.reduce(
      (map, dim) => {
        map[dim] = getTargetSize(target, rect, dim);
        return map;
      },
      {}
    );
  }, []);
  useIsomorphicLayoutEffect(() => {
    if (!resizeObserver) {
      return void 0;
    }
    const target = ref.current;
    let cleanedUp = false;
    async function registerObserver() {
      observedMap.set(target, { measurements: {} });
      cleanedUp = false;
      const { fonts } = document;
      if (fonts) {
        await fonts.ready;
      }
      if (!cleanedUp && resizeObserver) {
        const observedTarget = observedMap.get(target);
        if (observedTarget) {
          const measurements = measure(target);
          observedTarget.measurements = measurements;
          resizeObserver.observe(target);
          if (reportInitialSize) {
            onResize(measurements);
          }
        }
      }
    }
    if (target) {
      if (observedMap.has(target)) {
        throw Error(
          "useResizeObserver attemping to observe same element twice"
        );
      }
      void registerObserver();
    }
    return () => {
      if (target && observedMap.has(target)) {
        resizeObserver.unobserve(target);
        observedMap.delete(target);
        cleanedUp = true;
      }
    };
  }, [ref, measure]);
  useIsomorphicLayoutEffect(() => {
    const target = ref.current;
    const record = observedMap.get(target);
    if (record) {
      if (dimensionsRef.current !== dimensions) {
        dimensionsRef.current = dimensions;
        const measurements = measure(target);
        record.measurements = measurements;
      }
      record.onResize = onResize;
    }
  }, [dimensions, measure, ref, onResize]);
}

export { HeightOnly, WidthHeight, WidthOnly, useResizeObserver };
//# sourceMappingURL=useResizeObserver.js.map
