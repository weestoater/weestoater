import { useRef, Children, useReducer, useCallback, isValidElement } from 'react';
import { useIsomorphicLayoutEffect } from '@salt-ds/core';
import { measureOverflowItems } from './overflowUtils.js';
import { overflowReducer, reducerInitialiser } from './OverflowReducer.js';

const defaultOptions = {};
const defaultChildIdentity = (children) => {
  const childLabels = [];
  Children.forEach(children, (child) => {
    var _a;
    if (isValidElement(child)) {
      childLabels.push((_a = child.props.label) != null ? _a : "");
    }
  });
  return `${childLabels.length}:${childLabels.join(":")}`;
};
const defaultSourceIdentity = (source) => {
  const labels = source.map(({ label }) => label).join(":");
  return `${source.length}:${labels}`;
};
const getItemsIdentity = (defaultSource, source, children) => {
  let identity;
  if (Array.isArray(defaultSource)) {
    identity = defaultSourceIdentity(defaultSource);
  } else if (Array.isArray(source)) {
    identity = defaultSourceIdentity(source);
  } else {
    identity = defaultChildIdentity(children);
  }
  return identity;
};
const useOverflowCollectionItems = ({
  children,
  defaultSource,
  id: idRoot,
  injectedItems = [],
  options = defaultOptions,
  orientation,
  label = "",
  source
}) => {
  const dataRef = useRef([]);
  const versionRef = useRef(0);
  const measureTimeout = useRef(null);
  const previousIdentityRef = useRef("");
  const fontsLoaded = useRef(false);
  const identity = getItemsIdentity(defaultSource, source, children);
  const isControlled = Array.isArray(source) || Children.count(children) > 0;
  if (isControlled && defaultSource !== void 0) {
    throw Error(
      "useOverflowCollectionItems: defaultSource prop should not be used in combination with either source prop or children "
    );
  }
  const [data, dispatch] = useReducer(
    overflowReducer,
    {
      children,
      source: source || defaultSource,
      injectedItems,
      idRoot,
      options
    },
    reducerInitialiser
  );
  dataRef.current = data;
  const measureManagedItems = useCallback(
    (defer = false) => {
      if (measureTimeout.current) {
        window.clearTimeout(measureTimeout.current);
        measureTimeout.current = null;
      }
      if (defer) {
        measureTimeout.current = window.setTimeout(measureManagedItems, 30);
      } else {
        if (fontsLoaded.current) {
          const dimension = orientation === "horizontal" ? "width" : "height";
          const overflowItems = measureOverflowItems(
            dataRef.current,
            dimension
          );
          versionRef.current += 1;
          dispatch({
            type: "init",
            overflowItems
          });
        }
      }
    },
    [orientation]
  );
  useIsomorphicLayoutEffect(() => {
    async function measure() {
      const { fonts } = document;
      if (fonts) {
        await fonts.ready;
        fontsLoaded.current = true;
      } else {
        fontsLoaded.current = true;
      }
      measureManagedItems();
    }
    measure().catch((err) => {
      console.warn(`error occurred measuring Overflow Items`, err);
    });
  }, [measureManagedItems]);
  const dispatchOverflowAction = useCallback(
    (action) => {
      if (action.type === "reset") {
        measureManagedItems();
      } else {
        dispatch(action);
        if (action.type.endsWith("overflow-indicator")) {
          measureManagedItems(true);
        }
      }
    },
    [measureManagedItems]
  );
  useIsomorphicLayoutEffect(() => {
    if (previousIdentityRef.current !== "") {
      const overflowItems = reducerInitialiser({
        children,
        source: source || defaultSource,
        injectedItems,
        idRoot,
        options
      });
      dispatch({ type: "init", overflowItems });
      measureManagedItems(true);
    }
    previousIdentityRef.current = identity;
  }, [identity]);
  return {
    data,
    dispatch: dispatchOverflowAction,
    isControlled,
    version: versionRef.current
  };
};

export { useOverflowCollectionItems };
//# sourceMappingURL=useOverflowCollectionItems.js.map
