import { useIsomorphicLayoutEffect } from '@salt-ds/core';
import { useMemo, useCallback } from 'react';
import { measureContainerOverflow, addAll, getElementForItem, measureElementSize, allExceptOverflowIndicator } from './overflowUtils.js';

const newlyCollapsed = (overflowItems) => overflowItems.some(
  (item) => item.collapsible === "instant" && item.collapsed && item.fullSize === null
);
const findItemToCollapse = (items) => {
  for (let i = items.length - 1; i >= 0; i--) {
    const item = items[i];
    if (item.collapsible === "instant" && !item.collapsed) {
      return item;
    }
  }
};
const uncollapseItems = (items, containerSize) => {
  const visibleContentSize = items.reduce(allExceptOverflowIndicator, 0);
  let diff = containerSize - visibleContentSize;
  const collapsed = items.filter((item) => item.collapsible === "instant" && item.collapsed).sort((i1, i2) => i2.index - i1.index);
  const result = [];
  while (collapsed.length) {
    const item = collapsed.pop();
    const itemDiff = item.fullSize - item.size;
    if (diff >= itemDiff) {
      result.push({
        ...item,
        collapsed: false,
        size: item.fullSize,
        fullSize: null
      });
      diff = diff - itemDiff;
    } else {
      break;
    }
  }
  return result;
};
const useInstantCollapse = ({
  collectionHook,
  hasOverflowedItems,
  innerContainerSize = 0,
  label = "Toolbar",
  overflowContainerRef: ref,
  overflowItemsRef,
  orientation
}) => {
  const minMaxSizes = useMemo(() => /* @__PURE__ */ new Map(), []);
  const { dispatch } = collectionHook;
  const updateCollapse = useCallback(
    (containerSize, renderedSize) => {
      const { current: managedItems } = overflowItemsRef;
      if (renderedSize && containerSize < renderedSize) {
        const overflowItem = findItemToCollapse(managedItems);
        if (overflowItem) {
          dispatch({
            type: "collapse-instant-item",
            overflowItem
          });
        }
      } else {
        const uncollapsedItems = uncollapseItems(managedItems, containerSize);
        if (uncollapsedItems.length) {
          dispatch({
            type: "update-items",
            overflowItems: uncollapsedItems
          });
        }
      }
    },
    [dispatch, overflowItemsRef]
  );
  const handleResize = useCallback(
    (size, containerHasGrown) => {
      const { current: managedItems } = overflowItemsRef;
      const { isOverflowing: willOverflow } = measureContainerOverflow(
        ref,
        orientation
      );
      const collapsedItems = managedItems.filter((item) => item.collapsed);
      if (willOverflow && !hasOverflowedItems) {
        const overflowItem = findItemToCollapse(managedItems);
        if (overflowItem) {
          dispatch({
            type: "collapse-instant-item",
            overflowItem
          });
        }
      } else if (collapsedItems.length > 0 && containerHasGrown) {
        updateCollapse(size, null);
      } else if (willOverflow && hasOverflowedItems) {
        const renderedSize = managedItems.reduce(addAll, 0);
        updateCollapse(size, renderedSize);
      }
    },
    [
      dispatch,
      hasOverflowedItems,
      orientation,
      overflowItemsRef,
      ref,
      updateCollapse
    ]
  );
  const resetMeasurements = useCallback(
    (isOverflowing) => {
      const { current: managedItems } = overflowItemsRef;
      if (isOverflowing) {
        const overflowItem = findItemToCollapse(managedItems);
        if (overflowItem) {
          dispatch({
            type: "collapse-instant-item",
            overflowItem
          });
          return true;
        } else {
          return false;
        }
      }
    },
    [dispatch, overflowItemsRef]
  );
  const setMinSize = useCallback(
    (item, size) => {
      const minMaxSize = minMaxSizes.get(item.index);
      if (minMaxSize) {
        minMaxSize.minSize = size;
      } else {
        minMaxSizes.set(item.index, { maxSize: null, minSize: size });
      }
    },
    [minMaxSizes]
  );
  const measureCollapsedItem = useCallback(() => {
    const { current: managedItems } = overflowItemsRef;
    const dimension = orientation === "horizontal" ? "width" : "height";
    const [collapsedItem] = managedItems.filter(
      (item) => item.collapsible === "instant" && item.collapsed
    );
    console.log(`measureCollapsedItem ${collapsedItem.index}`);
    if (collapsedItem.fullSize === null) {
      const target = getElementForItem(ref, collapsedItem);
      if (target) {
        const collapsedSize = measureElementSize(target, dimension);
        const managedItem = findItemToCollapse(managedItems);
        const diff = collapsedItem.size - collapsedSize;
        const renderedSize = managedItems.reduce(addAll, 0) - diff;
        const updates = [];
        if (renderedSize > innerContainerSize && managedItem) {
          console.log(`next item to collapse ${managedItem.index}`);
          updates.push(
            {
              ...collapsedItem,
              fullSize: collapsedItem.size,
              size: collapsedSize
            },
            {
              ...managedItem,
              collapsed: true
            }
          );
        } else {
          updates.push({
            ...collapsedItem,
            fullSize: collapsedItem.size,
            size: collapsedSize
          });
        }
        dispatch({
          type: "update-items",
          overflowItems: updates
        });
        setMinSize(collapsedItem, collapsedSize);
      }
    } else {
      return -1;
    }
  }, [
    dispatch,
    innerContainerSize,
    orientation,
    overflowItemsRef,
    ref,
    setMinSize
  ]);
  useIsomorphicLayoutEffect(() => {
    const { current: managedItems } = overflowItemsRef;
    const newlyCollapsedItem = newlyCollapsed(managedItems);
    if (newlyCollapsedItem) {
      measureCollapsedItem();
    }
  });
  return {
    onResize: handleResize,
    resetMeasurements
  };
};

export { useInstantCollapse };
//# sourceMappingURL=useInstantCollapse.js.map
