import { useRef, useCallback } from 'react';
import { popNextItemByPriority, notOverflowed, isOverflowed, allExceptOverflowIndicator, getOverflowIndicator, measureContainerOverflow, addAll } from './overflowUtils.js';
import { partition } from '../utils/partition.js';
import { useIdMemo } from '@salt-ds/core';

const NO_OVERFLOW_INDICATOR = { size: 0 };
const getPriority = (item) => item.priority;
const popNextOverflowedItem = (items) => {
  const minPriority = Math.min(...items.map(getPriority));
  for (let i = 0; i < items.length; i++) {
    if (!items[i].isOverflowIndicator && items[i].priority === minPriority) {
      return items.splice(i, 1)[0];
    }
  }
  return null;
};
const useOverflow = ({
  collectionHook: { dispatch },
  id: idProp,
  label = "Toolbar",
  overflowItemsRef,
  overflowContainerRef,
  orientation
}) => {
  const innerContainerSizeRef = useRef(0);
  const overflowIndicatorSize = useRef(0);
  const id = useIdMemo(idProp);
  const setContainerMinSize = useCallback(
    (size) => {
      if (overflowContainerRef.current) {
        const isHorizontal = orientation === "horizontal";
        if (size === void 0) {
          const dimension = isHorizontal ? "width" : "height";
          ({ [dimension]: size } = overflowContainerRef.current.getBoundingClientRect());
        }
        if (typeof size === "number") {
          const styleDimension = isHorizontal ? "minWidth" : "minHeight";
          overflowContainerRef.current.style[styleDimension] = `${size}px`;
        }
      }
    },
    [orientation, overflowContainerRef]
  );
  const getAllOverflowedItems = useCallback(
    (renderedSize, availableSpace) => {
      const { current: allItems } = overflowItemsRef;
      const overflowedItems = [];
      const items = allItems.slice();
      while (renderedSize > availableSpace) {
        const overflowedItem = popNextItemByPriority(items);
        if (overflowedItem === null) {
          break;
        }
        renderedSize -= overflowedItem.size;
        overflowedItems.push({
          ...overflowedItem,
          overflowed: true
        });
      }
      return overflowedItems;
    },
    [overflowItemsRef]
  );
  const getOverflowedItems = useCallback(
    (visibleContentSize, containerSize) => {
      const newlyOverflowedItems = [];
      const { current: managedItems } = overflowItemsRef;
      const visibleItems = managedItems.filter(notOverflowed);
      while (visibleContentSize > containerSize) {
        const overflowedItem = popNextItemByPriority(visibleItems);
        if (overflowedItem === null) {
          break;
        }
        visibleContentSize -= overflowedItem.size;
        newlyOverflowedItems.push({
          ...overflowedItem,
          overflowed: true
        });
      }
      return newlyOverflowedItems;
    },
    [overflowItemsRef]
  );
  const getReinstatedItems = useCallback(
    (containerSize) => {
      const reinstatedItems = [];
      const { current: managedItems } = overflowItemsRef;
      const [overflowedItems, visibleItems] = partition(
        managedItems,
        isOverflowed
      );
      const overflowCount = overflowedItems.length;
      let visibleContentSize = visibleItems.reduce(
        allExceptOverflowIndicator,
        0
      );
      let diff = containerSize - visibleContentSize;
      const { size: overflowSize = 0 } = getOverflowIndicator(managedItems) || NO_OVERFLOW_INDICATOR;
      const totalOverflowedSize = overflowedItems.reduce(
        (sum, item) => sum + item.size,
        0
      );
      if (totalOverflowedSize <= diff) {
        reinstatedItems.push(
          ...overflowedItems.map((item) => ({ ...item, overflowed: false }))
        );
      } else {
        while (overflowedItems.length > 0) {
          const nextItem = popNextOverflowedItem(overflowedItems);
          if (nextItem && diff >= nextItem.size) {
            if (overflowedItems.length === 0 || diff >= nextItem.size + overflowSize) {
              visibleContentSize += nextItem.size;
              diff = diff - nextItem.size;
              reinstatedItems.push({
                ...nextItem,
                overflowed: false
              });
            } else {
              break;
            }
          } else {
            break;
          }
        }
      }
      return [overflowCount, reinstatedItems];
    },
    []
  );
  const resetMeasurements = useCallback(
    (isOverflowing, innerContainerSize) => {
      if (isOverflowing) {
        const { current: managedItems } = overflowItemsRef;
        const renderedSize = managedItems.reduce(allExceptOverflowIndicator, 0);
        const overflowIndicator = managedItems.find(
          (i) => i.isOverflowIndicator
        );
        if (overflowIndicator && overflowIndicator.size !== overflowIndicatorSize.current) {
          overflowIndicatorSize.current = overflowIndicator.size;
          setContainerMinSize(overflowIndicator.size);
        }
        const existingOverflow = managedItems.filter(isOverflowed);
        const updates = getAllOverflowedItems(
          renderedSize,
          innerContainerSize - overflowIndicatorSize.current
        );
        existingOverflow.forEach((item) => {
          if (!updates.some((i) => i.index === item.index)) {
            updates.push({
              ...item,
              overflowed: false
            });
          }
        });
        const overflowAdded = !existingOverflow.length && updates.length;
        if (updates.length > 0) {
          if (overflowAdded) {
            dispatch({
              type: "update-items-add-overflow-indicator",
              overflowItems: updates,
              overflowItem: {
                fullSize: null,
                id: `${id}-overflow-indicator`,
                index: managedItems.length,
                isOverflowIndicator: true,
                label: "Overflow Menu",
                priority: 1,
                source: {}
              }
            });
          } else {
            dispatch({
              type: "update-items",
              overflowItems: updates
            });
          }
          return true;
        } else {
          return false;
        }
      }
    },
    [dispatch, getAllOverflowedItems, id, overflowItemsRef, setContainerMinSize]
  );
  const updateOverflow = useCallback(
    (containerSize, renderedSize) => {
      if (containerSize < renderedSize) {
        const overflowItems = getOverflowedItems(renderedSize, containerSize);
        if (overflowItems.length) {
          dispatch({
            type: "update-items",
            overflowItems
          });
        }
      }
    },
    [dispatch, getOverflowedItems]
  );
  const removeOverflow = useCallback(
    (containerSize) => {
      const [overflowCount, reinstated] = getReinstatedItems(containerSize);
      if (reinstated.length) {
        if (overflowCount === reinstated.length) {
          dispatch({
            type: "update-items-remove-overflow-indicator",
            overflowItems: reinstated
          });
        } else {
          dispatch({
            type: "update-items",
            overflowItems: reinstated
          });
        }
      }
    },
    [dispatch, getReinstatedItems]
  );
  const handleResize = useCallback(
    (size, containerHasGrown) => {
      const { current: managedItems } = overflowItemsRef;
      const wasOverflowing = managedItems.some(
        (item) => item.isOverflowIndicator
      );
      const { isOverflowing } = measureContainerOverflow(
        overflowContainerRef,
        orientation
      );
      innerContainerSizeRef.current = size;
      if (!wasOverflowing && isOverflowing) {
        resetMeasurements(true, size);
      } else if (wasOverflowing && containerHasGrown) {
        removeOverflow(size);
      } else if (wasOverflowing && isOverflowing) {
        const renderedSize = managedItems.filter(notOverflowed).reduce(addAll, 0);
        updateOverflow(size, renderedSize);
      }
    },
    [
      orientation,
      overflowContainerRef,
      overflowItemsRef,
      removeOverflow,
      resetMeasurements,
      updateOverflow
    ]
  );
  return {
    onResize: handleResize,
    resetMeasurements
  };
};

export { useOverflow };
//# sourceMappingURL=useOverflow.js.map
