import React, { isValidElement } from 'react';

const DEFAULT_PRIORITY = 3;
const mapReactElementChildren = (children, fn) => {
  const childElements = [];
  React.Children.forEach(children, (child, i) => {
    if (isValidElement(child)) {
      childElements.push(fn(child, i));
    }
  });
  return childElements;
};
const sourceItem = (item, id, index, options) => {
  var _a, _b, _c, _d;
  const priority = (_c = (_b = (_a = options == null ? void 0 : options.getPriority) == null ? void 0 : _a.call(options, item, index)) != null ? _b : item.priority) != null ? _c : DEFAULT_PRIORITY;
  return {
    closeable: item.closeable || (options == null ? void 0 : options.closeable),
    editable: options == null ? void 0 : options.editable,
    element: null,
    fullSize: null,
    id: (_d = item.id) != null ? _d : id,
    index,
    label: item.label,
    position: item.position,
    priority,
    size: 0,
    source: item,
    type: "source"
  };
};
const createSourceItems = (source, idRoot, options) => {
  if (Array.isArray(source)) {
    return source.map((item, index) => {
      var _a;
      (_a = options == null ? void 0 : options.getPriority) == null ? void 0 : _a.call(options, source, index);
      return sourceItem(item, `${idRoot}-${index}`, index, options);
    });
  }
};
const childItem = (child, id, index, options) => {
  var _a;
  const {
    closeable,
    disabled,
    id: idProp,
    label,
    "data-collapsible": collapsible,
    "data-editable": editable,
    "data-position": dataPosition,
    "data-priority": dataPriority = "2"
  } = child.props;
  const priority = (_a = options == null ? void 0 : options.getPriority) == null ? void 0 : _a.call(options, child, index);
  return {
    closeable: closeable || (options == null ? void 0 : options.closeable),
    collapsible,
    editable: editable ? true : options == null ? void 0 : options.editable,
    disabled,
    fullSize: null,
    id: idProp != null ? idProp : id,
    index,
    element: child,
    label,
    position: dataPosition,
    priority: priority != null ? priority : parseInt(dataPriority),
    size: 0,
    source: null,
    type: "child"
  };
};
const createChildItems = (children, idRoot, options) => {
  if (children) {
    return mapReactElementChildren(children, (child, index) => {
      const id = `${idRoot}-${index}`;
      return childItem(child, id, index, options);
    });
  }
};
const createInjectedContent = (items, idRoot, startIndex) => {
  return items.map((item, i) => {
    const index = startIndex + i;
    const id = `${idRoot}-${index}`;
    const { source } = item;
    if (source) {
      const injectedItem = sourceItem(source, id, index);
      injectedItem.isInjectedItem = true;
      return injectedItem;
    } else {
      const { element } = item;
      const injectedItem = childItem(element, id, index);
      injectedItem.isInjectedItem = true;
      return injectedItem;
    }
  });
};
const defaultOptions = {};
const reducerInitialiser = ({
  children,
  source,
  injectedItems = [],
  idRoot,
  options = defaultOptions
}) => {
  const providedContent = createChildItems(children, idRoot, options) || createSourceItems(source, idRoot, options) || [];
  const injectedContent = createInjectedContent(
    injectedItems,
    idRoot,
    providedContent.length
  );
  return providedContent.concat(injectedContent);
};
const collapsingItem = (items, { overflowItem }) => items.map(
  (item) => item === overflowItem ? {
    ...item,
    collapsing: true
  } : item
);
const uncollapseDynamicItem = (items, { overflowItem }) => items.map(
  (item) => item === overflowItem ? {
    ...item,
    collapsed: false,
    collapsing: true,
    size: item.fullSize,
    fullSize: null
  } : item
);
const collapseInstantItem = (items, { overflowItem }) => items.map(
  (item) => item === overflowItem ? {
    ...item,
    collapsed: true
  } : item
);
const replaceItem = (items, { overflowItem }) => items.map(
  (item) => item.index === (overflowItem == null ? void 0 : overflowItem.index) ? overflowItem : item
);
const updateItems = (items, { overflowItems = [] }) => {
  return items.map((item) => {
    const targetItem = overflowItems.find((i) => i.id === item.id);
    return targetItem ? { ...item, ...targetItem } : item;
  });
};
const restoreCollapsingItem = (items) => {
  const collapsingItem2 = items.find(
    ({ collapsible, collapsing }) => collapsible === "dynamic" && collapsing
  );
  const collapsedItem = items.find(
    ({ collapsible, collapsed }) => collapsible === "dynamic" && collapsed
  );
  return items.map((item) => {
    if (item === collapsingItem2) {
      return {
        ...item,
        collapsing: false
      };
    } else if (item === collapsedItem) {
      return {
        ...item,
        collapsed: false,
        collapsing: true
      };
    } else {
      return item;
    }
  });
};
const collapseDynamicItem = (items, { overflowItem, collapsedSize = 0, minSize = 0 }) => {
  const remainingUncollpasedItems = items.filter(
    (i) => i.collapsible === "dynamic" && !i.collapsed && i !== overflowItem
  );
  const lastUncollapsedItem = remainingUncollpasedItems.pop();
  return items.map((item) => {
    if (item === overflowItem) {
      return {
        ...item,
        collapsing: false,
        collapsed: true,
        fullSize: item.size,
        minSize,
        size: collapsedSize
      };
    } else if (item === lastUncollapsedItem) {
      return {
        ...item,
        collapsing: true
      };
    } else {
      return item;
    }
  });
};
const addSourceItem = (items, { idRoot, source }) => {
  const index = items.length;
  return items.concat(sourceItem(source, `${idRoot}-${index}`, index));
};
const removeItem = (items, { indexPosition }) => {
  return items.slice(0, indexPosition).concat(items.slice(indexPosition + 1));
};
const addOverflowIndicator = (items, { overflowItem }) => {
  if (!items.find((i) => i.isOverflowIndicator)) {
    if (items.find((i) => i.label === "Add Tab")) {
      const [addTab] = items.slice(-1);
      return items.slice(0, -1).concat({ ...overflowItem, index: addTab.index }).concat({ ...addTab, index: overflowItem.index });
    } else {
      return items.concat(overflowItem);
    }
  } else {
    return items;
  }
};
const overflowReducer = (state, action) => {
  var _a;
  switch (action.type) {
    case "init":
      return (_a = action.overflowItems) != null ? _a : state;
    case "add-overflow-indicator":
      return addOverflowIndicator(state, action);
    case "update-items":
      return updateItems(state, action);
    case "replace-item":
      return replaceItem(state, action);
    case "update-items-add-overflow-indicator":
      return addOverflowIndicator(
        updateItems(state, {
          type: "update-items",
          overflowItems: action.overflowItems
        }),
        { type: "add-overflow-indicator", overflowItem: action.overflowItem }
      );
    case "update-items-remove-overflow-indicator":
      return updateItems(state, {
        type: "update-items",
        overflowItems: action.overflowItems
      }).filter((item) => !item.isOverflowIndicator);
    case "collapsing-item":
      return collapsingItem(state, action);
    case "collapse-dynamic-item":
      return collapseDynamicItem(state, action);
    case "uncollapse-dynamic-item":
      return uncollapseDynamicItem(state, action);
    case "restore-collapsing-item":
      return restoreCollapsingItem(state);
    case "collapse-instant-item":
      return collapseInstantItem(state, action);
    case "add-source-item":
      return addSourceItem(state, action);
    case "remove-item":
      return removeItem(state, action);
    default:
      return state;
  }
};

export { overflowReducer, reducerInitialiser };
//# sourceMappingURL=OverflowReducer.js.map
