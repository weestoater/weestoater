import { useRef, useCallback, useEffect } from 'react';
import { getIsOverflowed, measureContainerOverflow } from './overflowUtils.js';
import { useDynamicCollapse } from './useDynamicCollapse.js';
import { useInstantCollapse } from './useInstantCollapse.js';
import { useOverflow } from './useOverflow.js';
import { useReclaimSpace } from './useReclaimSpace.js';
import { useResizeObserver } from './useResizeObserver.js';
import '@salt-ds/core';

const MONITORED_DIMENSIONS = {
  horizontal: ["width", "scrollHeight"],
  vertical: ["height", "scrollWidth"],
  none: []
};
const useOverflowLayout = ({
  collectionHook,
  id,
  orientation,
  label = "Toolbar",
  disableOverflow = false
}) => {
  const overflowContainerRef = useRef(null);
  const overflowItemsRef = useRef([]);
  const measurement = useRef({ innerContainerSize: 0, rootContainerDepth: 0 });
  const { innerContainerSize } = measurement.current;
  const { dispatch, version: collectionVersion } = collectionHook;
  overflowItemsRef.current = collectionHook.data;
  const {
    onResize: onOverflowResize,
    resetMeasurements: resetOverflowMeasurements
  } = useOverflow({
    collectionHook,
    id,
    label,
    overflowItemsRef,
    orientation,
    overflowContainerRef
  });
  const hasOverflowedItems = getIsOverflowed(collectionHook.data);
  const {
    onResize: onDynamicResize,
    resetMeasurements: resetDynamicMeasurements
  } = useDynamicCollapse({
    collectionHook,
    innerContainerSize,
    label,
    overflowItemsRef,
    orientation,
    overflowContainerRef
  });
  const {
    onResize: onInstantResize,
    resetMeasurements: resetInstantMeasurements
  } = useInstantCollapse({
    collectionHook,
    hasOverflowedItems,
    innerContainerSize,
    label,
    overflowItemsRef,
    orientation,
    overflowContainerRef
  });
  const { onResize: onReclaimResize } = useReclaimSpace({
    collectionHook,
    label,
    overflowItemsRef,
    orientation,
    overflowContainerRef
  });
  const resizeHandler = useCallback(
    ({
      scrollHeight,
      height = scrollHeight,
      scrollWidth,
      width = scrollWidth
    }) => {
      const size = orientation === "horizontal" ? width : height;
      if (typeof size === "number") {
        const { innerContainerSize: innerContainerSize2 } = measurement.current;
        const sizeDiff = size - innerContainerSize2;
        if (Math.abs(sizeDiff) > 0.5) {
          measurement.current.innerContainerSize = size;
          const containerHasGrown = size > innerContainerSize2;
          onDynamicResize(size, containerHasGrown);
          onInstantResize(size, containerHasGrown);
          onOverflowResize(size, containerHasGrown);
          onReclaimResize(size, containerHasGrown);
        }
      }
    },
    [
      onDynamicResize,
      onInstantResize,
      onOverflowResize,
      onReclaimResize,
      orientation
    ]
  );
  const measureAndInitialize = useCallback(() => {
    const { isOverflowing, ...contentWidthAndDepth } = measureContainerOverflow(
      overflowContainerRef,
      orientation
    );
    measurement.current = contentWidthAndDepth;
    const { innerContainerSize: innerContainerSize2 } = contentWidthAndDepth;
    let handled = resetInstantMeasurements(isOverflowing);
    if (!handled) {
      handled = resetDynamicMeasurements();
      if (!handled) {
        resetOverflowMeasurements == null ? void 0 : resetOverflowMeasurements(isOverflowing, innerContainerSize2);
      }
    }
  }, [
    orientation,
    resetInstantMeasurements,
    resetDynamicMeasurements,
    resetOverflowMeasurements
  ]);
  const switchPriorities = useCallback(
    (item1, item2) => {
      const { priority: priority1 } = item1;
      const { priority: priority2 } = item2;
      if (priority1 !== priority2) {
        dispatch({
          type: "update-items",
          overflowItems: [
            { id: item1.id, priority: priority2 },
            { id: item2.id, priority: priority1 }
          ]
        });
        setTimeout(measureAndInitialize, 0);
      }
    },
    [dispatch, measureAndInitialize]
  );
  useResizeObserver(
    overflowContainerRef,
    MONITORED_DIMENSIONS[disableOverflow ? "none" : orientation],
    resizeHandler
  );
  useEffect(() => {
    if (!disableOverflow) {
      measureAndInitialize();
    }
  }, [collectionVersion, disableOverflow, measureAndInitialize]);
  return [overflowContainerRef, switchPriorities];
};

export { useOverflowLayout };
//# sourceMappingURL=useOverflowLayout.js.map
