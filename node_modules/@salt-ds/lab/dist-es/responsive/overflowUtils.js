import { jsx } from 'react/jsx-runtime';

const DropdownPlaceholder = () => null;
const getDropdownPlaceholder = () => /* @__PURE__ */ jsx(DropdownPlaceholder, {});
const NO_DATA = {};
const LEFT_RIGHT = ["left", "right"];
const TOP_BOTTOM = ["top", "bottom"];
const allExceptOverflowIndicator = (sum, m) => sum + (m.isOverflowIndicator ? 0 : m.size);
const isCollapsed = (item) => item.collapsed === true;
const isCollapsing = (item) => item.collapsing === true;
const isCollapsedOrCollapsing = (item) => isCollapsed(item) || isCollapsing(item);
const isOverflowed = (item) => item.overflowed === true;
const notOverflowed = (item) => !isOverflowed(item);
const isCollapsible = (item) => item.collapsible === "instant" || item.collapsible === "dynamic";
const getIsOverflowed = (managedItems) => managedItems.some(isOverflowed);
const measureContainer = (ref, orientation = "horizontal") => {
  const innerElement = ref.current;
  const container = innerElement.parentElement;
  if (container) {
    const { width: innerWidth, height: innerHeight } = innerElement.getBoundingClientRect();
    const { width, height } = container.getBoundingClientRect();
    if (orientation === "horizontal") {
      return {
        innerContainerSize: innerWidth,
        rootContainerDepth: height,
        innerContainerDepth: innerHeight
      };
    } else {
      return {
        innerContainerSize: innerHeight,
        rootContainerDepth: width,
        innerContainerDepth: innerWidth
      };
    }
  } else {
    throw Error("measureContainer, innerContainer has no parent element");
  }
};
const isContainerOverflowing = (containerDepth, parentContainerDepth, innerElement, orientation) => {
  const isHorizontal = orientation === "horizontal";
  if (containerDepth > parentContainerDepth) {
    return true;
  } else {
    const { bottom, right } = innerElement.getBoundingClientRect();
    const maxPos = Array.from(innerElement.childNodes).reduce(
      (maxVal, child) => {
        const rect = child.getBoundingClientRect();
        return Math.max(isHorizontal ? rect.bottom : rect.right, maxVal);
      },
      isHorizontal ? bottom : right
    );
    return isHorizontal ? maxPos > bottom : maxPos > right;
  }
};
const measureContainerOverflow = (ref, orientation = "horizontal") => {
  const { innerContainerDepth, innerContainerSize, rootContainerDepth } = measureContainer(ref, orientation);
  const innerElement = ref.current;
  const isOverflowing = isContainerOverflowing(
    innerContainerDepth,
    rootContainerDepth,
    innerElement,
    orientation
  );
  return { isOverflowing, innerContainerSize, rootContainerDepth };
};
function measureElementSize(element, dimension = "width", includeAutoMargin = false) {
  const { [dimension]: size } = element.getBoundingClientRect();
  const { padEnd = false, padStart = false } = element.dataset;
  const style = getComputedStyle(element);
  const [start, end] = dimension === "width" ? LEFT_RIGHT : TOP_BOTTOM;
  const marginStart = padStart && !includeAutoMargin ? 0 : parseInt(style.getPropertyValue(`margin-${start}`), 10);
  const marginEnd = padEnd && !includeAutoMargin ? 0 : parseInt(style.getPropertyValue(`margin-${end}`), 10);
  let minWidth = size;
  const flexShrink = parseInt(style.getPropertyValue("flex-shrink"), 10);
  if (flexShrink > 0) {
    const flexBasis = parseInt(style.getPropertyValue("flex-basis"), 10);
    if (!isNaN(flexBasis) && flexBasis > 0) {
      minWidth = flexBasis;
    }
  }
  return marginStart + minWidth + marginEnd;
}
const byDescendingPriority = (m1, m2) => {
  let result = m1.priority - m2.priority;
  if (result === 0) {
    result = m1.index - m2.index;
  }
  return result;
};
const getOverflowIndicator = (managedItems) => managedItems.find((item) => item.isOverflowIndicator);
const getPriority = (item) => item.priority;
const popNextItemByPriority = (items) => {
  const maxPriority = Math.max(...items.map(getPriority));
  for (let i = items.length - 1; i >= 0; i--) {
    if (!items[i].isOverflowIndicator && items[i].priority === maxPriority) {
      return items.splice(i, 1)[0];
    }
  }
  return null;
};
const measureOverflowItems = (items, dimension) => {
  const measurements = items.map(({ id }) => {
    const childElement = document.getElementById(id);
    const size = childElement ? measureElementSize(childElement, dimension) : 0;
    return size;
  });
  if (measurements.some((size, i) => size !== items[i].size)) {
    return items.map(
      (item, i) => item.size === measurements[i] ? item : {
        ...item,
        size: measurements[i]
      }
    );
  } else {
    return items;
  }
};
const addAll = (sum, m) => sum + m.size;
const getElementForItem = (ref, item) => ref.current.querySelector(
  `:scope > [data-index='${item.index}']`
);
const getRuntimePadding = (el, ...dimensions) => {
  const targetStyle = getComputedStyle(el);
  return dimensions.map(
    (dimension) => parseInt(targetStyle.getPropertyValue(`padding-${dimension}`), 10)
  );
};

export { DropdownPlaceholder, NO_DATA, addAll, allExceptOverflowIndicator, byDescendingPriority, getDropdownPlaceholder, getElementForItem, getIsOverflowed, getOverflowIndicator, getRuntimePadding, isCollapsed, isCollapsedOrCollapsing, isCollapsible, isCollapsing, isOverflowed, measureContainer, measureContainerOverflow, measureElementSize, measureOverflowItems, notOverflowed, popNextItemByPriority };
//# sourceMappingURL=overflowUtils.js.map
