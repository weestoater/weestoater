import { useIsomorphicLayoutEffect } from '@salt-ds/core';
import { useState, useCallback } from 'react';
import { measureElementSize, getElementForItem, getRuntimePadding, measureContainerOverflow, isCollapsible, isCollapsed, byDescendingPriority } from './overflowUtils.js';

const UNCOLLAPSED_DYNAMIC_ITEMS = '[data-collapsible="dynamic"]:not([data-collapsed="true"]):not([data-collapsing="true"])';
const hasUncollapsedDynamicItems = (containerRef) => containerRef.current.querySelector(UNCOLLAPSED_DYNAMIC_ITEMS) !== null;
const thereAreCollapsibleItemsAndTheyAreAllCollapsed = (items) => {
  const collapsibleItems = items.filter(isCollapsible);
  return collapsibleItems.length > 0 && collapsibleItems.every(isCollapsed);
};
const nextItemToCollapse = (listItems) => listItems.filter(isCollapsible).sort(byDescendingPriority).slice(-1)[0];
const useDynamicCollapse = ({
  collectionHook,
  innerContainerSize = 0,
  label = "Toolbar",
  overflowItemsRef: managedItemsRef,
  overflowContainerRef: ref,
  orientation
}) => {
  const { dispatch } = collectionHook;
  const [newCollapsingItem, setNewCollapsingItem] = useState(null);
  const restoreCollapsingItem = useCallback(() => {
    dispatch({
      type: "restore-collapsing-item"
    });
  }, [dispatch]);
  const collapseCollapsingItem = useCallback(
    (item, target, minSize) => {
      const styleDimension = orientation === "horizontal" ? "minWidth" : "minHeight";
      target.style[styleDimension] = `${minSize}px`;
      const size = measureElementSize(target);
      dispatch({
        type: "collapse-dynamic-item",
        overflowItem: item,
        collapsedSize: size,
        minSize
      });
    },
    [dispatch, orientation]
  );
  const checkDynamicContent = useCallback(
    (containerHasGrown) => {
      const { current: managedItems } = managedItemsRef;
      const collapsingChild = managedItems.find(
        ({ collapsible, collapsing }) => collapsible === "dynamic" && collapsing
      );
      const collapsedChild = managedItems.find(
        ({ collapsible, collapsed }) => collapsible === "dynamic" && collapsed
      );
      if (!collapsingChild && !collapsedChild) {
        return;
      }
      if (collapsedChild && !collapsingChild) {
        dispatch({
          type: "uncollapse-dynamic-item",
          overflowItem: collapsedChild
        });
      } else if (collapsingChild) {
        if (containerHasGrown && collapsedChild) {
          const collapsingElement = getElementForItem(ref, collapsingChild);
          const dimension = orientation === "horizontal" ? "width" : "height";
          const size = measureElementSize(collapsingElement, dimension);
          if (collapsedChild && size === collapsingChild.size) {
            restoreCollapsingItem();
          }
        } else {
          const dimension = orientation === "horizontal" ? "width" : "height";
          const collapsingElement = getElementForItem(ref, collapsingChild);
          const { [dimension]: measuredSizeOfCollapsingElement } = collapsingElement.getBoundingClientRect();
          const [padStart, padEnd] = getRuntimePadding(
            collapsingElement,
            "left",
            "right"
          );
          const lastTooltrayItem = collapsingElement.querySelector(
            ".Responsive-inner > :last-child"
          );
          if (lastTooltrayItem) {
            const { [dimension]: childMinSize } = lastTooltrayItem.getBoundingClientRect();
            const minSize = padStart + childMinSize + padEnd;
            if (Math.floor(measuredSizeOfCollapsingElement) <= minSize) {
              collapseCollapsingItem(
                collapsingChild,
                collapsingElement,
                minSize
              );
            }
          }
        }
      }
    },
    [
      collapseCollapsingItem,
      dispatch,
      managedItemsRef,
      orientation,
      ref,
      restoreCollapsingItem
    ]
  );
  const handleResize = useCallback(
    (size, containerHasGrown) => {
      const { current: managedItems } = managedItemsRef;
      const { isOverflowing: willOverflow } = measureContainerOverflow(
        ref,
        orientation
      );
      const collapsingItem = managedItems.find((item) => item.collapsing);
      if (collapsingItem) {
        checkDynamicContent(containerHasGrown);
      } else if (containerHasGrown && !willOverflow && thereAreCollapsibleItemsAndTheyAreAllCollapsed(managedItems)) {
        checkDynamicContent(true);
      }
    },
    [checkDynamicContent, managedItemsRef, orientation, ref]
  );
  const resetMeasurements = useCallback(() => {
    const { current: managedItems } = managedItemsRef;
    const hasDynamicItems = hasUncollapsedDynamicItems(ref);
    if (hasDynamicItems) {
      const collapsingItem = nextItemToCollapse(managedItems);
      setNewCollapsingItem(collapsingItem);
      dispatch({
        type: "collapsing-item",
        overflowItem: collapsingItem
      });
      return true;
    } else {
      return false;
    }
  }, [dispatch, managedItemsRef, ref]);
  useIsomorphicLayoutEffect(() => {
    if (newCollapsingItem) {
      checkDynamicContent(false);
    }
  }, [checkDynamicContent, newCollapsingItem]);
  return {
    onResize: handleResize,
    resetMeasurements
  };
};

export { useDynamicCollapse };
//# sourceMappingURL=useDynamicCollapse.js.map
