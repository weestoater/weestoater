import { useFormFieldProps, useDensity, useId, useForkRef, useControlled, useIsomorphicLayoutEffect, ownerWindow } from '@salt-ds/core';
import copy from 'clipboard-copy';
import { useState, useRef, useMemo, useCallback } from 'react';
import { escapeRegExp } from '../utils/escapeRegExp.js';
import { useWidth, getPadding } from './internal/useWidth.js';
import { useResizeObserver } from './internal/useResizeObserver.js';
import { calcFirstHiddenIndex } from './internal/calcFirstHiddenIndex.js';

const getCursorPosition = (inputRef) => {
  if (inputRef.current) {
    const { selectionStart, selectionEnd } = inputRef.current;
    if (selectionStart != null && selectionStart === selectionEnd) {
      return selectionStart;
    }
  }
  return -1;
};
const isCtrlModifier = (event) => {
  return event.ctrlKey || event.metaKey || ["CONTROL", "META"].indexOf(event.key.toUpperCase()) !== -1;
};
function isValidItem(data) {
  return typeof data === "string" && Boolean(data.length) || typeof data !== "string" && data != null;
}
function useTokenizedInputNext(props) {
  const {
    disabled: formFieldDisabled,
    readOnly,
    necessity,
    validationStatus,
    a11yProps: {
      "aria-describedby": ariaDescribedBy,
      "aria-labelledby": ariaLabelledBy
    } = {}
  } = useFormFieldProps();
  const {
    delimiters = [","],
    defaultSelected = [],
    disabled = formFieldDisabled,
    readOnly: readOnlyProp,
    validationStatus: validationStatusProp,
    disableAddOnBlur,
    onBlur,
    onClick,
    onExpand,
    onCollapse,
    onKeyDown,
    onInputChange,
    onInputFocus,
    onInputBlur,
    onClear,
    onChange,
    id: idProp,
    value: valueProp,
    expanded: expandedProp,
    selectedItems: selectedItemsProp,
    "aria-label": ariaLabel,
    "aria-describedby": ariaDescribedByProp,
    expandButtonRef: expandButtonRefProp,
    ...restProps
  } = props;
  const density = useDensity();
  const id = useId(idProp);
  const [focused, setFocused] = useState(false);
  const [pillGroupWidth, setPillGroupWidth] = useState(null);
  const [firstHiddenIndex, setFirstHiddenIndex] = useState(null);
  const [activeIndices, setActiveIndices] = useState([]);
  const [highlightedIndex, setHighlightedIndex] = useState(
    void 0
  );
  const [expandButtonHookRef, expandButtonWidth] = useWidth(density);
  const [clearButtonRef, clearButtonWidth] = useWidth(density);
  const [statusAdornmentRef, statusAdornmentWidth] = useWidth(density);
  const [inputRef, inputWidth] = useWidth(density);
  const containerRef = useRef(null);
  const pillsRef = useRef({});
  const textAreaRef = useRef(null);
  const preventBlurOnCopy = useRef(false);
  const expandButtonRef = useForkRef(expandButtonHookRef, expandButtonRefProp);
  const hasActiveItems = Boolean(activeIndices.length);
  const primaryDelimiter = delimiters[0];
  const delimiterRegex = useMemo(
    () => new RegExp(delimiters.map(escapeRegExp).join("|"), "gi"),
    [delimiters]
  );
  const [value, setValue, isInputControlled] = useControlled({
    controlled: valueProp,
    default: "",
    name: "TokenizedInputNext",
    state: "value"
  });
  const [selectedItems = [], setSelectedItems, isSelectionControlled] = useControlled({
    controlled: selectedItemsProp,
    default: defaultSelected,
    name: "TokenizedInputNext",
    state: "selectedItems"
  });
  const [expanded, setExpanded, isExpandedControlled] = useControlled({
    controlled: expandedProp,
    default: false,
    name: "TokenizedInputNext",
    state: "expanded"
  });
  const widthOffset = inputWidth + statusAdornmentWidth + (expanded ? clearButtonWidth : expandButtonWidth);
  const containerObserverRef = useResizeObserver(
    useCallback(
      ([{ contentRect }]) => {
        const padding = getPadding(containerRef.current);
        setPillGroupWidth(contentRect.width - padding - widthOffset);
      },
      [widthOffset]
    )
  );
  useIsomorphicLayoutEffect(
    () => () => {
      setFirstHiddenIndex(null);
    },
    [density]
  );
  useIsomorphicLayoutEffect(
    () => {
      if (expanded) {
        setFirstHiddenIndex(null);
      } else if (pillGroupWidth != null) {
        setFirstHiddenIndex(
          calcFirstHiddenIndex({
            containerWidth: pillGroupWidth,
            pillWidths: Object.values(pillsRef.current).filter(
              Boolean
            )
          })
        );
      }
    },
    [expanded, pillGroupWidth, selectedItems]
  );
  const focusInput = useCallback(() => {
    if (textAreaRef.current) {
      textAreaRef.current.focus();
    }
  }, []);
  const updateInputValue = (newValue) => {
    if (!isInputControlled) {
      setValue(newValue);
    }
  };
  const updateSelectedItems = useCallback(
    (event, action) => {
      if (!isSelectionControlled) {
        setSelectedItems((prevSelectedItems) => {
          const newItems = typeof action === "function" ? action(prevSelectedItems) : action;
          if (newItems !== prevSelectedItems) {
            onChange == null ? void 0 : onChange(event, newItems);
          }
          return newItems;
        });
      } else {
        onChange == null ? void 0 : onChange(
          event,
          typeof action === "function" ? action(selectedItems) : action
        );
      }
    },
    [isSelectionControlled, setSelectedItems, onChange, selectedItems]
  );
  const updateExpanded = (event, newExpanded) => {
    if (!isExpandedControlled) {
      setExpanded(newExpanded);
    }
    if (newExpanded) {
      focusInput();
      onExpand == null ? void 0 : onExpand(event);
    } else {
      onCollapse == null ? void 0 : onCollapse(event);
    }
  };
  const resetInput = () => {
    updateInputValue("");
    setHighlightedIndex(void 0);
    setActiveIndices([]);
  };
  const removeItems = useCallback(
    (event, itemIndices) => {
      updateSelectedItems(
        event,
        (prevSelectedItems) => prevSelectedItems && (prevSelectedItems.length === 0 ? prevSelectedItems : prevSelectedItems.filter(
          (_, index) => itemIndices.indexOf(index) === -1
        ))
      );
    },
    [updateSelectedItems]
  );
  const handleInputFocus = (event) => {
    event.stopPropagation();
    if (preventBlurOnCopy.current) {
      preventBlurOnCopy.current = false;
      setActiveIndices(
        Array.from(
          { length: selectedItems ? selectedItems.length : 0 },
          (_, index) => index
        )
      );
      return;
    }
    onInputFocus == null ? void 0 : onInputFocus(event);
    updateExpanded(event, true);
    setFocused(true);
  };
  const handleBlur = (event) => {
    onBlur == null ? void 0 : onBlur(event);
    setFocused(false);
    updateExpanded(event, false);
  };
  const handleInputBlur = (event) => {
    const container = containerRef == null ? void 0 : containerRef.current;
    const eventTarget = event.relatedTarget;
    event.preventDefault();
    event.stopPropagation();
    setHighlightedIndex(void 0);
    setActiveIndices([]);
    if (!disableAddOnBlur) {
      handleAddItems(event, value);
    }
    onInputBlur == null ? void 0 : onInputBlur(event);
    if (eventTarget !== container && !(container == null ? void 0 : container.contains(eventTarget))) {
      handleBlur(event);
    }
  };
  const handleClick = (event) => {
    updateExpanded(event, true);
    setActiveIndices([]);
    onClick == null ? void 0 : onClick(event);
  };
  const handleInputChange = (event) => {
    setHighlightedIndex(void 0);
    onInputChange == null ? void 0 : onInputChange(event);
    const newValue = event.target.value;
    if (delimiterRegex.test(newValue)) {
      handleAddItems(event, newValue);
    } else {
      updateInputValue(newValue);
    }
  };
  const handleAddItems = (event, newValue, appendOnly) => {
    if (!newValue || newValue.length === 0) {
      return;
    }
    resetInput();
    const newItems = newValue.split(delimiterRegex).reduce((values, item) => {
      const newItem = item.trim();
      return isValidItem(newItem) ? values.concat(newItem) : values;
    }, []);
    if (newItems.length) {
      updateSelectedItems(
        event,
        (prevSelectedItems = []) => hasActiveItems && !appendOnly ? newItems : prevSelectedItems.concat(newItems)
      );
    }
  };
  const handleRemoveItem = useCallback(
    (event, itemIndex) => {
      focusInput();
      if (itemIndex != void 0 && !readOnly && !readOnlyProp) {
        removeItems(event, [itemIndex]);
      }
    },
    [focusInput, removeItems]
  );
  const handleClear = (event) => {
    updateSelectedItems(event, []);
    resetInput();
    focusInput();
    onClear == null ? void 0 : onClear(event);
  };
  const cursorAtInputStart = () => getCursorPosition(textAreaRef) === 0 && Boolean(selectedItems.length);
  const highlightAtPillGroupEnd = () => highlightedIndex === selectedItems.length - 1;
  const pillGroupKeyDownHandlers = {
    ArrowLeft: (event) => {
      event.preventDefault();
      setHighlightedIndex(
        (prevHighlightedIndex) => prevHighlightedIndex == null ? selectedItems.length - 1 : Math.max(0, prevHighlightedIndex - 1)
      );
    },
    ArrowRight: (event) => {
      if (highlightAtPillGroupEnd()) {
        return setHighlightedIndex(void 0);
      }
      event.preventDefault();
      setHighlightedIndex(
        (prevHighlightedIndex) => prevHighlightedIndex == null ? prevHighlightedIndex : Math.min(selectedItems.length - 1, prevHighlightedIndex + 1)
      );
    },
    Backspace: (event) => {
      event.preventDefault();
      handleRemoveItem(event, highlightedIndex);
      setHighlightedIndex(
        (prevHighlightedIndex) => prevHighlightedIndex == null ? prevHighlightedIndex : Math.max(0, prevHighlightedIndex - 1)
      );
    },
    Home: (event) => {
      event.preventDefault();
      setHighlightedIndex(0);
    },
    End: (event) => {
      event.preventDefault();
      setHighlightedIndex(selectedItems.length - 1);
    },
    Enter: (event) => {
      event.preventDefault();
      handleRemoveItem(event, highlightedIndex);
    },
    Delete: (event) => {
      event.preventDefault();
      handleRemoveItem(event, highlightedIndex);
    },
    " ": (event) => {
      event.preventDefault();
      handleRemoveItem(event, highlightedIndex);
    }
  };
  const inputKeyDownHandlers = {
    ArrowLeft: (event) => {
      if (cursorAtInputStart()) {
        event.preventDefault();
        setHighlightedIndex(selectedItems.length - 1);
      }
    },
    Backspace: (event) => {
      if (hasActiveItems) {
        removeItems(event, activeIndices);
      } else if (cursorAtInputStart()) {
        setHighlightedIndex(selectedItems.length - 1);
      }
    },
    Delete: (event) => {
      if (hasActiveItems) {
        removeItems(event, activeIndices);
      }
    },
    Enter: (event) => {
      event.preventDefault();
      if (hasActiveItems) {
        removeItems(event, activeIndices);
      } else {
        handleAddItems(event, value);
      }
    }
  };
  const handleCtrlModifierKeyDown = (event) => {
    var _a;
    const win = ownerWindow(event.target);
    const supportClipboard = (_a = win.navigator) == null ? void 0 : _a.clipboard;
    switch (event.key.toUpperCase()) {
      case "A":
        setHighlightedIndex(void 0);
        setActiveIndices(
          Array.from({ length: selectedItems.length }, (_, index) => index)
        );
        break;
      case "C":
        const textToCopy = activeIndices.length > 0 ? activeIndices.map((index) => String(selectedItems[index])).concat(value != null ? String(value).trim() : "").filter(Boolean).join(primaryDelimiter) : highlightedIndex !== void 0 ? String(selectedItems[highlightedIndex] + ",") : "";
        copy(textToCopy).then((result) => {
          preventBlurOnCopy.current = !supportClipboard;
          return result;
        }).catch((error) => {
          console.error(error);
        });
        break;
      case "V":
        break;
      case "ARROWLEFT":
        pillGroupKeyDownHandlers.ArrowLeft(event);
        break;
      case "ARROWRIGHT":
        pillGroupKeyDownHandlers.ArrowRight(event);
        break;
      case "BACKSPACE":
        if (cursorAtInputStart()) {
          handleRemoveItem(event, selectedItems.length - 1);
        }
        break;
      case "CONTROL":
      case "META":
        break;
      default:
        setActiveIndices([]);
    }
  };
  const handleCommonKeyDown = (event) => {
    const eventKey = event.key.toUpperCase();
    if (eventKey === "ESCAPE") {
      event.preventDefault();
      resetInput();
    } else if (eventKey === "TAB" && !disableAddOnBlur) {
      handleAddItems(event, value);
    }
  };
  const handleKeyDown = (event) => {
    onKeyDown == null ? void 0 : onKeyDown(event);
    if (event.defaultPrevented) {
      return;
    }
    if (isCtrlModifier(event)) {
      handleCtrlModifierKeyDown(event);
    } else {
      let handler;
      if (highlightedIndex == null) {
        handler = inputKeyDownHandlers[event.key];
        setActiveIndices([]);
      } else {
        handler = pillGroupKeyDownHandlers[event.key];
      }
      if (handler != null) {
        handler(event);
      } else {
        handleCommonKeyDown(event);
      }
    }
  };
  const state = {
    value,
    selectedItems,
    activeIndices,
    highlightedIndex,
    expanded
  };
  const eventHandlers = {
    onBlur: expanded ? handleBlur : onBlur,
    onClick: handleClick,
    onInputChange: handleInputChange,
    onInputFocus: handleInputFocus,
    onInputBlur: handleInputBlur,
    onKeyDown: handleKeyDown,
    onRemoveItem: handleRemoveItem,
    onClear: handleClear
  };
  return {
    state,
    firstHiddenIndex,
    refs: {
      textAreaRef: useForkRef(textAreaRef, inputRef),
      pillsRef,
      clearButtonRef,
      expandButtonRef,
      statusAdornmentRef,
      containerRef: useForkRef(containerRef, containerObserverRef)
    },
    helpers: {
      setValue,
      setSelectedItems,
      setHighlightedIndex,
      updateExpanded
    },
    inputProps: {
      id,
      disabled,
      validationStatus: validationStatus != null ? validationStatus : validationStatusProp,
      readOnly: readOnly != null ? readOnly : readOnlyProp,
      necessity,
      focused,
      "aria-labelledby": ariaLabelledBy,
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescribedBy != null ? ariaDescribedBy : ariaDescribedByProp,
      ...state,
      ...restProps,
      ...disabled ? {} : eventHandlers
    }
  };
}

export { useTokenizedInputNext };
//# sourceMappingURL=useTokenizedInputNext.js.map
