import { useCallback, useState, useEffect, useMemo } from 'react';
import { useControlled, useIsFocusVisible } from '@salt-ds/core';

const useList = ({
  disabled = false,
  highlightedItem: highlightedItemProp,
  selected: selectedProp,
  defaultSelected,
  onChange,
  onSelect,
  id,
  ref
}) => {
  const getOptions = useCallback(() => {
    var _a, _b;
    return Array.from(
      (_b = (_a = ref.current) == null ? void 0 : _a.querySelectorAll('[role="option"]:not([aria-disabled])')) != null ? _b : []
    );
  }, [ref]);
  const [focusVisible, setFocusVisible] = useState(false);
  const [activeDescendant, setActiveDescendant] = useState(
    void 0
  );
  const [highlightedItem, setHighlightedItem] = useControlled({
    controlled: highlightedItemProp,
    default: void 0,
    name: "ListNext",
    state: "highlighted"
  });
  const [selectedItem, setSelectedItem] = useControlled({
    controlled: selectedProp,
    default: defaultSelected,
    name: "ListNext",
    state: "selected"
  });
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const updateScroll = useCallback(
    (currentTarget) => {
      const list = ref.current;
      if (!list || !currentTarget)
        return;
      const { offsetTop, offsetHeight } = currentTarget;
      const listHeight = list == null ? void 0 : list.clientHeight;
      const listScrollTop = list == null ? void 0 : list.scrollTop;
      if (offsetTop < listScrollTop) {
        list.scrollTop = offsetTop;
      } else if (offsetTop + offsetHeight > listScrollTop + listHeight) {
        list.scrollTop = offsetTop + offsetHeight - listHeight;
      }
    },
    [ref]
  );
  const updateHighlighted = useCallback(
    (element) => {
      setHighlightedItem(element.dataset.value);
      setActiveDescendant(element.id);
      updateScroll(element);
    },
    [setHighlightedItem, updateScroll]
  );
  const selectItem = useCallback(
    (element) => {
      const newValue = element == null ? void 0 : element.dataset.value;
      if (newValue) {
        setSelectedItem(newValue);
        updateHighlighted(element);
      }
    },
    [setSelectedItem, updateHighlighted]
  );
  useEffect(() => {
    var _a;
    const activeOptions = getOptions();
    const highlightedIndex = activeOptions.findIndex(
      (i) => i.dataset.value === highlightedItem
    );
    if (highlightedIndex) {
      setActiveDescendant((_a = activeOptions[highlightedIndex]) == null ? void 0 : _a.id);
      highlightedItem && updateScroll(activeOptions[highlightedIndex]);
    }
  }, [highlightedItem, getOptions, updateScroll]);
  const focusFirstItem = () => {
    const activeOptions = getOptions();
    const firstItem = activeOptions[0];
    if (firstItem) {
      updateHighlighted(firstItem);
    }
  };
  const focusLastItem = () => {
    const activeOptions = getOptions();
    const lastItem = activeOptions[activeOptions.length - 1];
    if (lastItem) {
      updateHighlighted(lastItem);
      updateScroll(lastItem);
    }
  };
  const findNextOption = (currentOption, moves) => {
    const activeOptions = getOptions();
    const nextOptionIndex = currentOption ? activeOptions.indexOf(currentOption) + moves : 0;
    return activeOptions[nextOptionIndex] || activeOptions[activeOptions.length - 1];
  };
  const findPreviousOption = (currentOption, moves) => {
    const activeOptions = getOptions();
    const currentOptionIndex = activeOptions.findIndex(
      (i) => i.id === currentOption.id
    );
    return activeOptions[currentOptionIndex - moves] || activeOptions[0];
  };
  const select = useCallback(
    (event) => {
      const newValue = event.currentTarget.dataset.value;
      const activeOptions = getOptions();
      const isActiveOption = activeOptions.findIndex((i) => i.id === event.currentTarget.id) !== -1;
      if (newValue && isActiveOption) {
        onSelect == null ? void 0 : onSelect(event, { value: newValue });
        if (selectedItem !== newValue) {
          selectItem(event.currentTarget);
          onChange == null ? void 0 : onChange(event, { value: selectedItem });
        }
      }
    },
    [selectItem, selectedItem, onChange, onSelect, getOptions]
  );
  const isSelected = useCallback(
    (value) => selectedItem === value,
    [selectedItem]
  );
  const highlight = useCallback(
    (event) => {
      setHighlightedItem(event.currentTarget.dataset.value);
    },
    [setHighlightedItem]
  );
  const isHighlighted = useCallback(
    (value) => highlightedItem === value,
    [highlightedItem]
  );
  const isFocused = useCallback(
    (value) => isHighlighted(value) && focusVisible,
    [focusVisible, isHighlighted]
  );
  const getActiveItem = () => {
    const activeOptions = getOptions();
    const activeIndex = activeOptions.findIndex(
      (i) => i.id === activeDescendant
    );
    return activeOptions[activeIndex];
  };
  const blurHandler = () => {
    handleBlurVisible();
    if (!isFocusVisibleRef.current) {
      setFocusVisible(false);
    }
  };
  const mouseOverHandler = () => {
    if (focusVisible) {
      setFocusVisible(false);
    }
  };
  const focusHandler = (event) => {
    handleFocusVisible(event);
    if (isFocusVisibleRef.current) {
      setFocusVisible(true);
    }
    const activeElement = getActiveItem();
    if (activeElement) {
      updateHighlighted(activeElement);
    } else {
      focusFirstItem();
    }
  };
  const keyDownHandler = (event) => {
    const { key } = event;
    const currentItem = getActiveItem();
    let nextItem = currentItem;
    if (isFocusVisibleRef.current || !focusVisible) {
      setFocusVisible(true);
    }
    switch (key) {
      case "ArrowUp":
      case "ArrowDown":
        if (!currentItem) {
          focusFirstItem();
          break;
        }
        nextItem = key === "ArrowUp" ? findPreviousOption(currentItem, 1) : findNextOption(currentItem, 1);
        if (nextItem && nextItem !== currentItem) {
          event.preventDefault();
          updateHighlighted(nextItem);
        }
        break;
      case "Home":
        event.preventDefault();
        focusFirstItem();
        break;
      case "End":
        event.preventDefault();
        focusLastItem();
        break;
      case " ":
      case "Enter":
        event.preventDefault();
        if (nextItem) {
          selectItem(nextItem);
          onChange == null ? void 0 : onChange(event, { value: nextItem.dataset.value || "" });
        }
        break;
      case "PageDown":
      case "PageUp":
        event.preventDefault();
        break;
    }
  };
  const contextValue = useMemo(
    () => ({
      disabled,
      id,
      select,
      isSelected,
      isFocused,
      highlight,
      isHighlighted
    }),
    [disabled, id, select, isSelected, isFocused, highlight, isHighlighted]
  );
  return {
    focusHandler,
    keyDownHandler,
    blurHandler,
    mouseOverHandler,
    activeDescendant,
    selectedItem,
    highlightedItem,
    setSelectedItem,
    setHighlightedItem,
    contextValue,
    focusVisibleRef
  };
};

export { useList };
//# sourceMappingURL=useList.js.map
