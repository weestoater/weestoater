import { jsx } from 'react/jsx-runtime';
import { useForkRef, useFloatingUI, useIsomorphicLayoutEffect } from '@salt-ds/core';
import { clsx } from 'clsx';
import { forwardRef, useState, useCallback, useEffect, useMemo } from 'react';
import { Portal } from '../portal/Portal.js';
import { List } from '../list-deprecated/List.js';
import '../list-deprecated/ListBase.js';
import '../list-deprecated/ListItemBase.js';
import '../list-deprecated/ListItem.js';
import '../list-deprecated/ListItemContext.js';
import '../list-deprecated/ListStateContext.js';
import { DefaultMenuItem } from './CascadingMenuItem.js';
import { CascadingMenuAction } from './internal/CascadingMenuAction.js';
import { getKeyDownHandlers } from './internal/keydownHandlers.js';
import { getMaxHeight, getHeight } from './internal/menuPositioning.js';
import { hasSubMenu, hasIcon } from './internal/stateUtils.js';
import { useMouseHandlers } from './internal/useMouseHandlers.js';
import { stateChangeTypes } from './stateChangeTypes.js';
import { useWindow as useWindow$1 } from '../window/WindowContext.js';
import '../window/ElectronWindow.js';
import { useComponentCssInjection } from '@salt-ds/styles';
import { useWindow } from '@salt-ds/window';
import css_248z from './CascadingMenuList.css.js';

const CascadingMenuList = forwardRef(function CascadingMenuList2(props, ref) {
  const {
    className,
    maxWidth,
    minWidth,
    itemToString,
    onItemClick,
    refsManager: refsManager2,
    dispatch,
    rowHeight: rowHeightProp,
    isNavigatingWithKeyboard,
    data,
    tooltipEnterDelay,
    tooltipLeaveDelay,
    height: heightProp,
    isChildMenuOpen,
    isRoot,
    highlightedItemIndex,
    menuId,
    parentElement = null,
    getScreenBounds,
    disableMouseOutInteractions,
    rootPlacementOffset,
    rootPlacement = "bottom-start"
  } = props;
  const targetWindow = useWindow();
  useComponentCssInjection({
    testId: "salt-cascading-menu-list",
    css: css_248z,
    window: targetWindow
  });
  const baseClass = "saltCascadingMenuList";
  const [menuRef, setInternalMenuRef] = useState(null);
  const setMenuRef = useCallback(
    (node) => {
      refsManager2.set(menuId, node);
    },
    [refsManager2, menuId]
  );
  const sizeStackable = 36;
  const defaultRowHeight = sizeStackable;
  const spacing = 8;
  const isMenuActiveState = useState(true);
  const [isMenuActive, setIsMenuActive] = isMenuActiveState;
  const listRef = useForkRef(ref, setInternalMenuRef);
  const handleRef = useForkRef(setMenuRef, listRef);
  useEffect(() => {
    if (menuRef && menuRef.focus) {
      const id = setTimeout(() => {
        menuRef.focus();
      });
      return () => {
        clearTimeout(id);
      };
    }
  }, [menuRef, rootPlacementOffset]);
  const handleKeyDown = getKeyDownHandlers(props, setIsMenuActive);
  const onFocusHandler = useCallback(() => {
    setIsMenuActive(true);
    if (isNavigatingWithKeyboard) {
      if (!highlightedItemIndex) {
        dispatch({
          type: CascadingMenuAction.SET_CURRENT_INTERACTED_ITEM,
          cause: stateChangeTypes.KEYBOARD_NAV_AUTO_FOCUS,
          targetId: menuId,
          highlightedItemIndex: 0
        });
      }
    }
  }, [
    setIsMenuActive,
    isNavigatingWithKeyboard,
    highlightedItemIndex,
    dispatch,
    menuId
  ]);
  const [handleMouseMove, handleMouseOut] = useMouseHandlers(
    props,
    isMenuActiveState,
    menuRef
  );
  const hasEndAdornment = useMemo(
    () => data.menuItems.some(hasSubMenu),
    [data]
  );
  const hasStartAdornment = useMemo(() => data.menuItems.some(hasIcon), [data]);
  const rowHeight = rowHeightProp != null ? rowHeightProp : defaultRowHeight;
  const maxHeight = getMaxHeight(heightProp, spacing, getScreenBounds);
  const calculatedMenuHeight = rowHeight * data.menuItems.length;
  const menuHeight = getHeight(heightProp, calculatedMenuHeight, maxHeight);
  const hasScrollbar = menuHeight >= maxHeight;
  const menuContainerHeight = menuHeight + 2;
  const Window = useWindow$1();
  const { reference, floating, x, y, strategy } = useFloatingUI({
    placement: isRoot ? rootPlacement : "right-start"
  });
  useIsomorphicLayoutEffect(() => {
    if (parentElement) {
      reference(
        isRoot ? parentElement : parentElement.querySelector(
          `#${parentElement.getAttribute("aria-activedescendant")}`
        )
      );
    }
  }, [reference, isRoot, parentElement]);
  if (parentElement === null) {
    return null;
  }
  return /* @__PURE__ */ jsx(Portal, {
    children: /* @__PURE__ */ jsx(Window, {
      className: `${baseClass}-popper`,
      id: menuId,
      style: {
        top: y != null ? y : 0,
        left: x != null ? x : 0,
        position: strategy
      },
      ref: floating,
      children: /* @__PURE__ */ jsx(List, {
        className: clsx(baseClass, className),
        height: menuContainerHeight,
        highlightedIndex: highlightedItemIndex === null ? -1 : highlightedItemIndex,
        id: menuId,
        itemHeight: rowHeight,
        itemToString,
        listRef: handleRef,
        maxWidth,
        minWidth,
        onFocus: onFocusHandler,
        onKeyDown: handleKeyDown,
        onMouseOut: disableMouseOutInteractions ? void 0 : handleMouseOut,
        role: "menu",
        width: "auto",
        children: data.menuItems.map((menuItem, idx) => {
          const isInteracted = highlightedItemIndex === idx;
          return /* @__PURE__ */ jsx(DefaultMenuItem, {
            blurSelected: !isMenuActive && isInteracted,
            hasEndAdornment,
            hasScrollbar,
            hasStartAdornment,
            hasSubMenu: hasSubMenu(menuItem),
            isChildMenuOpen,
            isInteracted,
            isNavigatingWithKeyboard,
            itemToString,
            onItemClick,
            onMouseMove: () => handleMouseMove(idx),
            sourceItem: menuItem,
            tooltipEnterDelay,
            tooltipLeaveDelay
          }, idx);
        })
      }, menuId)
    })
  });
});

export { CascadingMenuList };
//# sourceMappingURL=CascadingMenuList.js.map
