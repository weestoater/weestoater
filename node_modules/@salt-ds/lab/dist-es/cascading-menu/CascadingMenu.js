import { jsxs, Fragment } from 'react/jsx-runtime';
import { forwardRef, useRef, useCallback, useState, useMemo, useReducer, useEffect, isValidElement, createElement, cloneElement } from 'react';
import { useDensity, useControlled, usePrevious, ownerWindow, useForkRef } from '@salt-ds/core';
import { useEventCallback } from '../utils/useEventCallback.js';
import { CascadingMenuList } from './CascadingMenuList.js';
import { CascadingMenuAction } from './internal/CascadingMenuAction.js';
import { defaultGetScreenBounds } from './internal/menuPositioning.js';
import { deriveFlatStateFromTree } from './internal/stateUtils.js';
import { useClickAway } from './internal/useClickAway.js';
import { useMenuTriggerHandlers } from './internal/useMenuTriggerHandlers.js';
import { useRefsManager } from './internal/useRefsManager.js';
import { useStateReducer } from './internal/useStateReducer.js';
import { stateChangeTypes } from './stateChangeTypes.js';

const defaultItemToString = (item) => (item == null ? void 0 : item.title) || String(item);
const noop = () => void 0;
const CascadingMenu = forwardRef(
  function CascadingMenu2(props, ref) {
    const {
      children,
      className,
      initialSource: initialSourceProp,
      itemToString = defaultItemToString,
      onClose,
      onItemClick,
      onOpen,
      maxWidth = 544,
      minWidth = 200,
      delay = 300,
      rowHeight,
      tooltipEnterDelay = 1500,
      tooltipLeaveDelay = 0,
      height,
      rootPlacement,
      rootPlacementOffset,
      menuTriggerRef: anchorRefProp,
      open: openProp,
      getScreenBounds = defaultGetScreenBounds,
      disableMouseOutInteractions,
      disableClickAway,
      containingDocument = globalThis.document,
      source: sourceProp
    } = props;
    const density = useDensity();
    const refsManager = useRefsManager();
    const childrenRef = useRef(null);
    const getMenuTriggerRef = useCallback(
      () => anchorRefProp || childrenRef.current,
      [anchorRefProp]
    );
    const [menuSource] = useControlled({
      controlled: sourceProp,
      default: initialSourceProp,
      name: "CascadingMenu",
      state: "source"
    });
    const [isNavigatingWithKeyboard, setIsNavigatingWithKeyboard] = useState(false);
    const menusDataById = useMemo(
      () => menuSource ? deriveFlatStateFromTree(menuSource) : {},
      [menuSource]
    );
    const rootMenuId = useMemo(
      () => Object.keys(menusDataById).find((id) => menusDataById[id].level === 0),
      [menusDataById]
    );
    const stateReducer = useStateReducer(
      menusDataById,
      isNavigatingWithKeyboard
    );
    const [state, dispatch] = useReducer(stateReducer, []);
    const rootMenuState = state[0];
    const prevState = usePrevious(state, void 0, []);
    const prevRootMenuState = prevState == null ? void 0 : prevState[0];
    useEffect(() => {
      if (!!rootMenuState !== !!prevRootMenuState) {
        if (!rootMenuState) {
          onClose == null ? void 0 : onClose();
        } else if (rootMenuState) {
          onOpen == null ? void 0 : onOpen();
        }
      }
    });
    const openCloseMenu = useCallback(
      (open) => dispatch({
        type: open ? CascadingMenuAction.OPEN_MENU : CascadingMenuAction.CLOSE_CASCADING_MENU,
        cause: stateChangeTypes.MOUSE_TOGGLE,
        targetId: rootMenuId
      }),
      [rootMenuId]
    );
    useEffect(() => {
      if (openProp !== void 0 && openProp !== !!rootMenuState) {
        openCloseMenu(openProp);
      }
    });
    const clickAwayNodes = disableClickAway ? null : () => [getMenuTriggerRef(), ...refsManager.values()].filter(
      (node) => node !== null
    );
    useClickAway(
      clickAwayNodes,
      containingDocument,
      () => {
        dispatch({
          type: CascadingMenuAction.CLOSE_CASCADING_MENU,
          cause: stateChangeTypes.CLICKED_AWAY,
          targetId: rootMenuId
        });
      },
      () => {
        setIsNavigatingWithKeyboard(false);
      }
    );
    const handleResize = useEventCallback(() => {
      if (rootMenuState) {
        dispatch({
          type: CascadingMenuAction.CLOSE_CASCADING_MENU,
          cause: stateChangeTypes.ON_RESIZE,
          targetId: rootMenuId
        });
      }
    });
    useEffect(() => {
      const win = ownerWindow(getMenuTriggerRef());
      win.addEventListener("resize", handleResize);
      return () => {
        win.removeEventListener("resize", handleResize);
      };
    }, [getMenuTriggerRef, handleResize]);
    const onItemClickCallback = useCallback(
      (sourceItem, event) => {
        onItemClick == null ? void 0 : onItemClick(sourceItem, event);
        if (!isNavigatingWithKeyboard) {
          dispatch({
            type: CascadingMenuAction.CLOSE_CASCADING_MENU,
            cause: stateChangeTypes.ITEM_CLICKED,
            targetId: rootMenuId
          });
        }
      },
      [isNavigatingWithKeyboard, onItemClick, rootMenuId]
    );
    const setMenuTriggerRef = useCallback((node) => {
      childrenRef.current = node;
    }, []);
    const handleRef = useForkRef(
      isValidElement(children) ? children.ref : noop,
      setMenuTriggerRef
    );
    const [onMenuTriggerClick, onMenuTriggerKeydown] = useMenuTriggerHandlers({
      dispatch,
      children,
      setIsNavigatingWithKeyboard,
      openCloseMenu,
      rootMenuState,
      rootMenuId,
      menusDataById
    });
    const cloneMenuChildren = (cloneChildren) => {
      if (isValidElement(cloneChildren)) {
        const childrenProps = {
          ...cloneChildren.props
        };
        if (openProp === void 0) {
          childrenProps.onClick = onMenuTriggerClick;
          childrenProps.onKeyDown = onMenuTriggerKeydown;
        }
        return cloneElement(cloneChildren, {
          ref: handleRef,
          ...childrenProps
        });
      }
      return null;
    };
    const clonedChildren = cloneMenuChildren(children);
    const commonMenuProps = {
      className,
      delay,
      itemToString,
      maxWidth,
      minWidth,
      onItemClick: onItemClickCallback,
      dispatch,
      isNavigatingWithKeyboard,
      setIsNavigatingWithKeyboard,
      menusDataById,
      tooltipEnterDelay,
      tooltipLeaveDelay,
      rootPlacement,
      rootPlacementOffset,
      getScreenBounds,
      disableMouseOutInteractions
    };
    useEffect(() => {
      if (!openProp) {
        setIsNavigatingWithKeyboard(false);
      }
    }, [openProp, rootPlacementOffset]);
    return Object.keys(menusDataById).length > 0 ? /* @__PURE__ */ jsxs(Fragment, {
      children: [
        clonedChildren || null,
        Object.values(state).map((menuState) => {
          const data = menusDataById[menuState.id];
          const isRoot = data.level === 0;
          const parentElement = isRoot ? getMenuTriggerRef() : refsManager.get(data.parentId);
          const isChildMenuOpen = !!state[data.level + 1];
          return /* @__PURE__ */ createElement(CascadingMenuList, {
            ...commonMenuProps,
            data,
            height,
            highlightedItemIndex: menuState.highlightedItemIndex,
            isChildMenuOpen,
            isRoot,
            key: `${density}${menuState.id}`,
            menuId: menuState.id,
            menuTriggerRef: getMenuTriggerRef(),
            parentElement,
            ref: isRoot ? ref : null,
            refsManager,
            rowHeight
          });
        })
      ]
    }) : null;
  }
);

export { CascadingMenu };
//# sourceMappingURL=CascadingMenu.js.map
