import { useRef, useEffect, useCallback } from 'react';
import { CascadingMenuAction } from './CascadingMenuAction.js';
import { stateChangeTypes } from '../stateChangeTypes.js';

function isOrContainsNode(parent, child) {
  var _a;
  return parent === child || !!((_a = parent == null ? void 0 : parent.contains) == null ? void 0 : _a.call(parent, child));
}
function useMouseHandlers(props, isMenuActiveState, menuRef) {
  const [isMenuActive, setIsMenuActive] = isMenuActiveState;
  const {
    delay,
    refsManager,
    dispatch,
    isNavigatingWithKeyboard,
    setIsNavigatingWithKeyboard,
    data,
    highlightedItemIndex,
    menuId,
    parentElement
  } = props;
  const scheduledHighlightedIndexChange = useRef(null);
  const mouseEnterTimer = useRef();
  const mouseOutTimer = useRef();
  useEffect(
    () => function cleanUpTimeouts() {
      clearTimeout(mouseEnterTimer.current);
      clearTimeout(mouseOutTimer.current);
    },
    []
  );
  const handleMouseMove = useCallback(
    (highlightedIndex) => {
      if (isNavigatingWithKeyboard) {
        setIsNavigatingWithKeyboard(false);
      }
      if (!isMenuActive) {
        setIsMenuActive(true);
      }
      if (scheduledHighlightedIndexChange.current !== highlightedIndex) {
        scheduledHighlightedIndexChange.current = highlightedIndex;
        clearTimeout(mouseEnterTimer.current);
        clearTimeout(mouseOutTimer.current);
        mouseEnterTimer.current = window.setTimeout(() => {
          dispatch({
            type: CascadingMenuAction.SET_CURRENT_INTERACTED_ITEM,
            cause: stateChangeTypes.ITEM_MOUSE_ENTER,
            targetId: menuId,
            highlightedItemIndex: highlightedIndex
          });
        }, delay);
      }
    },
    [
      isNavigatingWithKeyboard,
      isMenuActive,
      setIsNavigatingWithKeyboard,
      setIsMenuActive,
      delay,
      dispatch,
      menuId
    ]
  );
  const handleMouseOut = useCallback(
    (event) => {
      var _a;
      if (isNavigatingWithKeyboard) {
        setIsNavigatingWithKeyboard(false);
      }
      clearTimeout(mouseOutTimer.current);
      const { relatedTarget } = event;
      const subMenuElement = typeof highlightedItemIndex === "number" ? (_a = refsManager.get(data.childMenus[highlightedItemIndex])) != null ? _a : null : null;
      const mouseMovedToSameMenu = isOrContainsNode(
        menuRef,
        relatedTarget
      );
      const mouseMovedToParentMenu = isOrContainsNode(
        parentElement != null ? parentElement : null,
        relatedTarget
      );
      if (mouseMovedToParentMenu) {
        dispatch({
          type: CascadingMenuAction.SET_CURRENT_INTERACTED_ITEM,
          cause: stateChangeTypes.ITEM_MOUSE_MOVE_TO_PARENT,
          targetId: menuId,
          highlightedItemIndex: null
        });
      }
      const didMouseMoveOutOfMenu = !(mouseMovedToParentMenu || mouseMovedToSameMenu || isOrContainsNode(subMenuElement, relatedTarget));
      if (didMouseMoveOutOfMenu) {
        scheduledHighlightedIndexChange.current = null;
        if (!isMenuActive) {
          setIsMenuActive(true);
          clearInterval(mouseEnterTimer.current);
          mouseOutTimer.current = window.setTimeout(() => {
            dispatch({
              type: CascadingMenuAction.RESET_MENU,
              cause: stateChangeTypes.MOUSE_OUT_OF_MENUS,
              targetId: menuId
            });
          }, delay);
        }
      } else if (!mouseMovedToSameMenu) {
        setIsMenuActive(false);
      }
    },
    [
      isNavigatingWithKeyboard,
      refsManager,
      data.childMenus,
      highlightedItemIndex,
      menuRef,
      parentElement,
      setIsNavigatingWithKeyboard,
      dispatch,
      menuId,
      isMenuActive,
      delay,
      setIsMenuActive
    ]
  );
  return [handleMouseMove, handleMouseOut];
}

export { useMouseHandlers };
//# sourceMappingURL=useMouseHandlers.js.map
