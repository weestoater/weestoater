import { jsx } from 'react/jsx-runtime';
import { forwardRef, Children, useMemo } from 'react';
import { clsx } from 'clsx';
import { ButtonBarContext } from './internal/ButtonBarContext.js';
import { DescendantProvider } from './internal/DescendantContext.js';
import { useDescendants } from './internal/useDescendants.js';
import { makePrefixer } from '@salt-ds/core';
import { useWindow } from '@salt-ds/window';
import { useComponentCssInjection } from '@salt-ds/styles';
import css_248z from './ButtonBar.css.js';

const DefaultButtonsOrderByVariant = {
  cta: {
    order: 0,
    alignLeftOrder: 1,
    stackOrder: 2
  },
  primary: {
    order: 1,
    alignLeftOrder: 2,
    stackOrder: 1
  },
  secondary: {
    order: 2,
    alignLeftOrder: 0,
    stackOrder: 0
  }
};
function getPriorityForButton(item, field) {
  var _a;
  const variant = (item == null ? void 0 : item.variant) || "primary";
  return (_a = item == null ? void 0 : item[field]) != null ? _a : DefaultButtonsOrderByVariant[variant][field];
}
const createComparatorForField = (field, sort, alignLeft, childrenData) => {
  let equalityResult;
  if (field === "order" || field === "stackOrder") {
    equalityResult = sort === "asc" ? 1 : 0;
  } else {
    equalityResult = alignLeft ? 1 : -1;
  }
  function createDescComparator(indexA, indexB) {
    const priorityA = getPriorityForButton(childrenData[indexA], field);
    const priorityB = getPriorityForButton(childrenData[indexB], field);
    if (priorityA == null && priorityB == null) {
      return 0;
    }
    if (priorityA == null) {
      return 1;
    }
    if (priorityB == null) {
      return -1;
    }
    if (priorityA === priorityB) {
      return equalityResult;
    }
    return priorityB - priorityA;
  }
  function createAscComparator(indexA, indexB) {
    return createDescComparator(indexA, indexB) * -1;
  }
  return sort === "asc" ? createAscComparator : createDescComparator;
};
function alignSecondaryChild(orderedChildrenData, sortOrder, alignLeft) {
  const noSecondaryChildren = { index: void 0, align: void 0 };
  if (sortOrder === "asc" || alignLeft) {
    const firstSecondaryChildIndex = orderedChildrenData.findIndex(
      (childData) => childData.variant === "secondary"
    );
    if (firstSecondaryChildIndex !== -1) {
      const originalChildIndex = orderedChildrenData[firstSecondaryChildIndex].index;
      return { index: originalChildIndex, align: "right" };
    } else {
      return noSecondaryChildren;
    }
  } else {
    let index = orderedChildrenData.length;
    while (index--) {
      if (orderedChildrenData[index].variant === "secondary") {
        return { index: orderedChildrenData[index].index, align: "left" };
      }
    }
    return noSecondaryChildren;
  }
}
const withBaseName = makePrefixer("saltButtonBar");
const ButtonBar = forwardRef(
  function ButtonBar2({
    alignLeft = false,
    children: childrenProp,
    className,
    disableAutoAlignment,
    sortAlignLeft = "desc",
    sortOrder = "desc",
    sortStackOrder = "desc",
    stackAtBreakpoint = "xs",
    ...rest
  }, ref) {
    const targetWindow = useWindow();
    useComponentCssInjection({
      testId: "salt-button-bar",
      css: css_248z,
      window: targetWindow
    });
    const [childrenData, setChildrenData] = useDescendants();
    const matches = false;
    const childrenArray = Children.toArray(childrenProp);
    const childrenIndexes = childrenArray.map((_, index) => index);
    createComparatorForField(
      "stackOrder",
      sortStackOrder,
      alignLeft,
      childrenData
    );
    const orderComparator = createComparatorForField(
      "order",
      sortOrder,
      alignLeft,
      childrenData
    );
    const alignLeftComparator = createComparatorForField(
      "alignLeftOrder",
      sortAlignLeft,
      alignLeft,
      childrenData
    );
    let orderedChildrenIndexes;
    if (childrenData.length !== childrenIndexes.length) {
      orderedChildrenIndexes = childrenIndexes;
    } else {
      orderedChildrenIndexes = childrenIndexes.sort(
        alignLeft ? alignLeftComparator : orderComparator
      );
    }
    let secondaryChildAlignment = {
      index: void 0,
      align: void 0
    };
    if (!disableAutoAlignment) {
      secondaryChildAlignment = alignSecondaryChild(
        orderedChildrenIndexes.map((index) => ({
          index,
          ...childrenData[index]
        })),
        sortOrder,
        alignLeft
      );
    }
    const hasSecondaryButtons = childrenData.some(
      (buttonData) => buttonData.variant === "secondary"
    );
    const orderedChildren = orderedChildrenIndexes.map(
      (index) => childrenArray[index]
    );
    const buttonBarContextValue = useMemo(
      () => ({
        matches,
        alignedIndex: secondaryChildAlignment.index,
        align: secondaryChildAlignment.align
      }),
      [matches, secondaryChildAlignment.align, secondaryChildAlignment.index]
    );
    return /* @__PURE__ */ jsx(ButtonBarContext.Provider, {
      value: buttonBarContextValue,
      children: /* @__PURE__ */ jsx(DescendantProvider, {
        items: childrenData,
        setItems: setChildrenData,
        children: /* @__PURE__ */ jsx("div", {
          "aria-label": "button bar",
          className: clsx(
            withBaseName(),
            {
              [withBaseName("stacked")]: matches,
              [withBaseName("alignLeft")]: alignLeft,
              [withBaseName("autoAligning")]: hasSecondaryButtons && !disableAutoAlignment
            },
            className
          ),
          ref,
          role: "region",
          ...rest,
          children: orderedChildren
        })
      })
    });
  }
);

export { ButtonBar, DefaultButtonsOrderByVariant };
//# sourceMappingURL=ButtonBar.js.map
