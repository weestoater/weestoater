import { jsxs, jsx } from 'react/jsx-runtime';
import { makePrefixer, useForkRef, Button } from '@salt-ds/core';
import { CloseIcon } from '@salt-ds/icons';
import { useComponentCssInjection } from '@salt-ds/styles';
import { useWindow } from '@salt-ds/window';
import { clsx } from 'clsx';
import { forwardRef, useRef, useState, useCallback } from 'react';
import { EditableLabel } from '../editable-label/EditableLabel.js';
import css_248z from './Tab.css.js';

const noop = () => void 0;
const withBaseName = makePrefixer("saltTab");
const CloseTabButton = (props) => /* @__PURE__ */ jsx(Button, {
  ...props,
  "aria-label": "Close Tab (Delete or Backspace)",
  className: withBaseName("closeButton"),
  tabIndex: void 0,
  title: "Close Tab (Delete or Backspace)",
  variant: "secondary",
  children: /* @__PURE__ */ jsx(CloseIcon, {
    "aria-label": "Close Tab (Delete or Backspace)",
    className: withBaseName("close-icon")
  })
});
const Tab = forwardRef(function Tab2({
  ariaControls,
  children,
  className,
  closeable,
  dragging,
  editable,
  editing,
  focusVisible,
  index,
  label,
  onClick,
  onClose,
  onEnterEditMode = noop,
  onExitEditMode = noop,
  onFocus: onFocusProp,
  onKeyDown,
  onKeyUp,
  onMouseDown,
  orientation,
  selected,
  tabChildIndex = 0,
  tabIndex,
  ...props
}, ref) {
  if (index === void 0 || onClick === void 0 || onKeyDown === void 0) {
    throw Error(
      "index, onClick, onKeyUp, onKeyDown are required props, they would nornally be injected by Tabstrip, are you creating a Tab outside of a Tabstrip"
    );
  }
  const targetWindow = useWindow();
  useComponentCssInjection({
    testId: "salt-tab",
    css: css_248z,
    window: targetWindow
  });
  const root = useRef(null);
  const editableRef = useRef(null);
  const setForkRef = useForkRef(ref, root);
  const [closeHover, setCloseHover] = useState(false);
  const handleClick = useCallback(
    (e) => {
      if (!editing) {
        e.preventDefault();
        onClick(e, index);
      }
    },
    [editing, index, onClick]
  );
  const handleKeyDownMain = (e) => {
    onKeyDown(e);
  };
  const handleOnExitEditMode = (originalValue = "", editedValue = "", allowDeactivation = true) => onExitEditMode(originalValue, editedValue, allowDeactivation, index);
  const handleKeyUp = (e) => {
    switch (e.key) {
      case "Backspace":
      case "Delete":
        if (closeable && !editing) {
          e.stopPropagation();
          onClose && onClose(index);
        }
        break;
      default:
        onKeyUp && onKeyUp(e, index);
    }
  };
  const handleCloseButtonClick = (e) => {
    e.stopPropagation();
    onClose && onClose(index);
  };
  const handleCloseButtonEnter = () => {
    setCloseHover(true);
  };
  const handleCloseButtonLeave = () => {
    setCloseHover(false);
  };
  const handleMouseDown = (e) => {
    onMouseDown == null ? void 0 : onMouseDown(e);
  };
  const getLabel = () => {
    if (editable) {
      return /* @__PURE__ */ jsx(EditableLabel, {
        editing,
        defaultValue: label,
        onEnterEditMode,
        onExitEditMode: handleOnExitEditMode,
        ref: editableRef
      }, label);
    } else {
      return label;
    }
  };
  const handleFocus = (evt) => {
    if (editableRef.current) {
      const editable2 = editableRef.current;
      const input = editable2.querySelector(
        ".saltEditableLabel-input"
      );
      input == null ? void 0 : input.focus();
    }
    onFocusProp == null ? void 0 : onFocusProp(evt);
  };
  return /* @__PURE__ */ jsxs("div", {
    ...props,
    "aria-controls": ariaControls,
    "aria-selected": selected,
    className: clsx(withBaseName(), {
      [withBaseName("closeable")]: closeable,
      [withBaseName("closeHover")]: closeHover,
      [withBaseName("dragAway")]: dragging,
      [withBaseName("editing")]: editing,
      [withBaseName("vertical")]: orientation === "vertical",
      [`saltFocusVisible`]: focusVisible
    }),
    "data-editable": editable || void 0,
    onClick: handleClick,
    onFocus: handleFocus,
    onKeyDown: handleKeyDownMain,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    ref: setForkRef,
    role: "tab",
    tabIndex,
    children: [
      /* @__PURE__ */ jsx("div", {
        className: withBaseName("main"),
        children: /* @__PURE__ */ jsx("span", {
          className: withBaseName("text"),
          "data-text": editable ? void 0 : label,
          children: children != null ? children : getLabel()
        })
      }),
      closeable ? /* @__PURE__ */ jsx(CloseTabButton, {
        onClick: handleCloseButtonClick,
        onMouseEnter: handleCloseButtonEnter,
        onMouseLeave: handleCloseButtonLeave
      }) : null
    ]
  });
});

export { Tab };
//# sourceMappingURL=Tab.js.map
