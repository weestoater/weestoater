import { useControlled, useIsomorphicLayoutEffect } from '@salt-ds/core';
import { useRef, useState, useCallback } from 'react';
import '../common-hooks/collectionProvider.js';
import { Home, End, ArrowLeft, ArrowRight, ArrowUp, ArrowDown } from '../common-hooks/keyUtils.js';
import 'react/jsx-runtime';
import '../responsive/useResizeObserver.js';

const navigation = {
  horizontal: {
    [Home]: "start",
    [End]: "end",
    [ArrowLeft]: "bwd",
    [ArrowRight]: "fwd"
  },
  vertical: {
    [Home]: "start",
    [End]: "end",
    [ArrowUp]: "bwd",
    [ArrowDown]: "fwd"
  }
};
const isNavigationKey = (key, orientation = "horizontal") => navigation[orientation][key] !== void 0;
function nextItemIdx(count, direction, idx) {
  if (direction === "start") {
    return 0;
  } else if (direction === "end") {
    return count - 1;
  } else if (direction === "bwd") {
    if (idx > 0) {
      return idx - 1;
    } else {
      return idx;
    }
  } else {
    if (idx === null) {
      return 0;
    } else if (idx === count - 1) {
      return idx;
    } else {
      return idx + 1;
    }
  }
}
const isFocusable = (item) => !item.overflowed;
const getFocusableElement = (el) => el ? el.hasAttribute("tabindex") ? el : el.querySelector("[tabindex]") : null;
const useKeyboardNavigation = ({
  defaultHighlightedIdx = -1,
  highlightedIdx: highlightedIdxProp,
  indexPositions,
  keyBoardActivation,
  orientation,
  selectedIndex: selectedTabIndex = 0
}) => {
  const manualActivation = keyBoardActivation === "manual";
  const mouseClickPending = useRef(false);
  const focusedRef = useRef(-1);
  const [hasFocus, setHasFocus] = useState(false);
  const [, forceRefresh] = useState({});
  const [highlightedIdx, _setHighlightedIdx] = useControlled({
    controlled: highlightedIdxProp,
    default: defaultHighlightedIdx,
    name: "UseKeyboardNavigation"
  });
  const setHighlightedIdx = useCallback(
    (value) => {
      _setHighlightedIdx(focusedRef.current = value);
    },
    [_setHighlightedIdx]
  );
  const keyboardNavigation = useRef(false);
  const focusTab = useCallback(
    (tabIndex, immediateFocus = false, withKeyboard) => {
      setHighlightedIdx(tabIndex);
      if (withKeyboard === true && !keyboardNavigation.current) {
        keyboardNavigation.current = true;
      }
      const setFocus = () => {
        const item = indexPositions.find((i) => i.index === tabIndex);
        if (item) {
          const focussableElement = getFocusableElement(
            document.getElementById(item.id)
          );
          focussableElement == null ? void 0 : focussableElement.focus();
        }
      };
      if (immediateFocus) {
        setFocus();
      } else {
        setTimeout(setFocus, 70);
      }
    },
    [indexPositions, setHighlightedIdx]
  );
  const onFocus = (e) => {
    if (focusedRef.current === -1) {
      if (e.target.tabIndex === -1) ; else {
        setTimeout(() => {
          if (focusedRef.current === -1 && selectedTabIndex !== null) {
            setHighlightedIdx(selectedTabIndex);
          }
        }, 200);
      }
    }
  };
  const nextFocusableItemIdx = useCallback(
    (direction = "fwd", idx = direction === "fwd" ? -1 : indexPositions.length) => {
      let nextIdx = nextItemIdx(indexPositions.length, direction, idx);
      const nextDirection = direction === "start" ? "fwd" : direction === "end" ? "bwd" : direction;
      while ((nextDirection === "fwd" && nextIdx < indexPositions.length || nextDirection === "bwd" && nextIdx > 0) && !isFocusable(indexPositions[nextIdx])) {
        const newIdx = nextItemIdx(
          indexPositions.length,
          nextDirection,
          nextIdx
        );
        if (newIdx === nextIdx) {
          break;
        } else {
          nextIdx = newIdx;
        }
      }
      return nextIdx;
    },
    [indexPositions]
  );
  const navigateChildItems = useCallback(
    (e, forceFocusVisible = false) => {
      const direction = navigation[orientation][e.key];
      const nextIdx = nextFocusableItemIdx(direction, highlightedIdx);
      if (nextIdx !== highlightedIdx) {
        const immediateFocus = true;
        if (manualActivation) {
          focusTab(nextIdx, immediateFocus);
        }
      } else if (forceFocusVisible) {
        forceRefresh({});
      }
    },
    [
      highlightedIdx,
      manualActivation,
      nextFocusableItemIdx,
      focusTab,
      orientation
    ]
  );
  const handleKeyDown = useCallback(
    (e) => {
      if (indexPositions.length > 0 && isNavigationKey(e.key, orientation)) {
        e.preventDefault();
        if (keyboardNavigation.current) {
          navigateChildItems(e);
        } else {
          keyboardNavigation.current = true;
          navigateChildItems(e, true);
        }
      }
    },
    [indexPositions, navigateChildItems, orientation]
  );
  const handleItemClick = (_, tabIndex) => {
    setHighlightedIdx(tabIndex);
  };
  const handleFocus = useCallback(
    (evt) => {
      if (!hasFocus) {
        setHasFocus(true);
        if (!mouseClickPending.current) {
          keyboardNavigation.current = true;
        } else {
          mouseClickPending.current = false;
        }
      }
    },
    [hasFocus]
  );
  const handleContainerMouseDown = useCallback(
    (evt) => {
      if (!hasFocus) {
        mouseClickPending.current = true;
      }
      keyboardNavigation.current = false;
    },
    [hasFocus]
  );
  const containerProps = {
    onBlur: (e) => {
      const sourceTarget = e.target.closest(".saltTabstrip");
      const destTarget = e.relatedTarget;
      if (sourceTarget && !(sourceTarget == null ? void 0 : sourceTarget.contains(destTarget))) {
        setHighlightedIdx(-1);
        setHasFocus(false);
      }
    },
    onMouseDownCapture: handleContainerMouseDown,
    onFocus: handleFocus,
    onMouseLeave: () => {
      keyboardNavigation.current = true;
      setHighlightedIdx(-1);
      mouseClickPending.current = false;
    }
  };
  useIsomorphicLayoutEffect(() => {
    if (hasFocus && selectedTabIndex !== void 0 && selectedTabIndex !== null) {
      focusTab(selectedTabIndex);
    }
  }, [focusTab, hasFocus, selectedTabIndex]);
  return {
    containerProps,
    focusVisible: keyboardNavigation.current ? highlightedIdx : -1,
    focusIsWithinComponent: hasFocus,
    highlightedIdx,
    focusTab,
    onClick: handleItemClick,
    onFocus,
    onKeyDown: handleKeyDown
  };
};

export { useKeyboardNavigation };
//# sourceMappingURL=useKeyboardNavigation.js.map
