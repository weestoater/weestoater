import { jsxs, jsx } from 'react/jsx-runtime';
import React, { forwardRef, useRef, useState, useCallback, useImperativeHandle, createElement } from 'react';
import { makePrefixer, useIdMemo, useIsomorphicLayoutEffect, Tooltip, Button } from '@salt-ds/core';
import { OverflowMenuIcon, AddIcon } from '@salt-ds/icons';
import { clsx } from 'clsx';
import '../dropdown/DropdownBase.js';
import '../dropdown/DropdownButton.js';
import { Dropdown } from '../dropdown/Dropdown.js';
import '../responsive/useResizeObserver.js';
import { useOverflowCollectionItems } from '../responsive/useOverflowCollectionItems.js';
import { useOverflowLayout } from '../responsive/useOverflowLayout.js';
import '../form-field-context-legacy/FormFieldLegacyContext.js';
import { Tab } from './Tab.js';
import { TabActivationIndicator } from './TabActivationIndicator.js';
import { useTabstrip } from './useTabstrip.js';
import { useWindow } from '@salt-ds/window';
import { useComponentCssInjection } from '@salt-ds/styles';
import css_248z$1 from './ThemeTabstrip.css.js';
import css_248z from './Tabstrip.css.js';

const withBaseName = makePrefixer("saltTabstrip");
const ADD_TAB_LABEL = "Create Tab";
const tabDescriptors = (tabs) => tabs && tabs.map(
  (tab) => typeof tab === "string" ? { label: tab } : tab
);
const Tabstrip = forwardRef(function Tabstrip2({
  activeTabIndex: activeTabIndexProp,
  allowDragDrop = false,
  centered = false,
  children,
  className: classNameProp,
  defaultSource,
  defaultActiveTabIndex,
  editing,
  variant,
  enableAddTab = false,
  enableCloseTab,
  enableRenameTab,
  id: idProp,
  keyBoardActivation = "manual",
  onAddTab,
  onActiveChange,
  onCloseTab,
  onEnterEditMode,
  onExitEditMode,
  onMouseDown,
  onMoveTab,
  orientation = "horizontal",
  overflowMenu: overflowMenuProp = true,
  promptForNewTabName = true,
  showActivationIndicator = true,
  source,
  title,
  ...htmlAttributes
}, forwardedRef) {
  var _a;
  const targetWindow = useWindow();
  useComponentCssInjection({
    testId: "salt-tab-strip",
    css: css_248z,
    window: targetWindow
  });
  useComponentCssInjection({
    testId: "salt-theme-tab-strip",
    css: css_248z$1,
    window: targetWindow
  });
  const root = useRef(null);
  const activeRef = useRef(
    activeTabIndexProp || defaultActiveTabIndex || 0
  );
  const overflowItemsRef = useRef([]);
  const [showOverflowMenu, _setShowOverflowMenu] = useState(false);
  const setShowOverflowMenu = useCallback((value) => {
    _setShowOverflowMenu(value);
  }, []);
  const tabstripId = useIdMemo(idProp);
  const injectedItems = enableAddTab ? [
    {
      source: { label: "Add Tab", position: -1, priority: 1 }
    }
  ] : void 0;
  const collectionHook = useOverflowCollectionItems({
    children,
    defaultSource: tabDescriptors(defaultSource),
    id: tabstripId,
    injectedItems,
    label: "Tabstrip",
    orientation,
    source: tabDescriptors(source),
    options: {
      closeable: enableCloseTab,
      editable: enableRenameTab,
      getPriority: (item, index) => {
        return index === activeRef.current ? 1 : void 0;
      }
    }
  });
  const childCount = useRef(React.Children.count(children));
  const getChildren = () => {
    if (React.Children.count(children) === 0) {
      return void 0;
    } else {
      return React.Children.toArray(children);
    }
  };
  const [innerContainerRef, switchOverflowPriorities] = useOverflowLayout({
    collectionHook,
    disableOverflow: overflowMenuProp === false,
    id: tabstripId,
    orientation,
    label: "Tabstrip"
  });
  overflowItemsRef.current = collectionHook.data;
  const overflowedItems = collectionHook.data.filter((item) => item.overflowed);
  const tabMovedHandler = useCallback(
    (fromIndex, toIndex) => {
      onMoveTab == null ? void 0 : onMoveTab(fromIndex, toIndex);
      setTimeout(() => {
        collectionHook.dispatch({
          type: "reset"
        });
      }, 50);
    },
    [collectionHook, onMoveTab]
  );
  const handleTabSelectionChange = useCallback(
    (tabIndex) => {
      const selectedItem = collectionHook.data[tabIndex];
      const prevSelectedItem = collectionHook.data.find(
        (item) => item.priority === 1 && !item.isOverflowIndicator
      );
      if (selectedItem && prevSelectedItem && overflowMenuProp) {
        switchOverflowPriorities(selectedItem, prevSelectedItem);
      }
      onActiveChange == null ? void 0 : onActiveChange(tabIndex);
      setShowOverflowMenu(false);
    },
    [
      collectionHook.data,
      onActiveChange,
      overflowMenuProp,
      setShowOverflowMenu,
      switchOverflowPriorities
    ]
  );
  const {
    activeTabIndex,
    activateTab,
    addTab,
    onMouseDown: tabstripHookMouseDown,
    ...tabstripHook
  } = useTabstrip({
    activeTabIndex: activeTabIndexProp,
    allowDragDrop,
    collectionHook,
    defaultTabs: tabDescriptors(defaultSource),
    defaultActiveTabIndex,
    editing,
    enableAddTab,
    idRoot: tabstripId,
    innerContainerRef,
    keyBoardActivation,
    onActiveChange: handleTabSelectionChange,
    onCloseTab,
    onEnterEditMode,
    onExitEditMode,
    onMoveTab: tabMovedHandler,
    orientation,
    promptForNewTabName,
    tabs: (_a = tabDescriptors(source)) != null ? _a : getChildren()
  });
  activeRef.current = activeTabIndex;
  useImperativeHandle(
    forwardedRef,
    () => ({
      focus: () => {
        const { current: tabstrip } = root;
        if (tabstrip) {
          const selectedTab = tabstrip.querySelector(
            '.saltTab[aria-selected="true"]'
          );
          if (selectedTab) {
            selectedTab.focus();
          }
        }
      }
    }),
    []
  );
  const handleAddTabClick = useCallback(() => {
    if (!collectionHook.isControlled) {
      addTab();
    }
    onAddTab == null ? void 0 : onAddTab();
  }, [collectionHook.isControlled, onAddTab, addTab]);
  const selectedIndex = useRef(activeTabIndex);
  const focusedTabIndex = tabstripHook.highlightedIdx;
  const handleOverflowSelectionChange = useCallback(
    (e, tab) => {
      if (tab !== null) {
        activateTab(tab.index);
      }
    },
    [activateTab]
  );
  const handleKeydownOverflowMenu = useCallback(
    (e) => {
      var _a2, _b;
      (_b = (_a2 = tabstripHook.navigationProps) == null ? void 0 : _a2.onKeyDown) == null ? void 0 : _b.call(_a2, e);
    },
    [tabstripHook.navigationProps]
  );
  const handleOverflowMenuOpen = useCallback(
    (open) => {
      setShowOverflowMenu(open);
    },
    [setShowOverflowMenu]
  );
  const handleMouseDown = useCallback(
    (evt) => {
      onMouseDown == null ? void 0 : onMouseDown(evt);
      tabstripHookMouseDown == null ? void 0 : tabstripHookMouseDown(evt);
    },
    [onMouseDown, tabstripHookMouseDown]
  );
  useIsomorphicLayoutEffect(() => {
    if (selectedIndex.current !== activeTabIndex && overflowMenuProp) {
      selectedIndex.current = activeTabIndex;
    }
  }, [overflowMenuProp, activeTabIndex]);
  useIsomorphicLayoutEffect(() => {
    if (React.Children.count(children) !== childCount.current) {
      childCount.current = React.Children.count(children);
    }
  }, [children]);
  useIsomorphicLayoutEffect(() => {
    if (activeTabIndex !== null && focusedTabIndex !== activeTabIndex && focusedTabIndex !== -1) {
      tabstripHook.focusTab(activeTabIndex);
    }
  }, [activeTabIndex]);
  const renderContent = () => {
    const content = collectionHook.data.filter((item) => !item.isOverflowIndicator && !item.isInjectedItem).map((item, index) => {
      const tab = item.source;
      const element = item.element;
      const selected = index === activeTabIndex;
      const focusVisible = tabstripHook.focusVisible === index;
      const overflowed = overflowedItems.findIndex(
        (item2) => item2.index === index
      ) !== -1;
      const tabIsBeingEdited = tabstripHook.editing && selected;
      const tabIndex = tabIsBeingEdited ? void 0 : selected && !tabstripHook.focusIsWithinComponent ? 0 : -1;
      const baseProps = {
        "data-index": index,
        "data-priority": item.priority,
        "data-overflowed": overflowed ? true : void 0,
        ...tabstripHook.navigationProps,
        id: item.id,
        key: index,
        onMouseDown: handleMouseDown,
        tabIndex
      };
      const tabProps = {
        ...tabstripHook.tabProps,
        closeable: item.closeable,
        dragging: tabstripHook.draggedItemIndex === index,
        editable: item.editable,
        editing: tabIsBeingEdited,
        focusVisible,
        index,
        onClose: item.closeable ? tabstripHook.closeTab : void 0,
        orientation,
        selected
      };
      if (React.isValidElement(element)) {
        if (element.type === Tab) {
          return React.cloneElement(element, { ...baseProps, ...tabProps });
        } else {
          return React.cloneElement(element, baseProps);
        }
      } else {
        return React.createElement(Tab, {
          ...baseProps,
          ...tabProps,
          label: tab.label
        });
      }
    });
    const overflowCount = overflowedItems.length;
    const draggingActiveTab = tabstripHook.draggedItemIndex === activeTabIndex;
    const showOverflow = tabstripHook.revealOverflowedItems && !draggingActiveTab || showOverflowMenu;
    const showTooltip = tabstripHook.revealOverflowedItems && draggingActiveTab;
    const overflowIndicator = collectionHook.data.find(
      (i) => i.isOverflowIndicator
    );
    const [injectedItem] = collectionHook.data.filter((i) => i.isInjectedItem);
    if (overflowIndicator) {
      content.push(
        /* @__PURE__ */ jsx(Tooltip, {
          content: "Active Tab cannot be moved into overflow list",
          open: true,
          disabled: !showTooltip,
          status: "warning",
          hideArrow: true,
          children: /* @__PURE__ */ jsx(Dropdown, {
            className: clsx(withBaseName("overflowMenu"), {
              [withBaseName("overflowMenu-open")]: showOverflow
            }),
            ListProps: {
              className: clsx({
                [withBaseName("overflowMenu-dropTarget")]: tabstripHook.revealOverflowedItems
              })
            },
            "data-overflow-indicator": true,
            "data-priority": 0,
            id: overflowIndicator.id,
            isOpen: showOverflow,
            onOpenChange: handleOverflowMenuOpen,
            onKeyDown: handleKeydownOverflowMenu,
            onSelectionChange: handleOverflowSelectionChange,
            placement: "bottom-end",
            source: overflowedItems,
            selected: null,
            triggerComponent: /* @__PURE__ */ jsx(Button, {
              "aria-label": `Tabs overflow menu ${overflowCount} item${overflowCount === 1 ? "" : "s"}`,
              variant: "secondary",
              tabIndex: -1,
              children: /* @__PURE__ */ jsx(OverflowMenuIcon, {})
            }),
            width: "auto"
          }, "overflow")
        }, "tooltip")
      );
    }
    if (injectedItem) {
      content.push(
        /* @__PURE__ */ createElement(Button, {
          ...tabstripHook.navigationProps,
          "aria-label": ADD_TAB_LABEL,
          "data-priority": injectedItem.priority,
          "data-overflowed": injectedItem.overflowed,
          id: injectedItem.id,
          key: "addButton",
          onClick: handleAddTabClick,
          variant: "secondary",
          tabIndex: -1
        }, /* @__PURE__ */ jsx(AddIcon, {}))
      );
    }
    return content;
  };
  const selectedTabOverflowed = overflowedItems.some(
    (item) => item.index === activeTabIndex
  );
  const className = clsx(
    withBaseName(),
    withBaseName(orientation),
    classNameProp,
    {
      [withBaseName("centered")]: centered,
      [withBaseName("draggingTab")]: tabstripHook.isDragging,
      [withBaseName("tertiary")]: variant === "tertiary"
    }
  );
  const selectedTabId = activeTabIndex !== null ? collectionHook.data[activeTabIndex].id : null;
  return /* @__PURE__ */ jsxs("div", {
    ...htmlAttributes,
    ...tabstripHook.containerProps,
    className,
    id: tabstripId,
    ref: root,
    role: "tablist",
    children: [
      /* @__PURE__ */ jsx("div", {
        className: withBaseName("inner"),
        ref: innerContainerRef,
        children: renderContent()
      }),
      showActivationIndicator ? /* @__PURE__ */ jsx(TabActivationIndicator, {
        hideThumb: selectedTabOverflowed || tabstripHook.isDragging,
        orientation,
        tabId: selectedTabId
      }) : null,
      tabstripHook.draggable
    ]
  });
});
Tabstrip.displayName = "Tabstrip";

export { Tabstrip };
//# sourceMappingURL=Tabstrip.js.map
