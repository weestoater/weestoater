import { jsx } from 'react/jsx-runtime';
import { useState, useRef, useCallback } from 'react';
import { useDragSpacers } from './useDragSpacers.js';
import { getDraggedItem, moveDragItem, measureDropTargets, getNextDropTarget, dimensions, isDraggedElement } from './drag-utils.js';
import { Draggable } from './Draggable.js';

const dragThreshold = 3;
const useDragDropNaturalMovement = ({
  onDrop,
  orientation = "horizontal",
  containerRef,
  itemQuery = "*"
}) => {
  const [showOverflow, setShowOverflow] = useState(false);
  const overflowMenuShowingRef = useRef(false);
  const [isDragging, setIsDragging] = useState(false);
  const [dragPortal, setDragPortal] = useState(null);
  const draggableRef = useRef(null);
  const startPos = useRef(0);
  const previousPos = useRef(0);
  const mouseOffset = useRef(0);
  const mouseDownTimer = useRef(null);
  const dragLimits = useRef({ start: 0, end: 0 });
  const dragDirection = useRef();
  const dropTarget = useRef(null);
  const measuredDropTargets = useRef([]);
  const { clearSpacers, displaceItem, displaceLastItem } = useDragSpacers();
  const dragMouseMoveHandler = useCallback(
    (evt) => {
      const { POS } = dimensions(orientation);
      const { [POS]: clientPos } = evt;
      const { current: lastClientPos } = previousPos;
      const { current: currentDropTarget } = dropTarget;
      const { current: dropTargets } = measuredDropTargets;
      const draggedItem = getDraggedItem(dropTargets);
      if (Math.abs(lastClientPos - clientPos) > 0) {
        previousPos.current = clientPos;
        const moveDistance = clientPos - startPos.current;
        const pos = startPos.current - mouseOffset.current + moveDistance;
        const renderPos = Math.max(
          dragLimits.current.start,
          Math.min(dragLimits.current.end, pos)
        );
        if (draggableRef.current && containerRef.current) {
          const START = orientation === "horizontal" ? "left" : "top";
          draggableRef.current.style[START] = `${renderPos}px`;
          const direction = lastClientPos < clientPos ? "fwd" : "bwd";
          const offsetPos = clientPos - mouseOffset.current;
          const leadingEdge = direction === "fwd" ? offsetPos + draggedItem.size : offsetPos;
          const nextDropTarget = getNextDropTarget(
            measuredDropTargets.current,
            leadingEdge,
            direction
          );
          if (nextDropTarget && (nextDropTarget.index !== (currentDropTarget == null ? void 0 : currentDropTarget.index) || direction !== dragDirection.current)) {
            if (nextDropTarget.isOverflowIndicator) {
              setShowOverflow(overflowMenuShowingRef.current = true);
            } else {
              const newDropTargets = moveDragItem(dropTargets, nextDropTarget);
              const draggedItem2 = getDraggedItem(newDropTargets);
              const nextDisplacedItem = newDropTargets[draggedItem2.currentIndex + 1];
              if (nextDisplacedItem) {
                displaceItem(
                  nextDisplacedItem,
                  draggedItem2.size,
                  true,
                  direction
                );
              } else {
                const displacedItem = newDropTargets[draggedItem2.currentIndex - 1];
                displaceLastItem(displacedItem, draggedItem2.size, true);
              }
              measuredDropTargets.current = newDropTargets;
              setShowOverflow(overflowMenuShowingRef.current = false);
            }
            dropTarget.current = nextDropTarget;
            dragDirection.current = direction;
          }
        }
      }
    },
    [containerRef, displaceItem, displaceLastItem, orientation]
  );
  const dragMouseUpHandler = useCallback(() => {
    document.removeEventListener("mousemove", dragMouseMoveHandler, false);
    document.removeEventListener("mouseup", dragMouseUpHandler, false);
    clearSpacers();
    const { current: dropTargets } = measuredDropTargets;
    const draggedItem = getDraggedItem(dropTargets);
    const { dataIndex = -1, index, currentIndex: toIndex } = draggedItem;
    const fromIndex = dataIndex !== -1 ? dataIndex : index;
    dropTarget.current = null;
    dragDirection.current = void 0;
    setDragPortal(null);
    if (overflowMenuShowingRef.current) {
      onDrop(fromIndex, -1);
    } else if (fromIndex !== toIndex) {
      onDrop(fromIndex, toIndex);
    }
    setShowOverflow(false);
    setIsDragging(false);
  }, [clearSpacers, dragMouseMoveHandler, onDrop]);
  const enterDraggingState = useCallback(
    (evt) => {
      const { POS, START } = dimensions(orientation);
      const { [POS]: clientPos } = evt;
      const evtTarget = evt.target;
      const dragElement = evtTarget.closest(itemQuery);
      if (dragElement) {
        const query = `:is(${itemQuery}:not([data-overflowed="true"]),[data-overflow-indicator])`;
        const dropTargets = measureDropTargets(
          containerRef.current,
          orientation,
          dragElement,
          query
        );
        const draggedItem = dropTargets.find(isDraggedElement);
        if (draggedItem && containerRef.current) {
          measuredDropTargets.current = dropTargets;
          dropTarget.current = draggedItem;
          const containerRect = containerRef.current.getBoundingClientRect();
          const draggableRect = draggedItem.element.getBoundingClientRect();
          mouseOffset.current = clientPos - draggedItem.start;
          const [lastItem] = dropTargets.slice(-1);
          const lastChildEnd = lastItem.end;
          console.log({ lastItem });
          dragLimits.current.start = containerRect[START];
          dragLimits.current.end = lastItem.isOverflowIndicator ? Math.max(lastItem.start, containerRect.right - draggedItem.size) : lastChildEnd - draggedItem.size;
          setDragPortal(
            /* @__PURE__ */ jsx(Draggable, {
              wrapperClassName: `tabstrip-${orientation}`,
              ref: draggableRef,
              rect: draggableRect,
              element: dragElement.cloneNode(true)
            })
          );
          if (draggedItem !== lastItem) {
            const nextItem = dropTargets[draggedItem.index + 1];
            displaceItem(nextItem, draggedItem.size, false);
          } else {
            const displacedItem = dropTargets[draggedItem.index];
            displaceLastItem(displacedItem, draggedItem.size, false);
          }
          setIsDragging(true);
        }
        document.addEventListener("mousemove", dragMouseMoveHandler, false);
        document.addEventListener("mouseup", dragMouseUpHandler, false);
      }
    },
    [
      containerRef,
      displaceItem,
      displaceLastItem,
      dragMouseMoveHandler,
      dragMouseUpHandler,
      itemQuery,
      orientation,
      setIsDragging
    ]
  );
  const preDragMouseMoveHandler = useCallback(
    (evt) => {
      const { POS } = dimensions(orientation);
      const { [POS]: clientPos } = evt;
      const mouseMoveDistance = Math.abs(clientPos - startPos.current);
      if (mouseMoveDistance > dragThreshold && containerRef.current) {
        if (mouseDownTimer.current) {
          window.clearTimeout(mouseDownTimer.current);
          mouseDownTimer.current = null;
        }
        document.removeEventListener(
          "mousemove",
          preDragMouseMoveHandler,
          false
        );
        document.removeEventListener("mouseup", preDragMouseUpHandler, false);
        enterDraggingState(evt);
      }
    },
    [containerRef, enterDraggingState, orientation]
  );
  const preDragMouseUpHandler = useCallback(() => {
    if (mouseDownTimer.current) {
      window.clearTimeout(mouseDownTimer.current);
      mouseDownTimer.current = null;
    }
    document.removeEventListener("mousemove", preDragMouseMoveHandler, false);
    document.removeEventListener("mouseup", preDragMouseUpHandler, false);
  }, [preDragMouseMoveHandler]);
  const mouseDownHandler = useCallback(
    (evt) => {
      if (containerRef.current && !evt.defaultPrevented) {
        const { POS } = dimensions(orientation);
        const { [POS]: clientPos } = evt;
        startPos.current = clientPos;
        previousPos.current = clientPos;
        document.addEventListener("mousemove", preDragMouseMoveHandler, false);
        document.addEventListener("mouseup", preDragMouseUpHandler, false);
        evt.persist();
        mouseDownTimer.current = window.setTimeout(() => {
          document.removeEventListener(
            "mousemove",
            preDragMouseMoveHandler,
            false
          );
          document.removeEventListener("mouseup", preDragMouseUpHandler, false);
          enterDraggingState(evt.nativeEvent);
        }, 500);
      }
    },
    [
      containerRef,
      enterDraggingState,
      orientation,
      preDragMouseMoveHandler,
      preDragMouseUpHandler
    ]
  );
  const draggedItemIndex = isDragging ? getDraggedItem(measuredDropTargets.current).dataIndex : -1;
  return {
    draggable: dragPortal,
    dropIndicator: null,
    draggedItemIndex,
    isDragging,
    onMouseDown: mouseDownHandler,
    revealOverflowedItems: showOverflow
  };
};

export { useDragDropNaturalMovement };
//# sourceMappingURL=useDragDropNaturalMovement.js.map
