{"version":3,"file":"drag-utils.js","sources":["../src/tabs/drag-drop/drag-utils.ts"],"sourcesContent":["import { orientationType } from \"../../responsive\";\nimport { Direction, FWD } from \"./dragDropTypes\";\n\nconst LEFT_RIGHT = [\"left\", \"right\"];\nconst TOP_BOTTOM = [\"top\", \"bottom\"];\n// duplicated in repsonsive\n\nexport type MeasuredDropTarget = {\n  currentIndex: number;\n  dataIndex?: number;\n  element: HTMLElement;\n  index: number;\n  isDraggedElement: boolean;\n  isOverflowIndicator?: boolean;\n  start: number;\n  end: number;\n  mid: number;\n  size: number;\n};\n\nexport type targetType = {\n  element: HTMLElement | null;\n  index: number;\n  isLast?: boolean;\n};\n\ntype MousePosKey = keyof Pick<MouseEvent, \"clientX\" | \"clientY\">;\ntype DOMRectKey = keyof Omit<DOMRect, \"toJSON\">;\ntype DOMRectDimensionKey = keyof Pick<DOMRect, \"width\" | \"height\">;\ntype Dimension = keyof Pick<DOMRect, \"width\" | \"height\">;\ntype ElementDimension = keyof Pick<\n  HTMLElement,\n  | \"scrollHeight\"\n  | \"scrollWidth\"\n  | \"clientHeight\"\n  | \"clientWidth\"\n  | \"scrollTop\"\n  | \"scrollLeft\"\n>;\n\nexport const measureElementSizeAndPosition = (\n  element: HTMLElement,\n  dimension: Dimension = \"width\",\n  includeAutoMargin = false\n) => {\n  const pos = dimension === \"width\" ? \"left\" : \"top\";\n  const { [dimension]: size, [pos]: position } =\n    element.getBoundingClientRect();\n  const { padEnd = false, padStart = false } = element.dataset;\n  const style = getComputedStyle(element);\n  const [start, end] = dimension === \"width\" ? LEFT_RIGHT : TOP_BOTTOM;\n  const marginStart =\n    padStart && !includeAutoMargin\n      ? 0\n      : parseInt(style.getPropertyValue(`margin-${start}`), 10);\n  const marginEnd =\n    padEnd && !includeAutoMargin\n      ? 0\n      : parseInt(style.getPropertyValue(`margin-${end}`), 10);\n\n  let minWidth = size;\n  const flexShrink = parseInt(style.getPropertyValue(\"flex-shrink\"), 10);\n  if (flexShrink > 0) {\n    const flexBasis = parseInt(style.getPropertyValue(\"flex-basis\"), 10);\n    if (!isNaN(flexBasis) && flexBasis > 0) {\n      minWidth = flexBasis;\n    }\n  }\n  return [position, marginStart + minWidth + marginEnd];\n};\n\nconst DIMENSIONS = {\n  horizontal: {\n    CLIENT_SIZE: \"clientWidth\" as ElementDimension,\n    CONTRA: \"top\" as DOMRectKey,\n    CONTRA_POS: \"clientY\" as MousePosKey,\n    DIMENSION: \"width\" as DOMRectDimensionKey,\n    END: \"right\" as DOMRectKey,\n    POS: \"clientX\" as MousePosKey,\n    SCROLL_POS: \"scrollTop\" as ElementDimension,\n    SCROLL_SIZE: \"scrollWidth\" as ElementDimension,\n    START: \"left\" as DOMRectKey,\n  },\n  vertical: {\n    CLIENT_SIZE: \"clientHeight\" as ElementDimension,\n    CONTRA: \"left\" as DOMRectKey,\n    CONTRA_POS: \"clientX\" as MousePosKey,\n    DIMENSION: \"height\" as DOMRectDimensionKey,\n    END: \"bottom\" as DOMRectKey,\n    POS: \"clientY\" as MousePosKey,\n    SCROLL_POS: \"scrollLeft\" as ElementDimension,\n    SCROLL_SIZE: \"scrollHeight\" as ElementDimension,\n    START: \"top\" as DOMRectKey,\n  },\n};\nexport const dimensions = (orientation: orientationType) =>\n  DIMENSIONS[orientation];\n\nexport const getDraggedItem = (\n  measuredItems: MeasuredDropTarget[]\n): MeasuredDropTarget => {\n  const result = measuredItems.find((item) => item.isDraggedElement);\n  if (result) {\n    return result;\n  } else {\n    throw Error(\"measuredItems do not contain a draggedElement\");\n  }\n};\n\nexport const moveDragItem = (\n  measuredItems: MeasuredDropTarget[],\n  dropTarget: MeasuredDropTarget\n): MeasuredDropTarget[] => {\n  const items: MeasuredDropTarget[] = measuredItems.slice();\n  const draggedItem = getDraggedItem(items);\n  const draggedIndex = items.indexOf(draggedItem!);\n  const targetIndex = items.indexOf(dropTarget);\n\n  const firstPos = Math.min(draggedIndex, targetIndex);\n  const lastPos = Math.max(draggedIndex, targetIndex);\n  let { start } = items[firstPos];\n\n  items[draggedIndex] = { ...dropTarget };\n  items[targetIndex] = { ...draggedItem };\n\n  for (let i = firstPos; i <= lastPos; i++) {\n    const item = items[i];\n    item.currentIndex = i;\n    item.start = start;\n    item.end = start + item.size;\n    item.mid = start + item.size / 2;\n    start = item.end;\n  }\n\n  return items;\n};\n\nexport const isDraggedElement = (item: MeasuredDropTarget) =>\n  item.isDraggedElement;\n\nexport const measureDropTargets = (\n  container: HTMLElement,\n  orientation: orientationType,\n  draggedItem: HTMLElement,\n  itemQuery?: string\n) => {\n  const dragThresholds: MeasuredDropTarget[] = [];\n\n  // TODO need to make sure we're including only the children we should\n  const children = Array.from(\n    itemQuery ? container.querySelectorAll(itemQuery) : container.children\n  );\n  let previousThreshold = null;\n  for (let index = 0; index < children.length; index++) {\n    const element = children[index] as HTMLElement;\n    const dimension = orientation === \"horizontal\" ? \"width\" : \"height\";\n    let [start, size] = measureElementSizeAndPosition(element, dimension);\n\n    dragThresholds.push(\n      (previousThreshold = {\n        currentIndex: index,\n        dataIndex: parseInt(element.dataset.index ?? \"-1\"),\n        index,\n        isDraggedElement: element === draggedItem,\n        isOverflowIndicator: element.dataset.overflowIndicator === \"true\",\n        element: element as HTMLElement,\n        start,\n        end: start + size,\n        size,\n        mid: start + size / 2,\n      })\n    );\n  }\n  return dragThresholds;\n};\n\nexport const getNextDropTarget = (\n  dropTargets: MeasuredDropTarget[],\n  pos: number,\n  direction: Direction\n) => {\n  const len = dropTargets.length;\n  if (direction === FWD) {\n    for (let index = 0; index < len; index++) {\n      let dropTarget = dropTargets[index];\n      const { start, mid, end } = dropTarget;\n      if (pos > end) {\n        continue;\n      } else if (pos > mid) {\n        return dropTarget.isDraggedElement ? null : dropTarget;\n      } else if (pos > start) {\n        dropTarget = dropTargets[index - 1];\n        return dropTarget.isDraggedElement ? null : dropTarget;\n      }\n    }\n  } else {\n    for (let index = len - 1; index >= 0; index--) {\n      let dropTarget = dropTargets[index];\n      const { start, mid, end } = dropTarget;\n      if (pos < start) {\n        continue;\n      } else if (pos < mid) {\n        return dropTarget.isDraggedElement ? null : dropTarget;\n      } else if (pos < end) {\n        dropTarget = dropTargets[Math.min(len - 1, index + 1)];\n        return dropTarget.isDraggedElement ? null : dropTarget;\n      }\n    }\n  }\n  return null;\n};\n"],"names":[],"mappings":";;AAGA,MAAM,UAAA,GAAa,CAAC,MAAA,EAAQ,OAAO,CAAA,CAAA;AACnC,MAAM,UAAA,GAAa,CAAC,KAAA,EAAO,QAAQ,CAAA,CAAA;AAoC5B,MAAM,gCAAgC,CAC3C,OAAA,EACA,SAAuB,GAAA,OAAA,EACvB,oBAAoB,KACjB,KAAA;AACH,EAAM,MAAA,GAAA,GAAM,SAAc,KAAA,OAAA,GAAU,MAAS,GAAA,KAAA,CAAA;AAC7C,EAAA,MAAM,GAAG,SAAY,GAAA,IAAA,EAAA,CAAO,MAAM,QAAS,EAAA,GACzC,QAAQ,qBAAsB,EAAA,CAAA;AAChC,EAAA,MAAM,EAAE,MAAS,GAAA,KAAA,EAAO,QAAW,GAAA,KAAA,KAAU,OAAQ,CAAA,OAAA,CAAA;AACrD,EAAM,MAAA,KAAA,GAAQ,iBAAiB,OAAO,CAAA,CAAA;AACtC,EAAA,MAAM,CAAC,KAAO,EAAA,GAAG,CAAI,GAAA,SAAA,KAAc,UAAU,UAAa,GAAA,UAAA,CAAA;AAC1D,EAAM,MAAA,WAAA,GACJ,QAAY,IAAA,CAAC,iBACT,GAAA,CAAA,GACA,QAAS,CAAA,KAAA,CAAM,gBAAiB,CAAA,CAAA,OAAA,EAAU,KAAO,CAAA,CAAA,CAAA,EAAG,EAAE,CAAA,CAAA;AAC5D,EAAM,MAAA,SAAA,GACJ,MAAU,IAAA,CAAC,iBACP,GAAA,CAAA,GACA,QAAS,CAAA,KAAA,CAAM,gBAAiB,CAAA,CAAA,OAAA,EAAU,GAAK,CAAA,CAAA,CAAA,EAAG,EAAE,CAAA,CAAA;AAE1D,EAAA,IAAI,QAAW,GAAA,IAAA,CAAA;AACf,EAAA,MAAM,aAAa,QAAS,CAAA,KAAA,CAAM,gBAAiB,CAAA,aAAa,GAAG,EAAE,CAAA,CAAA;AACrE,EAAA,IAAI,aAAa,CAAG,EAAA;AAClB,IAAA,MAAM,YAAY,QAAS,CAAA,KAAA,CAAM,gBAAiB,CAAA,YAAY,GAAG,EAAE,CAAA,CAAA;AACnE,IAAA,IAAI,CAAC,KAAA,CAAM,SAAS,CAAA,IAAK,YAAY,CAAG,EAAA;AACtC,MAAW,QAAA,GAAA,SAAA,CAAA;AAAA,KACb;AAAA,GACF;AACA,EAAA,OAAO,CAAC,QAAA,EAAU,WAAc,GAAA,QAAA,GAAW,SAAS,CAAA,CAAA;AACtD,EAAA;AAEA,MAAM,UAAa,GAAA;AAAA,EACjB,UAAY,EAAA;AAAA,IACV,WAAa,EAAA,aAAA;AAAA,IACb,MAAQ,EAAA,KAAA;AAAA,IACR,UAAY,EAAA,SAAA;AAAA,IACZ,SAAW,EAAA,OAAA;AAAA,IACX,GAAK,EAAA,OAAA;AAAA,IACL,GAAK,EAAA,SAAA;AAAA,IACL,UAAY,EAAA,WAAA;AAAA,IACZ,WAAa,EAAA,aAAA;AAAA,IACb,KAAO,EAAA,MAAA;AAAA,GACT;AAAA,EACA,QAAU,EAAA;AAAA,IACR,WAAa,EAAA,cAAA;AAAA,IACb,MAAQ,EAAA,MAAA;AAAA,IACR,UAAY,EAAA,SAAA;AAAA,IACZ,SAAW,EAAA,QAAA;AAAA,IACX,GAAK,EAAA,QAAA;AAAA,IACL,GAAK,EAAA,SAAA;AAAA,IACL,UAAY,EAAA,YAAA;AAAA,IACZ,WAAa,EAAA,cAAA;AAAA,IACb,KAAO,EAAA,KAAA;AAAA,GACT;AACF,CAAA,CAAA;AACa,MAAA,UAAA,GAAa,CAAC,WAAA,KACzB,UAAW,CAAA,WAAA,EAAA;AAEA,MAAA,cAAA,GAAiB,CAC5B,aACuB,KAAA;AACvB,EAAA,MAAM,SAAS,aAAc,CAAA,IAAA,CAAK,CAAC,IAAA,KAAS,KAAK,gBAAgB,CAAA,CAAA;AACjE,EAAA,IAAI,MAAQ,EAAA;AACV,IAAO,OAAA,MAAA,CAAA;AAAA,GACF,MAAA;AACL,IAAA,MAAM,MAAM,+CAA+C,CAAA,CAAA;AAAA,GAC7D;AACF,EAAA;AAEa,MAAA,YAAA,GAAe,CAC1B,aAAA,EACA,UACyB,KAAA;AACzB,EAAM,MAAA,KAAA,GAA8B,cAAc,KAAM,EAAA,CAAA;AACxD,EAAM,MAAA,WAAA,GAAc,eAAe,KAAK,CAAA,CAAA;AACxC,EAAM,MAAA,YAAA,GAAe,KAAM,CAAA,OAAA,CAAQ,WAAY,CAAA,CAAA;AAC/C,EAAM,MAAA,WAAA,GAAc,KAAM,CAAA,OAAA,CAAQ,UAAU,CAAA,CAAA;AAE5C,EAAA,MAAM,QAAW,GAAA,IAAA,CAAK,GAAI,CAAA,YAAA,EAAc,WAAW,CAAA,CAAA;AACnD,EAAA,MAAM,OAAU,GAAA,IAAA,CAAK,GAAI,CAAA,YAAA,EAAc,WAAW,CAAA,CAAA;AAClD,EAAI,IAAA,EAAE,KAAM,EAAA,GAAI,KAAM,CAAA,QAAA,CAAA,CAAA;AAEtB,EAAM,KAAA,CAAA,YAAA,CAAA,GAAgB,EAAE,GAAG,UAAW,EAAA,CAAA;AACtC,EAAM,KAAA,CAAA,WAAA,CAAA,GAAe,EAAE,GAAG,WAAY,EAAA,CAAA;AAEtC,EAAA,KAAA,IAAS,CAAI,GAAA,QAAA,EAAU,CAAK,IAAA,OAAA,EAAS,CAAK,EAAA,EAAA;AACxC,IAAA,MAAM,OAAO,KAAM,CAAA,CAAA,CAAA,CAAA;AACnB,IAAA,IAAA,CAAK,YAAe,GAAA,CAAA,CAAA;AACpB,IAAA,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;AACb,IAAK,IAAA,CAAA,GAAA,GAAM,QAAQ,IAAK,CAAA,IAAA,CAAA;AACxB,IAAK,IAAA,CAAA,GAAA,GAAM,KAAQ,GAAA,IAAA,CAAK,IAAO,GAAA,CAAA,CAAA;AAC/B,IAAA,KAAA,GAAQ,IAAK,CAAA,GAAA,CAAA;AAAA,GACf;AAEA,EAAO,OAAA,KAAA,CAAA;AACT,EAAA;AAEa,MAAA,gBAAA,GAAmB,CAAC,IAAA,KAC/B,IAAK,CAAA,iBAAA;AAEA,MAAM,kBAAqB,GAAA,CAChC,SACA,EAAA,WAAA,EACA,aACA,SACG,KAAA;AAjJL,EAAA,IAAA,EAAA,CAAA;AAkJE,EAAA,MAAM,iBAAuC,EAAC,CAAA;AAG9C,EAAA,MAAM,WAAW,KAAM,CAAA,IAAA;AAAA,IACrB,SAAY,GAAA,SAAA,CAAU,gBAAiB,CAAA,SAAS,IAAI,SAAU,CAAA,QAAA;AAAA,GAChE,CAAA;AAEA,EAAA,KAAA,IAAS,KAAQ,GAAA,CAAA,EAAG,KAAQ,GAAA,QAAA,CAAS,QAAQ,KAAS,EAAA,EAAA;AACpD,IAAA,MAAM,UAAU,QAAS,CAAA,KAAA,CAAA,CAAA;AACzB,IAAM,MAAA,SAAA,GAAY,WAAgB,KAAA,YAAA,GAAe,OAAU,GAAA,QAAA,CAAA;AAC3D,IAAA,IAAI,CAAC,KAAO,EAAA,IAAI,CAAI,GAAA,6BAAA,CAA8B,SAAS,SAAS,CAAA,CAAA;AAEpE,IAAe,cAAA,CAAA,IAAA;AAAA,MACQ;AAAA,QACnB,YAAc,EAAA,KAAA;AAAA,QACd,WAAW,QAAS,CAAA,CAAA,EAAA,GAAA,OAAA,CAAQ,OAAQ,CAAA,KAAA,KAAhB,YAAyB,IAAI,CAAA;AAAA,QACjD,KAAA;AAAA,QACA,kBAAkB,OAAY,KAAA,WAAA;AAAA,QAC9B,mBAAA,EAAqB,OAAQ,CAAA,OAAA,CAAQ,iBAAsB,KAAA,MAAA;AAAA,QAC3D,OAAA;AAAA,QACA,KAAA;AAAA,QACA,KAAK,KAAQ,GAAA,IAAA;AAAA,QACb,IAAA;AAAA,QACA,GAAA,EAAK,QAAQ,IAAO,GAAA,CAAA;AAAA,OACtB;AAAA,KACF,CAAA;AAAA,GACF;AACA,EAAO,OAAA,cAAA,CAAA;AACT,EAAA;AAEO,MAAM,iBAAoB,GAAA,CAC/B,WACA,EAAA,GAAA,EACA,SACG,KAAA;AACH,EAAA,MAAM,MAAM,WAAY,CAAA,MAAA,CAAA;AACxB,EAAA,IAAI,cAAc,GAAK,EAAA;AACrB,IAAA,KAAA,IAAS,KAAQ,GAAA,CAAA,EAAG,KAAQ,GAAA,GAAA,EAAK,KAAS,EAAA,EAAA;AACxC,MAAA,IAAI,aAAa,WAAY,CAAA,KAAA,CAAA,CAAA;AAC7B,MAAA,MAAM,EAAE,KAAA,EAAO,GAAK,EAAA,GAAA,EAAQ,GAAA,UAAA,CAAA;AAC5B,MAAA,IAAI,MAAM,GAAK,EAAA;AACb,QAAA,SAAA;AAAA,OACF,MAAA,IAAW,MAAM,GAAK,EAAA;AACpB,QAAO,OAAA,UAAA,CAAW,mBAAmB,IAAO,GAAA,UAAA,CAAA;AAAA,OAC9C,MAAA,IAAW,MAAM,KAAO,EAAA;AACtB,QAAA,UAAA,GAAa,YAAY,KAAQ,GAAA,CAAA,CAAA,CAAA;AACjC,QAAO,OAAA,UAAA,CAAW,mBAAmB,IAAO,GAAA,UAAA,CAAA;AAAA,OAC9C;AAAA,KACF;AAAA,GACK,MAAA;AACL,IAAA,KAAA,IAAS,KAAQ,GAAA,GAAA,GAAM,CAAG,EAAA,KAAA,IAAS,GAAG,KAAS,EAAA,EAAA;AAC7C,MAAA,IAAI,aAAa,WAAY,CAAA,KAAA,CAAA,CAAA;AAC7B,MAAA,MAAM,EAAE,KAAA,EAAO,GAAK,EAAA,GAAA,EAAQ,GAAA,UAAA,CAAA;AAC5B,MAAA,IAAI,MAAM,KAAO,EAAA;AACf,QAAA,SAAA;AAAA,OACF,MAAA,IAAW,MAAM,GAAK,EAAA;AACpB,QAAO,OAAA,UAAA,CAAW,mBAAmB,IAAO,GAAA,UAAA,CAAA;AAAA,OAC9C,MAAA,IAAW,MAAM,GAAK,EAAA;AACpB,QAAA,UAAA,GAAa,YAAY,IAAK,CAAA,GAAA,CAAI,GAAM,GAAA,CAAA,EAAG,QAAQ,CAAC,CAAA,CAAA,CAAA;AACpD,QAAO,OAAA,UAAA,CAAW,mBAAmB,IAAO,GAAA,UAAA,CAAA;AAAA,OAC9C;AAAA,KACF;AAAA,GACF;AACA,EAAO,OAAA,IAAA,CAAA;AACT;;;;"}