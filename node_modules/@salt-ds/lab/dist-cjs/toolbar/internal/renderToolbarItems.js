'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var ToolbarField = require('../toolbar-field/ToolbarField.js');
var Tooltray = require('../Tooltray.js');
require('@salt-ds/core');
var overflowUtils = require('../../responsive/overflowUtils.js');
require('../../responsive/useResizeObserver.js');
var utils = require('../../responsive/utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

const renderToolbarItems = (collectionHook, overflowedItems = [], orientation) => {
  let centerAlign = false;
  let rightAlign = false;
  const items = collectionHook.data;
  const collapseItems = items.filter(overflowUtils.isCollapsedOrCollapsing);
  return items.filter((item) => !item.isOverflowIndicator).map((item, index) => {
    var _a;
    const props = item.element.props;
    const overflowed = overflowedItems.findIndex((item2) => item2.index === index) === -1 ? void 0 : true;
    const collapseItem = collapseItems.find((item2) => item2.index === index);
    const collapsed = (collapseItem == null ? void 0 : collapseItem.collapsed) || void 0;
    const collapsing = (collapseItem == null ? void 0 : collapseItem.collapsing) || void 0;
    const {
      alignCenter: alignCenterProp,
      alignEnd: alignEndProp,
      alignStart: alignStartProp,
      "data-align-center": alignCenter = alignCenterProp,
      "data-align-end": alignEnd = alignEndProp,
      "data-align-start": alignStart = alignStartProp
    } = props;
    let dataPadStart = false;
    let dataPadEnd = false;
    if (alignCenter && !centerAlign) {
      centerAlign = true;
      dataPadStart = true;
    } else if (centerAlign && !alignCenter) {
      rightAlign = true;
      dataPadStart = true;
    } else if (alignEnd && !rightAlign) {
      rightAlign = true;
      dataPadStart = true;
    } else if (alignStart) {
      dataPadEnd = true;
    }
    const toolbarItemProps = {
      id: item.id,
      key: item.id,
      "data-index": index,
      "data-priority": (_a = props["data-priority"]) != null ? _a : 2,
      "data-pad-start": dataPadStart || void 0,
      "data-pad-end": dataPadEnd || void 0,
      "data-collapsed": collapsed,
      "data-collapsing": collapsing,
      "data-overflowed": overflowed,
      orientation
    };
    if (item.element.type === Tooltray.Tooltray) {
      return React__default["default"].cloneElement(item.element, toolbarItemProps);
    } else {
      switch (item.element.type) {
        case ToolbarField.ToolbarField:
          const props2 = item.element.props;
          return React__default["default"].cloneElement(item.element, {
            ...toolbarItemProps,
            children: React__default["default"].cloneElement(props2.children, {
              id: `toolbar-control-${item.id}`
            })
          });
        default:
          const [responsiveProps, componentProps] = utils.liftResponsivePropsToFormField(item.element.props);
          return /* @__PURE__ */ jsxRuntime.jsx(ToolbarField.ToolbarField, {
            ...responsiveProps,
            ...toolbarItemProps,
            children: React__default["default"].cloneElement(item.element, {
              ...componentProps,
              id: `toolbar-control-${item.id}`
            })
          });
      }
    }
  });
};

exports.renderToolbarItems = renderToolbarItems;
//# sourceMappingURL=renderToolbarItems.js.map
