{"version":3,"file":"useOverflow.js","sources":["../src/responsive/useOverflow.ts"],"sourcesContent":["import { useCallback, useRef } from \"react\";\nimport {\n  addAll,\n  allExceptOverflowIndicator,\n  getOverflowIndicator,\n  isOverflowed,\n  measureContainerOverflow,\n  notOverflowed,\n  popNextItemByPriority,\n} from \"./overflowUtils\";\nimport {\n  OverflowItem,\n  OverflowHookProps,\n  OverflowHookResult,\n} from \"./overflowTypes\";\nimport { partition } from \"../utils\";\nimport { useIdMemo } from \"@salt-ds/core\";\n\nconst NO_OVERFLOW_INDICATOR = { size: 0 };\n\nconst getPriority = (item: OverflowItem) => item.priority;\n\nconst popNextOverflowedItem = (items: OverflowItem[]) => {\n  const minPriority = Math.min(...items.map(getPriority));\n  for (let i = 0; i < items.length; i++) {\n    if (!items[i].isOverflowIndicator && items[i].priority === minPriority) {\n      return items.splice(i, 1)[0];\n    }\n  }\n  return null;\n};\n\nexport const useOverflow = ({\n  collectionHook: { dispatch },\n  id: idProp,\n  label = \"Toolbar\",\n  overflowItemsRef,\n  overflowContainerRef,\n  orientation,\n}: OverflowHookProps): OverflowHookResult => {\n  // We need to detect when we enter/exit the overflowed state\n  const innerContainerSizeRef = useRef(0);\n  const overflowIndicatorSize = useRef(0);\n  const id = useIdMemo(idProp);\n\n  const setContainerMinSize = useCallback(\n    (size?: number) => {\n      if (overflowContainerRef.current) {\n        const isHorizontal = orientation === \"horizontal\";\n        if (size === undefined) {\n          const dimension = isHorizontal ? \"width\" : \"height\";\n          ({ [dimension]: size } =\n            overflowContainerRef.current.getBoundingClientRect());\n        }\n        if (typeof size === \"number\") {\n          const styleDimension = isHorizontal ? \"minWidth\" : \"minHeight\";\n          overflowContainerRef.current.style[styleDimension] = `${size}px`;\n        }\n      }\n    },\n    [orientation, overflowContainerRef]\n  );\n\n  const getAllOverflowedItems = useCallback(\n    (renderedSize: number, availableSpace: number) => {\n      const { current: allItems } = overflowItemsRef;\n      const overflowedItems: OverflowItem[] = [];\n      const items = allItems.slice();\n      while (renderedSize > availableSpace) {\n        const overflowedItem = popNextItemByPriority(items);\n        if (overflowedItem === null) {\n          break;\n        }\n        // eslint-disable-next-line no-param-reassign\n        renderedSize -= overflowedItem.size;\n        overflowedItems.push({\n          ...overflowedItem,\n          overflowed: true,\n        });\n      }\n      return overflowedItems;\n    },\n    [overflowItemsRef]\n  );\n\n  const getOverflowedItems = useCallback(\n    (visibleContentSize: number, containerSize: number) => {\n      const newlyOverflowedItems = [];\n      const { current: managedItems } = overflowItemsRef;\n      const visibleItems = managedItems.filter(notOverflowed);\n      while (visibleContentSize > containerSize) {\n        const overflowedItem = popNextItemByPriority(visibleItems);\n        if (overflowedItem === null) {\n          // unable to overflow, all items are collapsed, this is our minimum width,\n          // enforce it ...\n          // TODO what if density changes\n          // TODO probably not right, now we overflow even collapsed items, min width should be\n          // overflow indicator width plus width of any non-overflowable items\n          // setContainerMinSize(visibleContentSize);\n          break;\n        }\n        visibleContentSize -= overflowedItem.size;\n        newlyOverflowedItems.push({\n          ...overflowedItem,\n          overflowed: true,\n        });\n      }\n      return newlyOverflowedItems;\n    },\n    [overflowItemsRef]\n  );\n\n  const getReinstatedItems = useCallback(\n    (containerSize: number): [number, OverflowItem[]] => {\n      const reinstatedItems: OverflowItem[] = [];\n      const { current: managedItems } = overflowItemsRef;\n\n      const [overflowedItems, visibleItems] = partition(\n        managedItems,\n        isOverflowed\n      );\n      const overflowCount = overflowedItems.length;\n      // TODO calculate this without using fullWidth if we have OVERFLOW\n      // Need a loop here where we first remove OVERFLOW, then potentially remove\n      // COLLAPSE too\n      // We want to re-introduce overflowed items before we start to restore collapsed items\n      // When we are dealing with overflowed items, we just use the current width of collapsed items.\n      let visibleContentSize = visibleItems.reduce(\n        allExceptOverflowIndicator,\n        0\n      );\n      let diff = containerSize - visibleContentSize;\n      const { size: overflowSize = 0 } =\n        getOverflowIndicator(managedItems) || NO_OVERFLOW_INDICATOR;\n      const totalOverflowedSize = overflowedItems.reduce(\n        (sum, item) => sum + item.size,\n        0\n      );\n      // It is important to make this check first, because the overflow indicator may have larger size than\n      // individual overflowed item(s).\n      if (totalOverflowedSize <= diff) {\n        reinstatedItems.push(\n          ...overflowedItems.map((item) => ({ ...item, overflowed: false }))\n        );\n      } else {\n        while (overflowedItems.length > 0) {\n          const nextItem = popNextOverflowedItem(overflowedItems);\n          if (nextItem && diff >= nextItem.size) {\n            // we have enough free space to reinstate this overflowed item\n            // we can only ignore the width of overflow Indicator if either there is only one remaining\n            // overflow item (so overflowIndicator will be removed) or diff is big enough to accommodate\n            // the overflow Ind.\n            if (\n              overflowedItems.length === 0 ||\n              diff >= nextItem.size + overflowSize\n            ) {\n              visibleContentSize += nextItem.size;\n              diff = diff - nextItem.size;\n              reinstatedItems.push({\n                ...nextItem,\n                overflowed: false,\n              });\n            } else {\n              break;\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      return [overflowCount, reinstatedItems];\n    },\n    []\n  );\n\n  const resetMeasurements = useCallback(\n    (isOverflowing: boolean, innerContainerSize: number) => {\n      if (isOverflowing) {\n        const { current: managedItems } = overflowItemsRef;\n        const renderedSize = managedItems.reduce(allExceptOverflowIndicator, 0);\n        const overflowIndicator = managedItems.find(\n          (i) => i.isOverflowIndicator\n        );\n        if (\n          overflowIndicator &&\n          overflowIndicator.size !== overflowIndicatorSize.current\n        ) {\n          overflowIndicatorSize.current = overflowIndicator.size;\n          setContainerMinSize(overflowIndicator.size);\n        }\n        const existingOverflow = managedItems.filter(isOverflowed);\n        const updates = getAllOverflowedItems(\n          renderedSize,\n          innerContainerSize - overflowIndicatorSize.current\n        );\n\n        existingOverflow.forEach((item) => {\n          if (!updates.some((i) => i.index === item.index)) {\n            updates.push({\n              ...item,\n              overflowed: false,\n            });\n          }\n        });\n\n        const overflowAdded = !existingOverflow.length && updates.length;\n\n        if (updates.length > 0) {\n          if (overflowAdded) {\n            dispatch({\n              type: \"update-items-add-overflow-indicator\",\n              overflowItems: updates,\n              overflowItem: {\n                fullSize: null,\n                id: `${id}-overflow-indicator`,\n                index: managedItems.length,\n                isOverflowIndicator: true,\n                label: \"Overflow Menu\",\n                priority: 1,\n                source: {},\n              } as OverflowItem<\"source\">,\n            });\n          } else {\n            dispatch({\n              type: \"update-items\",\n              overflowItems: updates,\n            });\n          }\n          return true;\n        } else {\n          return false;\n        }\n      }\n    },\n    [dispatch, getAllOverflowedItems, id, overflowItemsRef, setContainerMinSize]\n  );\n\n  const updateOverflow = useCallback(\n    (containerSize: number, renderedSize: number) => {\n      if (containerSize < renderedSize) {\n        const overflowItems = getOverflowedItems(renderedSize, containerSize);\n        if (overflowItems.length) {\n          dispatch({\n            type: \"update-items\",\n            overflowItems,\n          });\n        }\n      }\n    },\n    [dispatch, getOverflowedItems]\n  );\n\n  const removeOverflow = useCallback(\n    (containerSize: number) => {\n      const [overflowCount, reinstated] = getReinstatedItems(containerSize);\n      if (reinstated.length) {\n        if (overflowCount === reinstated.length) {\n          dispatch({\n            type: \"update-items-remove-overflow-indicator\",\n            overflowItems: reinstated,\n          });\n        } else {\n          dispatch({\n            type: \"update-items\",\n            overflowItems: reinstated,\n          });\n        }\n      }\n    },\n    [dispatch, getReinstatedItems]\n  );\n\n  const handleResize = useCallback(\n    (size: number, containerHasGrown?: boolean) => {\n      const { current: managedItems } = overflowItemsRef;\n      const wasOverflowing = managedItems.some(\n        (item) => item.isOverflowIndicator\n      );\n      const { isOverflowing } = measureContainerOverflow(\n        overflowContainerRef,\n        orientation\n      );\n\n      innerContainerSizeRef.current = size;\n\n      if (!wasOverflowing && isOverflowing) {\n        // entering overflow\n        // TODO if client is not using an overflow indicator, there is nothing to do here,\n        // just let nature take its course. How do we know this ?\n        // This is when we need to add width to measurements we are tracking\n        resetMeasurements(true, size);\n      } else if (wasOverflowing && containerHasGrown) {\n        // check to see if we can reinstate one or more items, possibly all\n        removeOverflow(size);\n      } else if (wasOverflowing && isOverflowing) {\n        // Note: container must have shrunk\n        // still overflowing, possibly more overflowing than before\n        const renderedSize = managedItems\n          .filter(notOverflowed)\n          .reduce(addAll, 0);\n        updateOverflow(size, renderedSize);\n      }\n    },\n    [\n      orientation,\n      overflowContainerRef,\n      overflowItemsRef,\n      removeOverflow,\n      resetMeasurements,\n      updateOverflow,\n    ]\n  );\n\n  return {\n    onResize: handleResize,\n    resetMeasurements,\n  };\n};\n"],"names":["useRef","useIdMemo","useCallback","popNextItemByPriority","notOverflowed","partition","isOverflowed","allExceptOverflowIndicator","getOverflowIndicator","measureContainerOverflow","addAll"],"mappings":"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"}