{"version":3,"file":"overflowUtils.js","sources":["../src/responsive/overflowUtils.tsx"],"sourcesContent":["import {\n  collapsibleType,\n  ElementRef,\n  OverflowItem,\n  orientationType,\n} from \"./overflowTypes\";\n\nexport const DropdownPlaceholder = () => null;\nexport const getDropdownPlaceholder = () => <DropdownPlaceholder />;\n\nexport type heightOrWidth = \"width\" | \"height\";\nexport const NO_DATA = {};\nconst LEFT_RIGHT = [\"left\", \"right\"];\nconst TOP_BOTTOM = [\"top\", \"bottom\"];\n\nexport const allExceptOverflowIndicator = (sum: number, m: OverflowItem) =>\n  sum + (m.isOverflowIndicator ? 0 : m.size);\n\nexport const isCollapsed = (item: OverflowItem): boolean =>\n  item.collapsed === true;\nexport const isCollapsing = (item: OverflowItem): boolean =>\n  item.collapsing === true;\nexport const isCollapsedOrCollapsing = (item: OverflowItem): boolean =>\n  isCollapsed(item) || isCollapsing(item);\nexport const isOverflowed = (item: OverflowItem): boolean =>\n  item.overflowed === true;\nexport const notOverflowed = (item: OverflowItem): boolean =>\n  !isOverflowed(item);\n\nexport const isCollapsible = (item: OverflowItem) =>\n  item.collapsible === \"instant\" || item.collapsible === \"dynamic\";\n\nexport const getIsOverflowed = (managedItems: OverflowItem[]) =>\n  managedItems.some(isOverflowed);\n\nexport const measureContainer = (\n  ref: ElementRef,\n  orientation: orientationType = \"horizontal\"\n): {\n  innerContainerSize: number;\n  rootContainerDepth: number;\n  innerContainerDepth: number;\n} => {\n  const innerElement = ref.current as HTMLElement;\n  const container = innerElement.parentElement;\n  if (container) {\n    const { width: innerWidth, height: innerHeight } =\n      innerElement.getBoundingClientRect();\n    const { width, height } = container.getBoundingClientRect();\n    if (orientation === \"horizontal\") {\n      return {\n        innerContainerSize: innerWidth,\n        rootContainerDepth: height,\n        innerContainerDepth: innerHeight,\n      };\n    } else {\n      return {\n        innerContainerSize: innerHeight,\n        rootContainerDepth: width,\n        innerContainerDepth: innerWidth,\n      };\n    }\n  } else {\n    throw Error(\"measureContainer, innerContainer has no parent element\");\n  }\n};\n\nconst isContainerOverflowing = (\n  containerDepth: number,\n  parentContainerDepth: number,\n  innerElement: HTMLElement,\n  orientation: orientationType\n) => {\n  const isHorizontal = orientation === \"horizontal\";\n  // If true, this is a reliable indication of content wrapping, but the containerDepth\n  // is not always correct\n  if (containerDepth > parentContainerDepth) {\n    return true;\n  } else {\n    // ... hence - expensive, but catches those situations where the containerDepth is wrong\n    const { bottom, right } = innerElement.getBoundingClientRect();\n    const maxPos = Array.from(innerElement.childNodes).reduce<number>(\n      (maxVal, child) => {\n        const rect = (child as HTMLElement).getBoundingClientRect();\n        return Math.max(isHorizontal ? rect.bottom : rect.right, maxVal);\n      },\n      isHorizontal ? bottom : right\n    );\n    return isHorizontal ? maxPos > bottom : maxPos > right;\n  }\n};\n\nexport const measureContainerOverflow = (\n  ref: ElementRef,\n  orientation: orientationType = \"horizontal\"\n): {\n  isOverflowing: boolean;\n  innerContainerSize: number;\n  rootContainerDepth: number;\n} => {\n  const { innerContainerDepth, innerContainerSize, rootContainerDepth } =\n    measureContainer(ref, orientation);\n  const innerElement = ref.current as HTMLElement;\n  const isOverflowing = isContainerOverflowing(\n    innerContainerDepth,\n    rootContainerDepth,\n    innerElement,\n    orientation\n  );\n\n  return { isOverflowing, innerContainerSize, rootContainerDepth };\n};\n\n/**\n * Compute element size including margin.\n * Exclude margin where this has been applied for alignment, via margin: auto\n * which can be identified by the data-pad-end, data-pad-start attributes.\n **/\nexport function measureElementSize(\n  element: HTMLElement,\n  dimension: heightOrWidth = \"width\",\n  includeAutoMargin = false\n): number {\n  const { [dimension]: size } = element.getBoundingClientRect();\n  const { padEnd = false, padStart = false } = element.dataset;\n  const style = getComputedStyle(element);\n  const [start, end] = dimension === \"width\" ? LEFT_RIGHT : TOP_BOTTOM;\n  const marginStart =\n    padStart && !includeAutoMargin\n      ? 0\n      : parseInt(style.getPropertyValue(`margin-${start}`), 10);\n  const marginEnd =\n    padEnd && !includeAutoMargin\n      ? 0\n      : parseInt(style.getPropertyValue(`margin-${end}`), 10);\n\n  let minWidth = size;\n  const flexShrink = parseInt(style.getPropertyValue(\"flex-shrink\"), 10);\n  if (flexShrink > 0) {\n    const flexBasis = parseInt(style.getPropertyValue(\"flex-basis\"), 10);\n    // TODO should we consider percentage values ?\n    // TODO are we still using flexBasis ?\n    if (!isNaN(flexBasis) && flexBasis > 0) {\n      minWidth = flexBasis;\n    }\n  }\n\n  return marginStart + minWidth + marginEnd;\n}\n\nexport const byDescendingPriority = (m1: OverflowItem, m2: OverflowItem) => {\n  let result = m1.priority - m2.priority;\n  if (result === 0) {\n    result = m1.index - m2.index;\n  }\n  return result;\n};\n\n// Helper function to try and determine the display label for an overflow item\n// Currently, Tab uses data-text, so this works for any Tab. Need to decide\n// whether this is appropriate for other components.\n// Note: Tab uses data-text for another reason, it is not implemented there just to\n// support this function.\n// There may be an aria attribute we should use instead\n// function getElementText(element: HTMLElement) {\n//   if (element.dataset.text) {\n//     return element.dataset.text;\n//   }\n//   const textNode = element.querySelector(\"[data-text]\") as HTMLElement;\n//   if (textNode) {\n//     return textNode.dataset.text;\n//   }\n//   return \"\";\n// }\n// const asCollapsibleType = (value?: string): collapsibleType | undefined =>\n//   value === \"instant\" || value == \"dynamic\"\n//     ? (value as collapsibleType)\n//     : undefined;\n\nexport const getOverflowIndicator = (managedItems: OverflowItem[]) =>\n  managedItems.find((item) => item.isOverflowIndicator);\n\n// TODO whats the right way to deduce the label. AccessibleText added\n// to eg delete button makes innerText unreliable.\n// const getLabelForElement = (element: HTMLElement) =>\n//   element.title || getElementText(element) || element.innerText;\n\nconst getPriority = (item: OverflowItem) => item.priority;\n\nexport const popNextItemByPriority = (\n  items: OverflowItem[]\n): OverflowItem | null => {\n  const maxPriority = Math.max(...items.map(getPriority));\n  for (let i = items.length - 1; i >= 0; i--) {\n    if (!items[i].isOverflowIndicator && items[i].priority === maxPriority) {\n      return items.splice(i, 1)[0];\n    }\n  }\n  return null;\n};\n\nexport const measureOverflowItems = (\n  items: OverflowItem[],\n  dimension: heightOrWidth\n): OverflowItem[] => {\n  const measurements = items.map(({ id }) => {\n    const childElement = document.getElementById(id);\n    const size = childElement ? measureElementSize(childElement, dimension) : 0;\n    return size;\n  });\n\n  if (measurements.some((size, i) => size !== items[i].size)) {\n    return items.map((item, i) =>\n      item.size === measurements[i]\n        ? item\n        : {\n            ...item,\n            size: measurements[i],\n          }\n    );\n  } else {\n    return items;\n  }\n};\n\nexport const addAll = (sum: number, m: OverflowItem): number => sum + m.size;\n\nexport const getElementForItem = (ref: ElementRef, item: OverflowItem) =>\n  ref.current!.querySelector(\n    `:scope > [data-index='${item.index}']`\n  ) as HTMLElement;\n\ntype dimension = \"left\" | \"right\" | \"top\" | \"bottom\";\n\nexport const getRuntimePadding = (\n  el: HTMLElement,\n  ...dimensions: dimension[]\n): number[] => {\n  const targetStyle = getComputedStyle(el);\n  return dimensions.map((dimension) =>\n    parseInt(targetStyle.getPropertyValue(`padding-${dimension}`), 10)\n  );\n};\n"],"names":["jsx"],"mappings":"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"}