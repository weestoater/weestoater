{"version":3,"file":"useDynamicCollapse.js","sources":["../src/responsive/useDynamicCollapse.ts"],"sourcesContent":["import { useIsomorphicLayoutEffect } from \"@salt-ds/core\";\nimport { useCallback, useState } from \"react\";\nimport {\n  ElementRef,\n  OverflowItem,\n  OverflowHookProps,\n  DynamicCollapseHookResult,\n} from \"./overflowTypes\";\nimport {\n  byDescendingPriority,\n  getElementForItem,\n  getRuntimePadding,\n  isCollapsed,\n  isCollapsible,\n  measureContainerOverflow,\n  measureElementSize,\n} from \"./overflowUtils\";\n\nconst UNCOLLAPSED_DYNAMIC_ITEMS =\n  '[data-collapsible=\"dynamic\"]:not([data-collapsed=\"true\"]):not([data-collapsing=\"true\"])';\n\nconst hasUncollapsedDynamicItems = (containerRef: ElementRef) =>\n  containerRef.current!.querySelector(UNCOLLAPSED_DYNAMIC_ITEMS) !== null;\n\nconst thereAreCollapsibleItemsAndTheyAreAllCollapsed = (\n  items: OverflowItem[]\n) => {\n  const collapsibleItems = items.filter(isCollapsible);\n  return collapsibleItems.length > 0 && collapsibleItems.every(isCollapsed);\n};\n\nconst nextItemToCollapse = (listItems: OverflowItem[]): OverflowItem =>\n  listItems.filter(isCollapsible).sort(byDescendingPriority).slice(-1)[0];\n\nexport const useDynamicCollapse = ({\n  collectionHook,\n  innerContainerSize = 0,\n  label = \"Toolbar\",\n  overflowItemsRef: managedItemsRef,\n  overflowContainerRef: ref,\n  orientation,\n}: OverflowHookProps): DynamicCollapseHookResult => {\n  const { dispatch } = collectionHook;\n  const [newCollapsingItem, setNewCollapsingItem] =\n    useState<OverflowItem | null>(null);\n  const restoreCollapsingItem = useCallback(() => {\n    dispatch({\n      type: \"restore-collapsing-item\",\n    });\n  }, [dispatch]);\n\n  const collapseCollapsingItem = useCallback(\n    (item: OverflowItem, target: HTMLElement, minSize: number) => {\n      const styleDimension =\n        orientation === \"horizontal\" ? \"minWidth\" : \"minHeight\";\n      // TODO do we really want to do this here ?\n      target.style[styleDimension] = `${minSize}px`;\n      const size = measureElementSize(target);\n\n      dispatch({\n        type: \"collapse-dynamic-item\",\n        overflowItem: item,\n        collapsedSize: size,\n        minSize,\n      });\n    },\n    [dispatch, orientation]\n  );\n\n  const checkDynamicContent = useCallback(\n    (containerHasGrown?: boolean) => {\n      const { current: managedItems } = managedItemsRef;\n      // The order must matter here\n      const collapsingChild = managedItems.find(\n        ({ collapsible, collapsing }) => collapsible === \"dynamic\" && collapsing\n      );\n      const collapsedChild = managedItems.find(\n        ({ collapsible, collapsed }) => collapsible === \"dynamic\" && collapsed\n      );\n\n      if (!collapsingChild && !collapsedChild) {\n        return;\n      }\n      if (collapsedChild && !collapsingChild) {\n        // TODO do we need a check to see whether we now have enough space to completely uncollapse the item ?\n        // We may be able to uncollapse one or more items before the one we set to collapsing\n\n        dispatch({\n          type: \"uncollapse-dynamic-item\",\n          overflowItem: collapsedChild,\n        });\n      } else if (collapsingChild) {\n        if (containerHasGrown && collapsedChild) {\n          const collapsingElement = getElementForItem(ref, collapsingChild);\n          const dimension = orientation === \"horizontal\" ? \"width\" : \"height\";\n          // can we avoid measuring ths element on every resize event ?\n          const size = measureElementSize(collapsingElement, dimension);\n          // collapsingElement.getBoundingClientRect();\n\n          // We don't restore a collapsing item unless there is at least one collapsed item\n          if (collapsedChild && size === collapsingChild.size) {\n            restoreCollapsingItem();\n          }\n        } else {\n          // Note we are going to compare width with minWidth. Margin is ignored\n          // use getBoundingClientRect rather than measureNode\n          const dimension = orientation === \"horizontal\" ? \"width\" : \"height\";\n          const collapsingElement = getElementForItem(ref, collapsingChild);\n          const { [dimension]: measuredSizeOfCollapsingElement } =\n            collapsingElement.getBoundingClientRect();\n          // minsize should be the size of the last item in the tooltray\n          const [padStart, padEnd] = getRuntimePadding(\n            collapsingElement,\n            \"left\",\n            \"right\"\n          );\n          //TODO we don't really want to measure the last item in the collapsing container\n          // we want to measure the width of the item that will be the last to overflow.\n          const lastTooltrayItem = collapsingElement.querySelector(\n            \".Responsive-inner > :last-child\"\n          );\n          if (lastTooltrayItem) {\n            const { [dimension]: childMinSize } =\n              lastTooltrayItem.getBoundingClientRect();\n            const minSize = padStart + childMinSize + padEnd;\n            if (Math.floor(measuredSizeOfCollapsingElement) <= minSize) {\n              collapseCollapsingItem(\n                collapsingChild,\n                collapsingElement,\n                minSize\n              );\n            }\n          }\n        }\n      }\n    },\n    [\n      collapseCollapsingItem,\n      dispatch,\n      managedItemsRef,\n      orientation,\n      ref,\n      restoreCollapsingItem,\n    ]\n  );\n\n  const handleResize = useCallback(\n    (size: number, containerHasGrown?: boolean) => {\n      const { current: managedItems } = managedItemsRef;\n      const { isOverflowing: willOverflow } = measureContainerOverflow(\n        ref,\n        orientation\n      );\n\n      const collapsingItem = managedItems.find((item) => item.collapsing);\n\n      if (collapsingItem) {\n        checkDynamicContent(containerHasGrown);\n      } else if (\n        containerHasGrown &&\n        !willOverflow &&\n        thereAreCollapsibleItemsAndTheyAreAllCollapsed(managedItems)\n      ) {\n        checkDynamicContent(true);\n      }\n    },\n    [checkDynamicContent, managedItemsRef, orientation, ref]\n  );\n\n  const resetMeasurements = useCallback(() => {\n    const { current: managedItems } = managedItemsRef;\n    const hasDynamicItems = hasUncollapsedDynamicItems(ref);\n    if (hasDynamicItems) {\n      const collapsingItem = nextItemToCollapse(managedItems);\n      setNewCollapsingItem(collapsingItem);\n\n      dispatch({\n        type: \"collapsing-item\",\n        overflowItem: collapsingItem,\n      });\n      return true;\n    } else {\n      return false;\n    }\n  }, [dispatch, managedItemsRef, ref]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (newCollapsingItem) {\n      checkDynamicContent(false);\n    }\n  }, [checkDynamicContent, newCollapsingItem]);\n\n  return {\n    onResize: handleResize,\n    resetMeasurements,\n  };\n};\n"],"names":["isCollapsible","isCollapsed","byDescendingPriority","useState","useCallback","measureElementSize","getElementForItem","getRuntimePadding","measureContainerOverflow","useIsomorphicLayoutEffect"],"mappings":"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"}