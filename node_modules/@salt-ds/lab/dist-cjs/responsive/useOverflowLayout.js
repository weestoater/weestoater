'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var overflowUtils = require('./overflowUtils.js');
var useDynamicCollapse = require('./useDynamicCollapse.js');
var useInstantCollapse = require('./useInstantCollapse.js');
var useOverflow = require('./useOverflow.js');
var useReclaimSpace = require('./useReclaimSpace.js');
var useResizeObserver = require('./useResizeObserver.js');
require('@salt-ds/core');

const MONITORED_DIMENSIONS = {
  horizontal: ["width", "scrollHeight"],
  vertical: ["height", "scrollWidth"],
  none: []
};
const useOverflowLayout = ({
  collectionHook,
  id,
  orientation,
  label = "Toolbar",
  disableOverflow = false
}) => {
  const overflowContainerRef = React.useRef(null);
  const overflowItemsRef = React.useRef([]);
  const measurement = React.useRef({ innerContainerSize: 0, rootContainerDepth: 0 });
  const { innerContainerSize } = measurement.current;
  const { dispatch, version: collectionVersion } = collectionHook;
  overflowItemsRef.current = collectionHook.data;
  const {
    onResize: onOverflowResize,
    resetMeasurements: resetOverflowMeasurements
  } = useOverflow.useOverflow({
    collectionHook,
    id,
    label,
    overflowItemsRef,
    orientation,
    overflowContainerRef
  });
  const hasOverflowedItems = overflowUtils.getIsOverflowed(collectionHook.data);
  const {
    onResize: onDynamicResize,
    resetMeasurements: resetDynamicMeasurements
  } = useDynamicCollapse.useDynamicCollapse({
    collectionHook,
    innerContainerSize,
    label,
    overflowItemsRef,
    orientation,
    overflowContainerRef
  });
  const {
    onResize: onInstantResize,
    resetMeasurements: resetInstantMeasurements
  } = useInstantCollapse.useInstantCollapse({
    collectionHook,
    hasOverflowedItems,
    innerContainerSize,
    label,
    overflowItemsRef,
    orientation,
    overflowContainerRef
  });
  const { onResize: onReclaimResize } = useReclaimSpace.useReclaimSpace({
    collectionHook,
    label,
    overflowItemsRef,
    orientation,
    overflowContainerRef
  });
  const resizeHandler = React.useCallback(
    ({
      scrollHeight,
      height = scrollHeight,
      scrollWidth,
      width = scrollWidth
    }) => {
      const size = orientation === "horizontal" ? width : height;
      if (typeof size === "number") {
        const { innerContainerSize: innerContainerSize2 } = measurement.current;
        const sizeDiff = size - innerContainerSize2;
        if (Math.abs(sizeDiff) > 0.5) {
          measurement.current.innerContainerSize = size;
          const containerHasGrown = size > innerContainerSize2;
          onDynamicResize(size, containerHasGrown);
          onInstantResize(size, containerHasGrown);
          onOverflowResize(size, containerHasGrown);
          onReclaimResize(size, containerHasGrown);
        }
      }
    },
    [
      onDynamicResize,
      onInstantResize,
      onOverflowResize,
      onReclaimResize,
      orientation
    ]
  );
  const measureAndInitialize = React.useCallback(() => {
    const { isOverflowing, ...contentWidthAndDepth } = overflowUtils.measureContainerOverflow(
      overflowContainerRef,
      orientation
    );
    measurement.current = contentWidthAndDepth;
    const { innerContainerSize: innerContainerSize2 } = contentWidthAndDepth;
    let handled = resetInstantMeasurements(isOverflowing);
    if (!handled) {
      handled = resetDynamicMeasurements();
      if (!handled) {
        resetOverflowMeasurements == null ? void 0 : resetOverflowMeasurements(isOverflowing, innerContainerSize2);
      }
    }
  }, [
    orientation,
    resetInstantMeasurements,
    resetDynamicMeasurements,
    resetOverflowMeasurements
  ]);
  const switchPriorities = React.useCallback(
    (item1, item2) => {
      const { priority: priority1 } = item1;
      const { priority: priority2 } = item2;
      if (priority1 !== priority2) {
        dispatch({
          type: "update-items",
          overflowItems: [
            { id: item1.id, priority: priority2 },
            { id: item2.id, priority: priority1 }
          ]
        });
        setTimeout(measureAndInitialize, 0);
      }
    },
    [dispatch, measureAndInitialize]
  );
  useResizeObserver.useResizeObserver(
    overflowContainerRef,
    MONITORED_DIMENSIONS[disableOverflow ? "none" : orientation],
    resizeHandler
  );
  React.useEffect(() => {
    if (!disableOverflow) {
      measureAndInitialize();
    }
  }, [collectionVersion, disableOverflow, measureAndInitialize]);
  return [overflowContainerRef, switchPriorities];
};

exports.useOverflowLayout = useOverflowLayout;
//# sourceMappingURL=useOverflowLayout.js.map
