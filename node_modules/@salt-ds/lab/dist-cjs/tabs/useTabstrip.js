'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var Tab = require('./Tab.js');
var useKeyboardNavigation = require('./useKeyboardNavigation.js');
var useDragDrop = require('./drag-drop/useDragDrop.js');
var useSelection = require('./useSelection.js');
var useEditableItem = require('./useEditableItem.js');

const useTabstrip = ({
  activeTabIndex: activeTabIndexProp,
  allowDragDrop = false,
  collectionHook,
  defaultActiveTabIndex,
  editing: editingProp,
  idRoot,
  innerContainerRef,
  keyBoardActivation,
  onActiveChange,
  onCloseTab,
  onEnterEditMode,
  onExitEditMode,
  onMoveTab,
  orientation,
  promptForNewTabName
}) => {
  const lastSelection = React.useRef(
    activeTabIndexProp === null ? null : activeTabIndexProp || defaultActiveTabIndex || 0
  );
  const pendingNewTab = React.useRef(null);
  const overflowedItems = collectionHook.data.filter((item) => item.overflowed);
  const keyboardHook = useKeyboardNavigation.useKeyboardNavigation({
    indexPositions: collectionHook.data,
    keyBoardActivation,
    orientation,
    selectedIndex: lastSelection.current
  });
  const selectionHook = useSelection.useSelection({
    defaultSelected: defaultActiveTabIndex,
    highlightedIdx: keyboardHook.highlightedIdx,
    onSelectionChange: onActiveChange,
    selected: activeTabIndexProp
  });
  lastSelection.current = selectionHook.selected;
  const handleDrop = React.useCallback(
    (fromIndex, toIndex) => {
      onMoveTab == null ? void 0 : onMoveTab(fromIndex, toIndex);
      if (toIndex === -1) ; else {
        if (selectionHook.selected === null) ; else if (selectionHook.selected === fromIndex) {
          selectionHook.activateTab(toIndex);
        } else if (fromIndex > selectionHook.selected && toIndex <= selectionHook.selected) {
          selectionHook.activateTab(selectionHook.selected + 1);
        } else if (fromIndex < selectionHook.selected && toIndex >= selectionHook.selected) {
          selectionHook.activateTab(selectionHook.selected - 1);
        }
      }
    },
    [onMoveTab, selectionHook]
  );
  const dragDropHook = useDragDrop.useDragDrop({
    allowDragDrop,
    containerRef: innerContainerRef,
    extendedDropZone: overflowedItems.length > 0,
    onDrop: handleDrop,
    orientation: "horizontal",
    itemQuery: ".saltTab"
  });
  const editableHook = useEditableItem.useEditableItem({
    editing: editingProp,
    highlightedIdx: keyboardHook.highlightedIdx,
    indexPositions: collectionHook.data,
    onEnterEditMode,
    onExitEditMode
  });
  const handleExitEditMode = React.useCallback(
    (originalValue, editedValue, allowDeactivation, tabIndex) => {
      editableHook.onExitEditMode(
        originalValue,
        editedValue,
        allowDeactivation,
        tabIndex
      );
      if (!allowDeactivation) {
        keyboardHook.focusTab(tabIndex, false, true);
      }
    },
    [editableHook, keyboardHook]
  );
  const handleClick = React.useCallback(
    (evt, tabIndex) => {
      if (!dragDropHook.isDragging) {
        keyboardHook.onClick(evt, tabIndex);
        selectionHook.onClick(evt, tabIndex);
      }
    },
    [dragDropHook.isDragging, keyboardHook, selectionHook]
  );
  const handleKeyDown = React.useCallback(
    (evt) => {
      keyboardHook.onKeyDown(evt);
      if (!evt.defaultPrevented) {
        selectionHook.onKeyDown(evt);
      }
      if (!evt.defaultPrevented) {
        editableHook.onKeyDown(evt);
      }
    },
    [keyboardHook, selectionHook, editableHook]
  );
  const navigationProps2 = {
    onFocus: keyboardHook.onFocus,
    onKeyDown: handleKeyDown
  };
  const tabProps = {
    onClick: handleClick,
    onEnterEditMode: editableHook.onEnterEditMode,
    onExitEditMode: handleExitEditMode
  };
  const addTab = React.useCallback(
    (indexPosition = collectionHook.data.length - 1) => {
      const tabId = pendingNewTab.current = `${idRoot}-${collectionHook.data.length}`;
      const overflowIndicator = collectionHook.data.find(
        (i) => i.isOverflowIndicator
      );
      const newTabs = collectionHook.data.filter(
        (item) => {
          var _a;
          return (_a = item.label) == null ? void 0 : _a.startsWith("New Tab");
        }
      );
      const count = newTabs.length + 1;
      collectionHook.dispatch({
        type: "add-child-item",
        idRoot,
        element: React.createElement(Tab.Tab, {
          editable: true,
          label: `New Tab ${count}`,
          id: tabId
        }),
        indexPosition: overflowIndicator ? indexPosition - 1 : indexPosition
      });
    },
    [collectionHook, idRoot]
  );
  const selectNewTab = React.useCallback(
    (tabId) => {
      const tab = collectionHook.data.find((item) => item.id === tabId);
      if (tab) {
        selectionHook.activateTab(tab.index);
        if (promptForNewTabName) {
          editableHook.setEditing(true);
        } else {
          keyboardHook.focusTab(tab.index);
        }
      }
    },
    [
      collectionHook.data,
      editableHook,
      keyboardHook,
      promptForNewTabName,
      selectionHook
    ]
  );
  const closeTab = React.useCallback(
    (indexPosition) => {
      if (!collectionHook.isControlled) {
        collectionHook.dispatch({
          type: "remove-item",
          indexPosition
        });
        if (collectionHook.data.length > 1) {
          if (indexPosition === selectionHook.selected && indexPosition === collectionHook.data.length - 1) {
            selectionHook.activateTab(indexPosition - 1);
          }
          onCloseTab == null ? void 0 : onCloseTab(indexPosition);
          if (selectionHook.selected !== null && indexPosition < selectionHook.selected) {
            selectionHook.activateTab(selectionHook.selected - 1);
          }
        }
      } else {
        onCloseTab == null ? void 0 : onCloseTab(indexPosition);
      }
    },
    [collectionHook, onCloseTab, selectionHook]
  );
  React.useEffect(() => {
    if (pendingNewTab.current) {
      const { current: tabId } = pendingNewTab;
      pendingNewTab.current = null;
      selectNewTab(tabId);
    }
  }, [collectionHook.data, promptForNewTabName, selectNewTab]);
  return {
    activateTab: selectionHook.activateTab,
    addTab,
    closeTab,
    containerProps: keyboardHook.containerProps,
    controlledSelection: selectionHook.isControlled,
    editing: editableHook.editing,
    focusTab: keyboardHook.focusTab,
    focusIsWithinComponent: keyboardHook.focusIsWithinComponent,
    focusVisible: keyboardHook.focusVisible,
    highlightedIdx: keyboardHook.highlightedIdx,
    activeTabIndex: selectionHook.selected,
    navigationProps: navigationProps2,
    tabProps,
    ...dragDropHook
  };
};

exports.useTabstrip = useTabstrip;
//# sourceMappingURL=useTabstrip.js.map
