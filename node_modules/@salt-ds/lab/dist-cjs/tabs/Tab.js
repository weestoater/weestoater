'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var core = require('@salt-ds/core');
var icons = require('@salt-ds/icons');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var clsx = require('clsx');
var React = require('react');
var EditableLabel = require('../editable-label/EditableLabel.js');
var Tab$1 = require('./Tab.css.js');

const noop = () => void 0;
const withBaseName = core.makePrefixer("saltTab");
const CloseTabButton = (props) => /* @__PURE__ */ jsxRuntime.jsx(core.Button, {
  ...props,
  "aria-label": "Close Tab (Delete or Backspace)",
  className: withBaseName("closeButton"),
  tabIndex: void 0,
  title: "Close Tab (Delete or Backspace)",
  variant: "secondary",
  children: /* @__PURE__ */ jsxRuntime.jsx(icons.CloseIcon, {
    "aria-label": "Close Tab (Delete or Backspace)",
    className: withBaseName("close-icon")
  })
});
const Tab = React.forwardRef(function Tab2({
  ariaControls,
  children,
  className,
  closeable,
  dragging,
  editable,
  editing,
  focusVisible,
  index,
  label,
  onClick,
  onClose,
  onEnterEditMode = noop,
  onExitEditMode = noop,
  onFocus: onFocusProp,
  onKeyDown,
  onKeyUp,
  onMouseDown,
  orientation,
  selected,
  tabChildIndex = 0,
  tabIndex,
  ...props
}, ref) {
  if (index === void 0 || onClick === void 0 || onKeyDown === void 0) {
    throw Error(
      "index, onClick, onKeyUp, onKeyDown are required props, they would nornally be injected by Tabstrip, are you creating a Tab outside of a Tabstrip"
    );
  }
  const targetWindow = window.useWindow();
  styles.useComponentCssInjection({
    testId: "salt-tab",
    css: Tab$1,
    window: targetWindow
  });
  const root = React.useRef(null);
  const editableRef = React.useRef(null);
  const setForkRef = core.useForkRef(ref, root);
  const [closeHover, setCloseHover] = React.useState(false);
  const handleClick = React.useCallback(
    (e) => {
      if (!editing) {
        e.preventDefault();
        onClick(e, index);
      }
    },
    [editing, index, onClick]
  );
  const handleKeyDownMain = (e) => {
    onKeyDown(e);
  };
  const handleOnExitEditMode = (originalValue = "", editedValue = "", allowDeactivation = true) => onExitEditMode(originalValue, editedValue, allowDeactivation, index);
  const handleKeyUp = (e) => {
    switch (e.key) {
      case "Backspace":
      case "Delete":
        if (closeable && !editing) {
          e.stopPropagation();
          onClose && onClose(index);
        }
        break;
      default:
        onKeyUp && onKeyUp(e, index);
    }
  };
  const handleCloseButtonClick = (e) => {
    e.stopPropagation();
    onClose && onClose(index);
  };
  const handleCloseButtonEnter = () => {
    setCloseHover(true);
  };
  const handleCloseButtonLeave = () => {
    setCloseHover(false);
  };
  const handleMouseDown = (e) => {
    onMouseDown == null ? void 0 : onMouseDown(e);
  };
  const getLabel = () => {
    if (editable) {
      return /* @__PURE__ */ jsxRuntime.jsx(EditableLabel.EditableLabel, {
        editing,
        defaultValue: label,
        onEnterEditMode,
        onExitEditMode: handleOnExitEditMode,
        ref: editableRef
      }, label);
    } else {
      return label;
    }
  };
  const handleFocus = (evt) => {
    if (editableRef.current) {
      const editable2 = editableRef.current;
      const input = editable2.querySelector(
        ".saltEditableLabel-input"
      );
      input == null ? void 0 : input.focus();
    }
    onFocusProp == null ? void 0 : onFocusProp(evt);
  };
  return /* @__PURE__ */ jsxRuntime.jsxs("div", {
    ...props,
    "aria-controls": ariaControls,
    "aria-selected": selected,
    className: clsx.clsx(withBaseName(), {
      [withBaseName("closeable")]: closeable,
      [withBaseName("closeHover")]: closeHover,
      [withBaseName("dragAway")]: dragging,
      [withBaseName("editing")]: editing,
      [withBaseName("vertical")]: orientation === "vertical",
      [`saltFocusVisible`]: focusVisible
    }),
    "data-editable": editable || void 0,
    onClick: handleClick,
    onFocus: handleFocus,
    onKeyDown: handleKeyDownMain,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    ref: setForkRef,
    role: "tab",
    tabIndex,
    children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", {
        className: withBaseName("main"),
        children: /* @__PURE__ */ jsxRuntime.jsx("span", {
          className: withBaseName("text"),
          "data-text": editable ? void 0 : label,
          children: children != null ? children : getLabel()
        })
      }),
      closeable ? /* @__PURE__ */ jsxRuntime.jsx(CloseTabButton, {
        onClick: handleCloseButtonClick,
        onMouseEnter: handleCloseButtonEnter,
        onMouseLeave: handleCloseButtonLeave
      }) : null
    ]
  });
});

exports.Tab = Tab;
//# sourceMappingURL=Tab.js.map
