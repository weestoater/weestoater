'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var core = require('@salt-ds/core');
var clsx = require('clsx');
var React = require('react');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var reactOverflow = require('@fluentui/react-overflow');
var OverflowMenu = require('./OverflowMenu.js');
var TabstripNext$1 = require('./TabstripNext.css.js');
var TabNextContext = require('./TabNextContext.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var clsx__default = /*#__PURE__*/_interopDefaultLegacy(clsx);

const withBaseName = core.makePrefixer("saltTabstripNext");
const TabstripNext = React.forwardRef(
  function TabstripNext2(props, ref) {
    const {
      activeColor = "primary",
      align = "left",
      children,
      className,
      value: valueProp,
      defaultValue,
      onChange,
      onKeyDown,
      style,
      variant = "main",
      ...rest
    } = props;
    const targetWindow = window.useWindow();
    styles.useComponentCssInjection({
      testId: "salt-tabstrip-next",
      css: TabstripNext$1,
      window: targetWindow
    });
    const tabstripRef = React.useRef(null);
    const handleRef = core.useForkRef(tabstripRef, ref);
    const [value, setValue] = core.useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "TabstripNext",
      state: "selected"
    });
    const [focusable, setFocusableState] = React.useState(value);
    const [overflowOpen, setOverflowOpen] = React.useState(false);
    const activate = React.useCallback(
      (event) => {
        const newValue = event.currentTarget.value;
        setValue(newValue);
        if (value !== newValue) {
          onChange == null ? void 0 : onChange(event, { value: newValue });
        }
      },
      [onChange, value, setValue]
    );
    const isActive = React.useCallback(
      (id) => {
        return value === id;
      },
      [value]
    );
    const setFocusable = React.useCallback((id) => {
      setFocusableState(id);
    }, []);
    const isFocusable = React.useCallback(
      (id) => {
        return focusable === id || !focusable;
      },
      [focusable]
    );
    const [tabList, setTabList] = React.useState([]);
    const registerTab = React.useCallback((tab) => {
      setTabList((list) => list.concat([tab]));
    }, []);
    const unregisterTab = React.useCallback((id) => {
      setTabList((list) => list.filter((item) => item.value !== id));
    }, []);
    const handleKeyDown = (event) => {
      var _a, _b, _c, _d, _e, _f;
      if (overflowOpen)
        return;
      const elements = Array.from(
        (_b = (_a = tabstripRef.current) == null ? void 0 : _a.querySelectorAll(
          `div:not([data-overflowing]) > [role="tab"]:not([disabled])`
        )) != null ? _b : []
      );
      const currentIndex = elements.findIndex(
        (element) => element === (targetWindow == null ? void 0 : targetWindow.document.activeElement)
      );
      if (currentIndex < 0)
        return;
      switch (event.key) {
        case "ArrowDown":
        case "ArrowRight":
          (_c = elements[Math.min(currentIndex + 1, elements.length)]) == null ? void 0 : _c.focus();
          break;
        case "ArrowUp":
        case "ArrowLeft":
          (_d = elements[Math.max(0, currentIndex - 1)]) == null ? void 0 : _d.focus();
          break;
        case "Home":
          (_e = elements[0]) == null ? void 0 : _e.focus();
          break;
        case "End":
          (_f = elements[elements.length - 1]) == null ? void 0 : _f.focus();
      }
      onKeyDown == null ? void 0 : onKeyDown(event);
    };
    const handleOverflowItemClick = (event, item) => {
      if (item) {
        setValue(item.value);
        requestAnimationFrame(() => {
          var _a;
          const element = (_a = tabstripRef.current) == null ? void 0 : _a.querySelector(
            `[value="${item.value}"]`
          );
          if (element instanceof HTMLElement) {
            element == null ? void 0 : element.focus();
          }
        });
        if (value !== item.value) {
          onChange == null ? void 0 : onChange(event, { value: item.value });
        }
      }
    };
    const handleOverflowOpenChange = (isOpen) => {
      setOverflowOpen(isOpen);
    };
    const contextValue = React.useMemo(
      () => ({
        activate,
        isActive,
        setFocusable,
        isFocusable,
        registerTab,
        unregisterTab,
        variant,
        activeColor
      }),
      [
        activate,
        isActive,
        setFocusable,
        isFocusable,
        registerTab,
        unregisterTab,
        variant,
        activeColor
      ]
    );
    const tabstripStyle = {
      "--tabstripNext-justifyContent": align,
      ...style
    };
    return /* @__PURE__ */ jsxRuntime.jsx(TabNextContext.TabsContext.Provider, {
      value: contextValue,
      children: /* @__PURE__ */ jsxRuntime.jsx("div", {
        className: clsx__default["default"](withBaseName("container"), withBaseName(variant)),
        children: /* @__PURE__ */ jsxRuntime.jsx(reactOverflow.Overflow, {
          ref: handleRef,
          children: /* @__PURE__ */ jsxRuntime.jsxs("div", {
            role: "tablist",
            className: clsx__default["default"](
              withBaseName(),
              withBaseName("horizontal"),
              className
            ),
            onKeyDown: handleKeyDown,
            style: tabstripStyle,
            ...rest,
            children: [
              children,
              /* @__PURE__ */ jsxRuntime.jsx(OverflowMenu.OverflowMenu, {
                tabs: tabList,
                onOpenChange: handleOverflowOpenChange,
                onSelectionChange: handleOverflowItemClick
              })
            ]
          })
        })
      })
    });
  }
);

exports.TabstripNext = TabstripNext;
//# sourceMappingURL=TabstripNext.js.map
