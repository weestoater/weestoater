'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var collectionItemUtils = require('./utils/collection-item-utils.js');
var filterUtils = require('./utils/filter-utils.js');
var itemToString = require('./itemToString.js');
var collectionProvider = require('./collectionProvider.js');

const defaultCollectionOptions = {};
const useCollectionItems = ({
  children,
  id: idRoot,
  label = "",
  options = defaultCollectionOptions,
  source
}) => {
  var _a;
  const { getItemId } = options;
  const [, forceUpdate] = React.useState(null);
  const inheritedCollectionHook = collectionProvider.useCollection();
  const dataRef = React.useRef([]);
  const flattenedDataRef = React.useRef([]);
  const EMPTY_COLLECTION = React.useMemo(() => [], []);
  const filterPattern = React.useRef((_a = options.filterPattern) != null ? _a : "");
  const {
    getFilterRegex = filterUtils.getDefaultFilterRegex,
    noChildrenLabel,
    itemToString: itemToString$1 = itemToString.itemToString
  } = options;
  const isExpanded = React.useCallback(
    (path) => {
      return options.defaultExpanded || false;
    },
    [options.defaultExpanded]
  );
  const addMetadataToItems = React.useCallback(
    (items, indexer, level = 1, path = "", results = [], flattenedCollection2 = [], flattenedSource2 = []) => {
      items.forEach((item, i, all) => {
        var _a2, _b;
        const isCollapsibleHeader = item.header && options.collapsibleHeaders;
        const isNonCollapsibleGroupNode = item.childNodes && options.collapsibleHeaders === false;
        const isLeaf = !item.childNodes || item.childNodes.length === 0;
        const nonCollapsible = isNonCollapsibleGroupNode || isLeaf && !isCollapsibleHeader;
        const childPath = path ? `${path}.${i}` : `item-${i}`;
        const id = (_a2 = item.id) != null ? _a2 : getItemId ? getItemId(i) : `${idRoot}-${childPath}`;
        const expanded = nonCollapsible ? void 0 : (_b = item.expanded) != null ? _b : isExpanded(id);
        const normalisedItem = {
          ...item,
          childNodes: void 0,
          count: !isNonCollapsibleGroupNode && expanded === void 0 ? 0 : collectionItemUtils.countChildItems(item, all, i),
          description: item.description,
          disabled: collectionItemUtils.isDisabled(item.value),
          focusable: collectionItemUtils.isFocusable(item.value) ? void 0 : false,
          id,
          index: indexer.value,
          expanded,
          level
        };
        results.push(normalisedItem);
        flattenedCollection2.push(normalisedItem);
        flattenedSource2.push(items[i].value);
        indexer.value += 1;
        if (item.childNodes) {
          const [children2] = addMetadataToItems(
            item.childNodes,
            indexer,
            level + 1,
            childPath,
            [],
            flattenedCollection2,
            flattenedSource2
          );
          normalisedItem.childNodes = children2;
        }
      });
      return [results, flattenedSource2, flattenedCollection2];
    },
    [options.collapsibleHeaders, getItemId, idRoot, isExpanded]
  );
  const getFilter = React.useCallback(() => {
    if (filterPattern.current) {
      return filterUtils.getDefaultFilter(filterPattern.current, getFilterRegex);
    } else {
      return null;
    }
  }, [getFilterRegex]);
  const collectVisibleItems = React.useCallback(
    (items, filter = getFilter(), results = [], idx = { value: 0 }) => {
      let skipToNextHeader = false;
      for (const item of items) {
        if (!(skipToNextHeader && !collectionItemUtils.isHeader(item))) {
          if (item.value !== null && (filter === null || filter(itemToString$1(item.value)))) {
            results[idx.value] = item;
            idx.value += 1;
          }
          skipToNextHeader = false;
          if (collectionItemUtils.isHeader(item) && item.expanded === false) {
            skipToNextHeader = true;
          } else if (collectionItemUtils.isGroupNode(item)) {
            if (item.expanded !== false && item.childNodes) {
              collectVisibleItems(item.childNodes, filter, results, idx);
            }
          }
        }
      }
      return results;
    },
    [getFilter, itemToString$1]
  );
  const partialCollectionItems = React.useMemo(() => {
    return inheritedCollectionHook ? EMPTY_COLLECTION : collectionItemUtils.sourceItems(source, { itemToString: itemToString$1, noChildrenLabel }) || collectionItemUtils.childItems(children) || [];
  }, [
    inheritedCollectionHook,
    EMPTY_COLLECTION,
    source,
    itemToString$1,
    noChildrenLabel,
    children
  ]);
  const [collectionItems, flattenedSource, flattenedCollection] = React.useMemo(
    () => inheritedCollectionHook ? [EMPTY_COLLECTION, EMPTY_COLLECTION, EMPTY_COLLECTION] : addMetadataToItems(partialCollectionItems, { value: 0 }),
    [
      EMPTY_COLLECTION,
      addMetadataToItems,
      inheritedCollectionHook,
      partialCollectionItems
    ]
  );
  flattenedDataRef.current = flattenedCollection;
  React.useMemo(
    () => inheritedCollectionHook ? EMPTY_COLLECTION : dataRef.current = collectVisibleItems(collectionItems),
    [
      EMPTY_COLLECTION,
      collectVisibleItems,
      collectionItems,
      inheritedCollectionHook
    ]
  );
  const collectionItemsRef = React.useRef(collectionItems);
  const setFilterPattern = React.useCallback(
    (pattern = "") => {
      if (typeof pattern === "string") {
        filterPattern.current = pattern;
        dataRef.current = collectVisibleItems(collectionItems);
        forceUpdate({});
      }
    },
    [collectionItems, collectVisibleItems]
  );
  const itemById = React.useCallback(
    (id, target = collectionItems) => {
      const sourceWithId = target.find(
        (i) => {
          var _a2;
          return i.id === id || ((_a2 = i == null ? void 0 : i.childNodes) == null ? void 0 : _a2.length) && collectionItemUtils.isParentPath(i.id, id);
        }
      );
      if ((sourceWithId == null ? void 0 : sourceWithId.id) === id) {
        return flattenedSource == null ? void 0 : flattenedSource[sourceWithId.index];
      } else if (sourceWithId) {
        return itemById(id, sourceWithId.childNodes);
      }
      throw Error(`useCollectionData itemById, id ${id} not found `);
    },
    [flattenedSource, collectionItems]
  );
  const toCollectionItem = React.useCallback(
    (item) => {
      const collectionItem = flattenedDataRef.current.find(
        (i) => React.isValidElement(i.value) ? i.label === item : i.value === item
      );
      if (collectionItem) {
        return collectionItem;
      }
      throw Error(`useCollectionData toCollectionItem, item not found `);
    },
    []
  );
  const itemToCollectionItem = React.useCallback(
    (sel) => {
      if (sel === null) {
        return null;
      } else if (Array.isArray(sel)) {
        const result = [];
        for (const item of sel) {
          const collectionItem = toCollectionItem(item);
          result.push(collectionItem);
        }
        return result;
      } else if (sel !== void 0) {
        return toCollectionItem(sel);
      }
      return void 0;
    },
    [toCollectionItem]
  );
  const stringToCollectionItem = React.useCallback(
    (value) => {
      const toCollectionItem2 = (item) => {
        const collectionItem = flattenedDataRef.current.find(
          (i) => React.isValidElement(i.value) ? i.label === item : i.value !== null && itemToString$1(i.value) === item
        );
        if (collectionItem) {
          return collectionItem;
        }
      };
      if (value === null) {
        return null;
      } else if (Array.isArray(value)) {
        const result = [];
        for (const item of value) {
          const collectionItem = toCollectionItem2(item);
          if (collectionItem) {
            result.push(collectionItem);
          }
        }
        return result;
      } else if (value !== void 0) {
        return toCollectionItem2(value);
      }
      return void 0;
    },
    [itemToString$1]
  );
  const itemToId = React.useCallback((item) => {
    for (const collectionItem of collectionItemsRef.current) {
      if (item === collectionItem.value) {
        return collectionItem.id;
      }
    }
    throw Error("useCollectionData itemToId, item not found");
  }, []);
  const collapseGroupItem = React.useCallback(
    (item) => {
      collectionItemsRef.current = collectionItemUtils.replaceCollectionItem(
        collectionItemsRef.current,
        item.id,
        {
          expanded: false
        }
      );
      dataRef.current = collectVisibleItems(collectionItemsRef.current);
      forceUpdate({});
    },
    [collectVisibleItems]
  );
  const expandGroupItem = React.useCallback(
    (item) => {
      collectionItemsRef.current = collectionItemUtils.replaceCollectionItem(
        collectionItemsRef.current,
        item.id,
        {
          expanded: true
        }
      );
      dataRef.current = collectVisibleItems(collectionItemsRef.current);
      forceUpdate({});
    },
    [collectVisibleItems]
  );
  return inheritedCollectionHook || {
    collapseGroupItem,
    data: dataRef.current,
    expandGroupItem,
    setFilterPattern,
    itemById,
    itemToId,
    toCollectionItem,
    itemToCollectionItem,
    stringToCollectionItem
  };
};

exports.useCollectionItems = useCollectionItems;
//# sourceMappingURL=useCollectionItems.js.map
