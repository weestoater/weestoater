'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var core = require('@salt-ds/core');
require('react/jsx-runtime');
var useResizeObserver = require('../responsive/useResizeObserver.js');

const HeightOnly = ["height"];
const HeightWithScroll = ["height", "scrollHeight"];
const EMPTY_ARRAY = [];
const ObservedDimensions = {
  containerOnly: [HeightWithScroll, EMPTY_ARRAY],
  withContent: [HeightOnly, HeightOnly]
};
const getObservedDimensions = (containerOnly) => containerOnly ? ObservedDimensions.containerOnly : ObservedDimensions.withContent;
const NULL_REF = { current: null };
const getItemTop = (element, offsetContainer) => {
  const { transform = "none" } = getComputedStyle(element);
  if (transform.startsWith("matrix")) {
    const pos = transform.lastIndexOf(",");
    return parseInt(transform.slice(pos + 1));
  } else {
    let offsetParent = element.offsetParent;
    if (offsetParent === offsetContainer || offsetContainer === null) {
      return element.offsetTop;
    } else {
      let top = element.offsetTop;
      while (offsetParent !== null && offsetParent !== offsetContainer) {
        top += offsetParent.offsetTop;
        offsetParent = offsetParent.offsetParent;
      }
      return top;
    }
  }
};
const useViewportTracking = ({
  containerRef,
  contentRef = NULL_REF,
  highlightedIdx = -1,
  indexPositions,
  stickyHeaders = false
}) => {
  const scrolling = React.useRef(false);
  const viewport = React.useRef({
    height: 0,
    contentHeight: 0
  });
  const scrollTo = React.useCallback((scrollPos) => {
    scrolling.current = true;
    if (containerRef.current) {
      containerRef.current.scrollTop = scrollPos;
    }
    setTimeout(() => {
      scrolling.current = false;
    });
  }, []);
  const scrollToStart = React.useCallback(() => scrollTo(0), [scrollTo]);
  const scrollToEnd = React.useCallback(() => {
    scrollTo(viewport.current.contentHeight - viewport.current.height);
  }, [scrollTo]);
  const scrollIntoViewIfNeeded = React.useCallback(
    (item) => {
      const offsetContainer = contentRef.current || containerRef.current;
      if (item.id) {
        const el = document.getElementById(item.id);
        if (el && containerRef.current) {
          const { height: viewportHeight } = viewport.current;
          const targetEl = el.ariaExpanded && el.firstChild ? el.firstChild : el;
          const headerHeight = stickyHeaders ? 36 : 0;
          const itemTop = getItemTop(targetEl, offsetContainer);
          const itemHeight = targetEl.offsetHeight;
          const { scrollTop } = containerRef.current;
          const viewportStart = scrollTop + headerHeight;
          const viewportEnd = viewportStart + viewportHeight - headerHeight;
          if (itemTop + itemHeight > viewportEnd || itemTop < viewportStart) {
            const newScrollTop = itemTop + itemHeight > viewportEnd ? scrollTop + (itemTop + itemHeight) - viewportEnd : itemTop - headerHeight;
            scrollTo(newScrollTop);
          }
        }
      }
    },
    [containerRef, contentRef, scrollTo, stickyHeaders]
  );
  core.useIsomorphicLayoutEffect(() => {
    const { height, contentHeight } = viewport.current;
    const item = indexPositions[highlightedIdx];
    if (contentHeight > height && item) {
      const [firstItem] = indexPositions;
      const [lastItem] = indexPositions.slice(-1);
      if (item === firstItem) {
        scrollToStart();
      } else if (item === lastItem) {
        scrollToEnd();
      } else {
        scrollIntoViewIfNeeded(indexPositions[highlightedIdx]);
      }
    }
  }, [
    highlightedIdx,
    indexPositions,
    scrollIntoViewIfNeeded,
    scrollToEnd,
    scrollToStart
  ]);
  const onContainerResize = React.useCallback(
    ({ height, scrollHeight }) => {
      if (typeof height === "number") {
        viewport.current.height = height;
      }
      if (typeof scrollHeight === "number") {
        viewport.current.contentHeight = scrollHeight;
      }
    },
    []
  );
  const onContentResize = React.useCallback(({ height }) => {
    if (typeof height === "number") {
      viewport.current.contentHeight = height;
    }
  }, []);
  const [containerDimensions, contentDimensions] = getObservedDimensions(
    contentRef === NULL_REF
  );
  useResizeObserver.useResizeObserver(containerRef, containerDimensions, onContainerResize, true);
  useResizeObserver.useResizeObserver(contentRef, contentDimensions, onContentResize, true);
  return {
    isScrolling: scrolling,
    scrollIntoView: scrollIntoViewIfNeeded
  };
};

exports.useViewportTracking = useViewportTracking;
//# sourceMappingURL=useViewportTracking.js.map
