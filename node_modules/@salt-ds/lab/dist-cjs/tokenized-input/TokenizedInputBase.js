'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var clsx = require('clsx');
var deepmerge = require('deepmerge');
var React = require('react');
var core = require('@salt-ds/core');
var icons = require('@salt-ds/icons');
var calcFirstHiddenIndex = require('./internal/calcFirstHiddenIndex.js');
var defaultItemToString = require('./internal/defaultItemToString.js');
var InputPill = require('./internal/InputPill.js');
var InputRuler = require('./internal/InputRuler.js');
var useResizeObserver = require('./internal/useResizeObserver.js');
var useWidth = require('./internal/useWidth.js');
var InputLegacy = require('../input-legacy/InputLegacy.js');
require('../input-legacy/StaticInputAdornment.js');
var window = require('@salt-ds/window');
var styles = require('@salt-ds/styles');
var TokenizedInput = require('./TokenizedInput.css.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var deepmerge__default = /*#__PURE__*/_interopDefaultLegacy(deepmerge);

const INITIAL_INPUT_WIDTH = 5;
const withBaseName = core.makePrefixer("saltTokenizedInput");
const getItemsAriaLabel = (itemCount) => itemCount === 0 ? "no item selected" : `${itemCount} ${itemCount > 1 ? "items" : "item"}`;
const hasHelpers = (helpers) => {
  if (process.env.NODE_ENV !== "production") {
    if (helpers == null) {
      console.warn(
        'TokenizedInputBase is used without helpers. You should pass in "helpers" from "useTokenizedInput".'
      );
    }
  }
  return helpers != null;
};
const TokenizedInputBase = React.forwardRef(function TokenizedInputBase2(props, ref) {
  const {
    InputProps: InputProps2 = {},
    ExpandButtonProps = {},
    className,
    activeIndices = [],
    selectedItems = [],
    highlightedIndex,
    value,
    focused,
    expanded,
    disabled,
    helpers,
    onFocus,
    onBlur,
    onKeyUp,
    onKeyDown,
    onRemoveItem,
    onInputChange,
    onInputFocus,
    onInputBlur,
    onInputSelect,
    onClear,
    onClick,
    inputRef,
    itemToString = defaultItemToString.defaultItemToString,
    id: idProp,
    expandButtonRef: expandButtonRefProp,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    ...restProps
  } = props;
  const targetWindow = window.useWindow();
  styles.useComponentCssInjection({
    testId: "salt-tokenized-input",
    css: TokenizedInput,
    window: targetWindow
  });
  const density = core.useDensity();
  const id = core.useId(idProp);
  const inputId = `${id}-input`;
  const expandButtonId = `${id}-expand-button`;
  const clearButtonId = `${id}-clear-button`;
  const pillGroupPadding = 16;
  const pillsRef = React.useRef({});
  const inputRulerRef = React.useRef(null);
  const keydownExpandButton = React.useRef(false);
  const [expandButtonRef, expandButtonWidth] = useWidth.useWidth(density);
  const [clearButtonRef, clearButtonWidth] = useWidth.useWidth(density);
  const [inputWidth, setInputWidth] = React.useState(INITIAL_INPUT_WIDTH);
  const [pillGroupWidth, setPillGroupWidth] = React.useState(null);
  const [firstHiddenIndex, setFirstHiddenIndex] = React.useState(null);
  const showExpandButton = !expanded && firstHiddenIndex != null;
  const widthOffset = pillGroupPadding + INITIAL_INPUT_WIDTH + (expanded ? clearButtonWidth : expandButtonWidth);
  const containerRef = useResizeObserver.useResizeObserver(
    React.useCallback(
      ([{ contentRect }]) => {
        setPillGroupWidth(contentRect.width - widthOffset);
      },
      [widthOffset]
    )
  );
  core.useIsomorphicLayoutEffect(
    () => () => {
      setFirstHiddenIndex(null);
    },
    [density]
  );
  core.useIsomorphicLayoutEffect(
    () => {
      if (expanded) {
        setFirstHiddenIndex(null);
      } else if (pillGroupWidth != null) {
        setFirstHiddenIndex(
          calcFirstHiddenIndex.calcFirstHiddenIndex({
            containerWidth: pillGroupWidth,
            pillWidths: Object.values(pillsRef.current).filter(
              Boolean
            )
          })
        );
      }
    },
    [expanded, pillGroupWidth, selectedItems]
  );
  core.useIsomorphicLayoutEffect(() => {
    if (expanded && inputRulerRef.current) {
      const newInputWidth = inputRulerRef.current.scrollWidth;
      setInputWidth(Math.min(newInputWidth, pillGroupWidth || 0));
    }
  }, [expanded, pillGroupWidth, value]);
  const handleExpandButtonKeyDown = (event) => {
    const singleChar = event.key.length === 1;
    const triggerExpand = [
      "CONTROL",
      "META",
      "ENTER",
      "BACKSPACE",
      "ARROWDOWN",
      "ARROWLEFT",
      "ARROWRIGHT"
    ].indexOf(event.key.toUpperCase()) !== -1;
    if ((singleChar || triggerExpand) && hasHelpers(helpers)) {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        event.stopPropagation();
      }
      helpers.updateExpanded(true);
      keydownExpandButton.current = true;
    }
  };
  const handleInputKeyUp = (event) => {
    if (keydownExpandButton.current && "Enter" !== event.key) {
      keydownExpandButton.current = false;
      if (onKeyDown) {
        onKeyDown(event);
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  };
  const handleExpand = (event) => {
    event.stopPropagation();
    if (hasHelpers(helpers)) {
      helpers.updateExpanded(true);
    }
  };
  const handleClearButtonFocus = (event) => {
    event.stopPropagation();
    if (hasHelpers(helpers)) {
      helpers.setFocused(false);
      helpers.cancelBlur();
    }
  };
  const selectedItemIds = selectedItems.map(
    (_, index) => `${id}-pill-${index}`
  );
  const inputAriaLabelledBy = disabled ? [ariaLabelledBy, inputId, ...selectedItemIds] : [ariaLabelledBy, inputId];
  const mergedInputProps = deepmerge__default["default"](
    {
      inputProps: {
        style: {
          width: inputWidth,
          minWidth: inputWidth
        },
        "aria-label": [ariaLabel, getItemsAriaLabel(selectedItems.length)].filter(Boolean).join(" "),
        "aria-labelledby": inputAriaLabelledBy.filter(Boolean).join(" "),
        "aria-activedescendant": highlightedIndex && highlightedIndex >= 0 ? `${id}-pill-${highlightedIndex}` : void 0
      }
    },
    InputProps2
  );
  const {
    accessibleText: expandButtonAccessibleText,
    ...restExpandButtonProps
  } = ExpandButtonProps;
  return /* @__PURE__ */ jsxRuntime.jsxs("div", {
    ...restProps,
    className: clsx.clsx(
      withBaseName(),
      {
        [withBaseName("focused")]: focused,
        [withBaseName("expanded")]: expanded,
        [withBaseName("disabled")]: disabled
      },
      className
    ),
    id,
    onClick,
    ref: core.useForkRef(ref, containerRef),
    children: [
      /* @__PURE__ */ jsxRuntime.jsx("span", {
        "aria-owns": selectedItemIds.join(" "),
        className: withBaseName("hidden"),
        role: "listbox"
      }),
      /* @__PURE__ */ jsxRuntime.jsxs("div", {
        className: withBaseName("pillGroup"),
        children: [
          selectedItems.map((item, index) => {
            const label = itemToString(item);
            return /* @__PURE__ */ jsxRuntime.jsx(InputPill.InputPill, {
              active: activeIndices.indexOf(index) !== -1,
              disabled,
              hidden: showExpandButton && index >= firstHiddenIndex,
              highlighted: index === highlightedIndex,
              id: `${id}-pill-${index}`,
              index,
              label,
              lastVisible: !showExpandButton && index === selectedItems.length - 1,
              onDelete: expanded ? onRemoveItem : void 0,
              pillsRef
            }, `${index}-${label}`);
          }),
          /* @__PURE__ */ jsxRuntime.jsx(core.Button, {
            "aria-labelledby": [ariaLabelledBy, inputId, expandButtonId].filter(Boolean).join(" "),
            className: clsx.clsx(withBaseName("expandButton"), {
              [withBaseName("hidden")]: !showExpandButton
            }),
            disabled,
            id: expandButtonId,
            onBlur,
            onClick: handleExpand,
            onFocus,
            onKeyDown: handleExpandButtonKeyDown,
            ref: core.useForkRef(expandButtonRef, expandButtonRefProp),
            variant: "secondary",
            ...restExpandButtonProps,
            children: /* @__PURE__ */ jsxRuntime.jsx(icons.OverflowMenuIcon, {
              "aria-label": expandButtonAccessibleText === void 0 ? "expand edit" : expandButtonAccessibleText
            })
          }),
          /* @__PURE__ */ jsxRuntime.jsx(InputLegacy.InputLegacy, {
            ...mergedInputProps,
            className: clsx.clsx(withBaseName("input"), withBaseName("inputField"), {
              [withBaseName("hidden")]: showExpandButton
            }),
            disabled,
            id: inputId,
            onBlur: onInputBlur,
            onChange: onInputChange,
            onFocus: onInputFocus,
            onKeyDown,
            onKeyUp: handleInputKeyUp,
            onSelect: onInputSelect,
            renderSuffix: () => /* @__PURE__ */ jsxRuntime.jsx(InputRuler.InputRuler, {
              ref: inputRulerRef,
              value
            }),
            value,
            ref: inputRef
          })
        ]
      }),
      /* @__PURE__ */ jsxRuntime.jsx(core.Button, {
        className: clsx.clsx(withBaseName("clearButton"), {
          [withBaseName("hidden")]: !expanded || selectedItems.length === 0
        }),
        disabled,
        id: clearButtonId,
        onBlur,
        onClick: onClear,
        onFocus: handleClearButtonFocus,
        ref: clearButtonRef,
        variant: "secondary",
        "data-testid": "clear-button",
        children: /* @__PURE__ */ jsxRuntime.jsx(icons.CloseIcon, {
          "aria-label": "clear input"
        })
      })
    ]
  });
});

exports.TokenizedInputBase = TokenizedInputBase;
//# sourceMappingURL=TokenizedInputBase.js.map
