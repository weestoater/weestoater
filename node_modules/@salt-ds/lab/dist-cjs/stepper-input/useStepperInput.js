'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@salt-ds/core');
var useDynamicAriaLabel = require('./internal/useDynamicAriaLabel.js');
var useSpinner = require('./internal/useSpinner.js');

const stepperDirection = {
  INCREMENT: "increment",
  DECREMENT: "decrement"
};
const ACCEPT_INPUT = /^[-+]?[0-9]*\.?([0-9]+)?/g;
const callAll = (...fns) => (...args) => fns.forEach((fn) => fn && fn(...args));
const toFixedDecimalPlaces = (inputNumber, decimalPlaces) => inputNumber.toFixed(decimalPlaces);
const isAllowedNonNumeric = (inputCharacter) => {
  if (typeof inputCharacter === "number")
    return;
  return "-+".includes(inputCharacter) && inputCharacter.length === 1 || inputCharacter === "";
};
const toFloat = (inputValue) => {
  if (isAllowedNonNumeric(inputValue))
    return 0;
  return parseFloat(inputValue.toString());
};
const santizedInput = (numberString) => (numberString.match(ACCEPT_INPUT) || []).join("");
const getButtonIcon = (type) => type === stepperDirection.INCREMENT ? "triangle-up" : "triangle-down";
const useStepperInput = (props, inputRef) => {
  const {
    block = 10,
    decimalPlaces = 0,
    defaultValue = 0,
    liveValue,
    max = Number.MAX_SAFE_INTEGER,
    min = Number.MIN_SAFE_INTEGER,
    onChange,
    step = 1,
    value,
    InputProps: inputPropsProp = {}
  } = props;
  const [currentValue, setCurrentValue, isControlled] = core.useControlled({
    controlled: value,
    default: toFixedDecimalPlaces(defaultValue, decimalPlaces),
    name: "stepper-input"
  });
  const inputId = core.useId(inputPropsProp.id);
  const isOutOfRange = () => {
    if (currentValue === void 0)
      return true;
    return toFloat(currentValue) > max || toFloat(currentValue) < min;
  };
  const isAtMax = () => {
    if (currentValue === void 0)
      return true;
    return toFloat(currentValue) >= max || max === 0 && currentValue === "";
  };
  const isAtMin = () => {
    if (currentValue === void 0)
      return true;
    return toFloat(currentValue) <= min || min === 0 && currentValue === "";
  };
  const valuesHaveDiverged = () => {
    if (liveValue === void 0 || currentValue === void 0)
      return false;
    return toFloat(toFixedDecimalPlaces(liveValue, decimalPlaces)) !== toFloat(currentValue);
  };
  const { setHasAnnounced } = useDynamicAriaLabel.useDynamicAriaLabel(
    ", value out of date",
    liveValue !== void 0,
    inputRef,
    currentValue,
    valuesHaveDiverged
  );
  const decrement = () => {
    if (currentValue === void 0 || isAtMin())
      return;
    let nextValue = currentValue === "" ? -step : toFloat(currentValue) - step;
    if (max !== void 0 && isOutOfRange())
      nextValue = max;
    setNextValue(nextValue);
  };
  const decrementBlock = () => {
    if (currentValue === void 0 || isAtMin())
      return;
    let nextValue = currentValue === "" ? block * -step : toFloat(currentValue) - step * block;
    if (max !== void 0 && isOutOfRange())
      nextValue = max;
    setNextValue(nextValue);
  };
  const increment = () => {
    if (currentValue === void 0 || isAtMax())
      return;
    let nextValue = currentValue === "" ? step : toFloat(currentValue) + step;
    if (min !== void 0 && isOutOfRange())
      nextValue = min;
    setNextValue(nextValue);
  };
  const incrementBlock = () => {
    if (currentValue === void 0 || isAtMax())
      return;
    let nextValue = currentValue === "" ? block * step : toFloat(currentValue) + step * block;
    if (min !== void 0 && isOutOfRange())
      nextValue = min;
    setNextValue(nextValue);
  };
  const setNextValue = (modifiedValue) => {
    let nextValue = modifiedValue;
    if (nextValue < min)
      nextValue = min;
    if (nextValue > max)
      nextValue = max;
    const roundedValue = toFixedDecimalPlaces(nextValue, decimalPlaces);
    if (isNaN(toFloat(roundedValue)))
      return;
    if (!isControlled) {
      setCurrentValue(roundedValue);
    }
    if (onChange) {
      onChange(roundedValue);
    }
  };
  const { activate: decrementSpinnerBlock, buttonDown: pgDnButtonDown } = useSpinner.useSpinner(decrementBlock, isAtMin());
  const { activate: decrementSpinner, buttonDown: arrowDownButtonDown } = useSpinner.useSpinner(decrement, isAtMin());
  const { activate: incrementSpinnerBlock, buttonDown: pgUpButtonDown } = useSpinner.useSpinner(incrementBlock, isAtMax());
  const { activate: incrementSpinner, buttonDown: arrowUpButtonDown } = useSpinner.useSpinner(increment, isAtMax());
  const handleInputBlur = () => {
    if (currentValue === void 0)
      return;
    const roundedValue = toFixedDecimalPlaces(
      toFloat(currentValue),
      decimalPlaces
    );
    if (currentValue !== "" && !isAllowedNonNumeric(currentValue) && !isControlled) {
      setCurrentValue(roundedValue);
    }
    if (onChange) {
      onChange(roundedValue);
    }
  };
  const handleInputFocus = () => {
    setHasAnnounced(false);
  };
  const handleInputChange = (event) => {
    const changedValue = event.currentTarget.value;
    if (!isControlled) {
      setCurrentValue(santizedInput(changedValue));
    }
    if (onChange) {
      onChange(santizedInput(changedValue));
    }
  };
  const handleInputKeyDown = (event) => {
    if (["ArrowUp", "ArrowDown"].includes(event.key)) {
      event.preventDefault();
      event.key === "ArrowUp" ? incrementSpinner() : decrementSpinner();
    }
    if (["PageUp", "PageDown"].includes(event.key)) {
      event.preventDefault();
      event.key === "PageUp" ? incrementSpinnerBlock() : decrementSpinnerBlock();
    }
  };
  const handleButtonMouseDown = (event, type = stepperDirection.INCREMENT) => {
    if (event.nativeEvent.button !== 0)
      return;
    type === stepperDirection.INCREMENT ? incrementSpinner() : decrementSpinner();
  };
  const handleButtonMouseUp = () => {
    var _a;
    return (_a = inputRef.current) == null ? void 0 : _a.focus();
  };
  const refreshCurrentValue = () => {
    var _a;
    const refreshedcurrentValue = liveValue !== void 0 ? liveValue : defaultValue;
    if (refreshedcurrentValue === void 0)
      return;
    setCurrentValue(
      toFixedDecimalPlaces(toFloat(refreshedcurrentValue), decimalPlaces)
    );
    (_a = inputRef.current) == null ? void 0 : _a.focus();
    if (onChange) {
      onChange(
        toFixedDecimalPlaces(toFloat(refreshedcurrentValue), decimalPlaces)
      );
    }
  };
  const getButtonProps = (type = stepperDirection.INCREMENT, buttonPropsProp = {}) => ({
    "aria-hidden": true,
    "data-testid": `${type}-button`,
    tabIndex: -1,
    ...buttonPropsProp,
    onMouseDown: callAll(
      (event) => handleButtonMouseDown(event, type),
      buttonPropsProp.onMouseDown
    ),
    onMouseUp: callAll(() => handleButtonMouseUp(), buttonPropsProp.onMouseUp)
  });
  const getInputProps = (inputProps = {}) => {
    if (currentValue === void 0)
      return void 0;
    return {
      ...inputProps,
      inputProps: {
        role: "spinbutton",
        "aria-invalid": isOutOfRange(),
        "aria-valuemax": toFloat(toFixedDecimalPlaces(max, decimalPlaces)),
        "aria-valuemin": toFloat(toFixedDecimalPlaces(min, decimalPlaces)),
        "aria-valuenow": toFloat(
          toFixedDecimalPlaces(toFloat(currentValue), decimalPlaces)
        ),
        id: inputId,
        ...inputProps.inputProps
      },
      onBlur: callAll(inputProps.onBlur, handleInputBlur),
      onChange: callAll(inputProps.onChange, handleInputChange),
      onFocus: callAll(inputProps.onFocus, handleInputFocus),
      onKeyDown: callAll(inputProps.onKeyPress, handleInputKeyDown),
      value: String(currentValue)
    };
  };
  return {
    decrementButtonDown: arrowDownButtonDown || pgDnButtonDown,
    getButtonIcon,
    getButtonProps,
    getInputProps,
    incrementButtonDown: arrowUpButtonDown || pgUpButtonDown,
    isAtMax,
    isAtMin,
    refreshCurrentValue,
    stepperDirection,
    valuesHaveDiverged
  };
};

exports.useStepperInput = useStepperInput;
//# sourceMappingURL=useStepperInput.js.map
