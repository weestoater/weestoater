{"version":3,"file":"DescendantContext.js","sources":["../src/button-bar/internal/DescendantContext.tsx"],"sourcesContent":["// Copied from https://gist.github.com/ryanflorence/10e9387f633f9d2e6f444a9bddaabf6e\nimport {\n  createContext,\n  Dispatch,\n  MutableRefObject,\n  ReactNode,\n  SetStateAction,\n  useRef,\n  useState,\n} from \"react\";\nimport { useIsomorphicLayoutEffect } from \"@salt-ds/core\";\n\n// //////////////////////////////////////////////////////////////////////////////\n// SUPER HACKS AHEAD: The React team will hate this enough to hopefully give us\n// a way to know the index of a descendant given a parent (will help generate\n// IDs for accessibility a long with the ability create maximally composable\n// component abstractions).\n//\n// This is all to avoid cloneElement. If we can avoid cloneElement then people\n// can have arbitrary markup around MenuItems.  This basically takes advantage\n// of react's render lifecycles to let us \"register\" descendants to an\n// ancestor, so that we can track all the descendants and manage focus on them,\n// etc.  The super hacks here are for the child to know it's index as well, so\n// that it can set attributes, match against state from above, etc.\ninterface DescendantProviderProps {\n  children?: ReactNode;\n  items: Record<string, any>[];\n  setItems: Dispatch<SetStateAction<Record<string, any>[]>>;\n}\n\ninterface DescendantContextType {\n  assigning?: MutableRefObject<boolean>;\n  setItems?: DescendantProviderProps[\"setItems\"];\n}\nexport const DescendantContext = createContext<DescendantContextType>({});\n\nexport function DescendantProvider({\n  items,\n  setItems,\n  ...props\n}: DescendantProviderProps) {\n  // On the first render we say we're \"assigning\", and the children will push\n  // into the array when they show up in their own useLayoutEffect.\n  const assigning = useRef(true);\n\n  // since children are pushed into the array in useLayoutEffect of the child,\n  // children can't read their index on first render.  So we need to cause a\n  // second render so they can read their index.\n  const [, forceUpdate] = useState<unknown>();\n\n  // parent useLayoutEffect is always last\n  useIsomorphicLayoutEffect(() => {\n    if (assigning.current) {\n      // At this point all of the children have pushed into the array so we set\n      // assigning to false and force an update. Since we're in\n      // useLayoutEffect, we won't get a flash of rendered content, it will all\n      // happen synchronously. And now that this is false, children won't push\n      // into the array on the forceUpdate\n      assigning.current = false;\n      forceUpdate({});\n    } else {\n      // After the forceUpdate completes, we end up here and set assigning back\n      // to true for the next update from the app\n      assigning.current = true;\n    }\n    return () => {\n      // this cleanup function runs right before the next render, so it's the\n      // right time to empty out the array to be reassigned with whatever shows\n      // up next render.\n      if (assigning.current) {\n        // we only want to empty out the array before the next render cycle if\n        // it was NOT the result of our forceUpdate, so being guarded behind\n        // assigning.current works\n        setItems([]);\n      }\n    };\n  }, [items]);\n\n  return (\n    <DescendantContext.Provider {...props} value={{ setItems, assigning }} />\n  );\n}\n"],"names":["createContext","useRef","useState","useIsomorphicLayoutEffect","jsx"],"mappings":";;;;;;;;AAkCa,MAAA,iBAAA,GAAoBA,mBAAqC,CAAA,EAAE,EAAA;AAEjE,SAAS,kBAAmB,CAAA;AAAA,EACjC,KAAA;AAAA,EACA,QAAA;AAAA,EACG,GAAA,KAAA;AACL,CAA4B,EAAA;AAG1B,EAAM,MAAA,SAAA,GAAYC,aAAO,IAAI,CAAA,CAAA;AAK7B,EAAA,MAAM,GAAG,WAAW,CAAA,GAAIC,cAAkB,EAAA,CAAA;AAG1C,EAAAC,8BAAA,CAA0B,MAAM;AAC9B,IAAA,IAAI,UAAU,OAAS,EAAA;AAMrB,MAAA,SAAA,CAAU,OAAU,GAAA,KAAA,CAAA;AACpB,MAAA,WAAA,CAAY,EAAE,CAAA,CAAA;AAAA,KACT,MAAA;AAGL,MAAA,SAAA,CAAU,OAAU,GAAA,IAAA,CAAA;AAAA,KACtB;AACA,IAAA,OAAO,MAAM;AAIX,MAAA,IAAI,UAAU,OAAS,EAAA;AAIrB,QAAA,QAAA,CAAS,EAAE,CAAA,CAAA;AAAA,OACb;AAAA,KACF,CAAA;AAAA,GACF,EAAG,CAAC,KAAK,CAAC,CAAA,CAAA;AAEV,EACE,uBAAAC,cAAA,CAAC,kBAAkB,QAAlB,EAAA;AAAA,IAA4B,GAAG,KAAA;AAAA,IAAO,KAAA,EAAO,EAAE,QAAA,EAAU,SAAU,EAAA;AAAA,GAAG,CAAA,CAAA;AAE3E;;;;;"}