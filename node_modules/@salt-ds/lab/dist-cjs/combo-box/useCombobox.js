'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@salt-ds/core');
var React = require('react');
require('../list/Highlighter.js');
require('../list/ListItem.js');
require('../list/List.js');
var useList = require('../list/useList.js');
require('../list/VirtualizedList.js');
require('../common-hooks/collectionProvider.js');
var itemToString = require('../common-hooks/itemToString.js');
require('../common-hooks/keyUtils.js');
require('react/jsx-runtime');
require('../responsive/useResizeObserver.js');

const NULL_REF = { current: null };
const EnterOnly = ["Enter"];
const useCombobox = ({
  allowFreeText,
  ariaLabel,
  collectionHook,
  defaultIsOpen,
  defaultValue,
  disabled,
  onBlur,
  onFocus,
  onChange,
  onSelect,
  id,
  isOpen: isOpenProp,
  itemToString: itemToString$1 = itemToString.itemToString,
  onOpenChange,
  onSelectionChange,
  selectionStrategy,
  stringToItem,
  value: valueProp,
  InputProps: inputProps = {
    onBlur,
    onFocus,
    onChange,
    onSelect
  }
}) => {
  var _a;
  const isMultiSelect = selectionStrategy === "multiple" || selectionStrategy === "extended";
  const selectedValue = collectionHook.stringToCollectionItem(
    (_a = valueProp != null ? valueProp : defaultValue) != null ? _a : null
  );
  const {
    data: indexPositions,
    itemToCollectionItem,
    setFilterPattern,
    stringToCollectionItem
  } = collectionHook;
  const setHighlightedIndexRef = React.useRef(null);
  const setSelectedRef = React.useRef(null);
  const ignoreSelectOnFocus = React.useRef(true);
  const selectedRef = React.useRef(selectedValue);
  const [isOpen, setIsOpen] = core.useControlled({
    controlled: isOpenProp,
    default: defaultIsOpen != null ? defaultIsOpen : false,
    name: "useDropdownList"
  });
  const [value, setValue] = core.useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : "",
    name: "ComboBox",
    state: "value"
  });
  const collectionItemsToItem = React.useCallback(
    (sel) => {
      if (Array.isArray(sel)) {
        return sel.map((i) => i.value);
      } else if (sel) {
        return sel.value;
      } else {
        return sel;
      }
    },
    []
  );
  const [disableAriaActiveDescendant, setDisableAriaActiveDescendant] = React.useState(true);
  const [quickSelection, setQuickSelection] = React.useState(false);
  const highlightSelectedItem = React.useCallback(
    (selected2 = selectedRef.current) => {
      var _a2, _b;
      if (Array.isArray(selected2)) {
        console.log("TODO multi selection");
      } else if (selected2 == null) {
        (_a2 = setHighlightedIndexRef.current) == null ? void 0 : _a2.call(setHighlightedIndexRef, -1);
      } else {
        const indexOfSelectedItem = indexPositions.indexOf(selected2);
        (_b = setHighlightedIndexRef.current) == null ? void 0 : _b.call(setHighlightedIndexRef, indexOfSelectedItem);
      }
    },
    [indexPositions]
  );
  const setTextValue = React.useCallback(
    (value2) => {
      setValue(value2);
      setFilterPattern(value2 === "" ? void 0 : value2);
    },
    [setFilterPattern, setValue]
  );
  const reconcileInput = React.useCallback(
    (selected2 = selectedRef.current) => {
      var _a2;
      let value2 = "";
      if (Array.isArray(selected2)) {
        console.log("TODO multi selection");
      } else if (selected2 != null && selected2.value !== null) {
        value2 = itemToString$1(selected2.value);
      }
      setTextValue(value2);
      if (value2 === "") {
        (_a2 = setHighlightedIndexRef.current) == null ? void 0 : _a2.call(setHighlightedIndexRef, -1);
      } else {
        highlightSelectedItem(selected2);
      }
    },
    [highlightSelectedItem, itemToString$1, setTextValue]
  );
  const applySelection = React.useCallback(
    (evt, selected2) => {
      if (!isMultiSelect) {
        setIsOpen(false);
      }
      selectedRef.current = selected2;
      reconcileInput(selected2);
      onSelectionChange == null ? void 0 : onSelectionChange(evt, collectionItemsToItem(selected2 != null ? selected2 : null));
    },
    [
      collectionItemsToItem,
      isMultiSelect,
      onSelectionChange,
      reconcileInput,
      setIsOpen
    ]
  );
  const handleSelectionChange = React.useCallback(
    (evt, selected2) => {
      if (!isMultiSelect) {
        const selectedCollectionItem = itemToCollectionItem(selected2);
        applySelection(evt, selectedCollectionItem);
      }
    },
    [applySelection, isMultiSelect, itemToCollectionItem]
  );
  const handleFirstItemSelection = React.useCallback(
    (evt) => {
      if (!allowFreeText && evt.key === "Enter" && quickSelection) {
        const [firstItem] = indexPositions;
        applySelection(evt, firstItem);
      }
    },
    [allowFreeText, applySelection, indexPositions, quickSelection]
  );
  const {
    onKeyDown: inputOnKeyDown,
    onFocus: inputOnFocus,
    onChange: inputOnChange,
    onBlur: inputOnBlur,
    onSelect: inputOnSelect
  } = inputProps;
  const handleInputKeyDown = React.useCallback(
    (evt) => {
      if ("Escape" === evt.key) {
        if (allowFreeText) {
          setTextValue("");
        } else {
          reconcileInput();
        }
      } else if ("Tab" === evt.key) {
        if (!allowFreeText) {
          reconcileInput();
        }
      }
      handleFirstItemSelection(evt);
      inputOnKeyDown == null ? void 0 : inputOnKeyDown(evt);
    },
    [
      allowFreeText,
      handleFirstItemSelection,
      inputOnKeyDown,
      reconcileInput,
      setTextValue
    ]
  );
  const handleKeyboardNavigation = React.useCallback(() => {
    setDisableAriaActiveDescendant(false);
  }, []);
  const {
    focusVisible,
    setHighlightedIndex,
    highlightedIndex,
    listControlProps,
    listHandlers: listHookListHandlers,
    selected,
    setSelected
  } = useList.useList({
    collectionHook,
    defaultHighlightedIndex: -1,
    disableAriaActiveDescendant,
    disableHighlightOnFocus: true,
    disableTypeToSelect: true,
    onKeyboardNavigation: handleKeyboardNavigation,
    onKeyDown: handleInputKeyDown,
    onSelectionChange: handleSelectionChange,
    containerRef: NULL_REF,
    selected: selectedRef.current,
    selectionKeys: EnterOnly,
    selectionStrategy,
    tabToSelect: !isMultiSelect
  });
  setHighlightedIndexRef.current = setHighlightedIndex;
  setSelectedRef.current = setSelected;
  const handleOpenChange = React.useCallback(
    (open) => {
      setIsOpen(open);
      if (!open) {
        setQuickSelection(false);
      }
      onOpenChange == null ? void 0 : onOpenChange(open);
    },
    [onOpenChange, setIsOpen]
  );
  const { onClick: listHandlersOnClick } = listHookListHandlers;
  const handleListClick = React.useCallback(
    (evt) => {
      var _a2;
      (_a2 = document.getElementById(`${id}-input`)) == null ? void 0 : _a2.focus();
      console.log("handle list click");
      listHandlersOnClick == null ? void 0 : listHandlersOnClick(evt);
    },
    [id, listHandlersOnClick]
  );
  const handleInputChange = React.useCallback(
    (evt) => {
      const newValue = evt.target.value;
      setValue(newValue);
      if (newValue == null ? void 0 : newValue.trim().length) {
        setFilterPattern(newValue);
      } else {
        setFilterPattern(void 0);
        if (selectedRef.current !== null) {
          onSelectionChange == null ? void 0 : onSelectionChange(
            evt,
            null
          );
        }
        selectedRef.current = null;
      }
      setIsOpen(true);
      setQuickSelection(newValue.length > 0 && !allowFreeText);
      inputOnChange == null ? void 0 : inputOnChange(evt, newValue);
    },
    [allowFreeText, inputOnChange, setFilterPattern, setIsOpen, setValue]
  );
  const { onFocus: listOnFocus } = listControlProps;
  const handleInputFocus = React.useCallback(
    (evt) => {
      setDisableAriaActiveDescendant(false);
      listOnFocus == null ? void 0 : listOnFocus(evt);
      inputOnFocus == null ? void 0 : inputOnFocus(evt);
    },
    [inputOnFocus, listOnFocus]
  );
  const listFocused = React.useCallback(
    (evt) => {
      const element = evt.relatedTarget;
      return (element == null ? void 0 : element.id) === `${id}-list`;
    },
    [id]
  );
  const selectInputValue = React.useCallback(
    (evt) => {
      var _a2;
      const text = value.trim();
      if (text) {
        const selectedCollectionItem = stringToCollectionItem(
          text
        );
        if (selectedCollectionItem) {
          if (Array.isArray(selectedCollectionItem)) ; else if (selectedCollectionItem !== selected) {
            (_a2 = setSelectedRef.current) == null ? void 0 : _a2.call(setSelectedRef, selectedCollectionItem);
            onSelectionChange == null ? void 0 : onSelectionChange(
              evt,
              selectedCollectionItem.value
            );
          }
        } else if (stringToItem) {
          const item = stringToItem(text);
          if (item) {
            console.log("we have a new item");
          }
        }
      }
    },
    [onSelectionChange, selected, stringToItem, stringToCollectionItem, value]
  );
  const { onBlur: listOnBlur } = listControlProps;
  const handleInputBlur = React.useCallback(
    (evt) => {
      if (listFocused(evt)) ; else {
        listOnBlur == null ? void 0 : listOnBlur(evt);
        inputOnBlur == null ? void 0 : inputOnBlur(evt);
        if (allowFreeText) {
          selectInputValue(evt);
        } else {
          reconcileInput();
        }
        setDisableAriaActiveDescendant(true);
        ignoreSelectOnFocus.current = true;
      }
    },
    [
      allowFreeText,
      listFocused,
      inputOnBlur,
      listOnBlur,
      reconcileInput,
      selectInputValue
    ]
  );
  const handleInputSelect = React.useCallback(
    (event) => {
      if (ignoreSelectOnFocus.current) {
        ignoreSelectOnFocus.current = false;
      } else {
        setDisableAriaActiveDescendant(true);
      }
      inputOnSelect == null ? void 0 : inputOnSelect(event);
    },
    [inputOnSelect]
  );
  React.useEffect(() => {
    highlightSelectedItem();
    if (indexPositions.length === 0) {
      setIsOpen(false);
    }
  }, [highlightSelectedItem, indexPositions.length, setIsOpen]);
  const mergedInputProps = {
    ...inputProps.inputProps,
    "aria-label": ariaLabel
  };
  return {
    focusVisible,
    highlightedIndex,
    isOpen,
    onOpenChange: handleOpenChange,
    inputProps: {
      ...inputProps,
      id: `${id}-input`,
      inputProps: mergedInputProps,
      onChange: handleInputChange,
      onSelect: handleInputSelect,
      role: "combobox",
      value
    },
    listControlProps: {
      ...listControlProps,
      onBlur: handleInputBlur,
      onFocus: handleInputFocus
    },
    listHandlers: {
      ...listHookListHandlers,
      onClick: handleListClick
    },
    selected
  };
};

exports.useCombobox = useCombobox;
//# sourceMappingURL=useCombobox.js.map
