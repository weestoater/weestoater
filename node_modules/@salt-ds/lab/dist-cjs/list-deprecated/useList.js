'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@salt-ds/core');
var React = require('react');

function useList(props = {}) {
  validateProps(props);
  const generatedId = core.useId(props.id);
  const {
    id = generatedId,
    source = [],
    itemCount = source.length,
    getItemId = (index) => `${id}-item-${index}`,
    getItemAtIndex: getItemAtIndexProp,
    getItemIndex: getItemIndexProp,
    displayedItemCount = 10,
    initialSelectedItem,
    selectionVariant,
    disabled = false,
    onBlur,
    onChange,
    onFocus,
    onKeyDown,
    onMouseDown,
    onMouseLeave,
    onSelect,
    disableMouseDown,
    restoreLastFocus,
    highlightedIndex: highlightedIndexProp,
    selectedItem: selectedItemProp,
    tabToSelect,
    ...restProps
  } = props;
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = core.useIsFocusVisible();
  const { current: isDeselectable } = React.useRef(
    selectionVariant === "deselectable"
  );
  const { current: isMultiSelect } = React.useRef(
    selectionVariant === "multiple" || selectionVariant === "extended" || Array.isArray(initialSelectedItem) || Array.isArray(selectedItemProp)
  );
  const { current: isExtendedSelect } = React.useRef(selectionVariant === "extended");
  let getItemIndex = React.useCallback(
    (item) => source.indexOf(item),
    [source]
  );
  let getItemAtIndex = React.useCallback((index) => source[index], [source]);
  const indexComparator = React.useCallback(
    (a, b) => getItemIndex(a) - getItemIndex(b),
    [getItemIndex]
  );
  if (typeof getItemIndexProp === "function" && typeof getItemAtIndexProp === "function") {
    getItemIndex = getItemIndexProp;
    getItemAtIndex = getItemAtIndexProp;
  }
  const rootRef = React.useRef();
  const [focusVisible, setFocusVisible] = React.useState(false);
  const [lastFocusedIndex, setLastFocusedIndex] = React.useState(-1);
  const [selectedItem, setSelectedItem] = core.useControlled({
    controlled: selectedItemProp,
    default: initialSelectedItem != null ? initialSelectedItem : isMultiSelect ? [] : null,
    name: "useList",
    state: "selectedItem"
  });
  const [highlightedIndex, setHighlightedIndex] = core.useControlled({
    controlled: highlightedIndexProp,
    default: void 0,
    name: "useList",
    state: "highlightedIndex"
  });
  const handleSingleSelect = React.useCallback(
    (event, index, item) => {
      const isSelected = item === selectedItem;
      let nextItem;
      if (isSelected && !isDeselectable) {
        return;
      }
      if (!isSelected) {
        nextItem = item;
        setHighlightedIndex(index);
      } else {
        nextItem = null;
      }
      setSelectedItem(
        nextItem
      );
      if (onChange) {
        onChange(
          event,
          nextItem
        );
      }
    },
    [
      isDeselectable,
      onChange,
      selectedItem,
      setHighlightedIndex,
      setSelectedItem
    ]
  );
  const handleMultiSelect = React.useCallback(
    (event, index, item) => {
      const isSelected = selectedItem.indexOf(item) !== -1;
      let nextItems = selectedItem;
      if (!isSelected) {
        nextItems = nextItems.concat([item]).sort(indexComparator);
        setHighlightedIndex(index);
      } else {
        nextItems = nextItems.filter((selected) => selected !== item);
      }
      setSelectedItem(
        nextItems
      );
      if (onChange) {
        onChange(
          event,
          nextItems
        );
      }
    },
    [
      indexComparator,
      onChange,
      selectedItem,
      setHighlightedIndex,
      setSelectedItem
    ]
  );
  const handleRangeSelect = React.useCallback(
    (event, index) => {
      var _a;
      const currentSelection = event.ctrlKey || event.metaKey ? selectedItem : [];
      const lastSelectedItemIndex = selectedItem.length > 0 ? getItemIndex(
        selectedItem[selectedItem.length - 1]
      ) : 0;
      const startRegion = Math.min(
        index != null ? index : lastSelectedItemIndex,
        lastSelectedItemIndex
      );
      const endRegion = Math.max(
        index != null ? index : lastSelectedItemIndex,
        lastSelectedItemIndex
      );
      const rangeSelection = source.slice(startRegion, endRegion + 1);
      const nextItems = [
        .../* @__PURE__ */ new Set([...currentSelection, ...rangeSelection])
      ];
      (_a = core.ownerDocument(event.currentTarget).getSelection()) == null ? void 0 : _a.removeAllRanges();
      setSelectedItem(
        nextItems
      );
      if (onChange) {
        onChange(
          event,
          nextItems
        );
      }
    },
    [getItemIndex, onChange, selectedItem, setSelectedItem, source]
  );
  const handleExtendedSelect = React.useCallback(
    (event, index, item) => {
      let nextItems = selectedItem;
      if (event.shiftKey) {
        handleRangeSelect(event, index);
      } else if (selectedItem.length === 0 || event.ctrlKey || event.metaKey) {
        console.log("handleMulti");
        handleMultiSelect(event, index, item);
      } else {
        nextItems = [item];
        setSelectedItem(
          nextItems
        );
        if (onChange) {
          onChange(
            event,
            nextItems
          );
        }
      }
    },
    [
      handleMultiSelect,
      handleRangeSelect,
      onChange,
      selectedItem,
      setSelectedItem
    ]
  );
  const handleSelect = React.useCallback(
    (event, index, item) => {
      if (item == null || item.disabled) {
        return;
      }
      if (onSelect) {
        console.log("onSelect");
        onSelect(event, item);
      }
      if (isExtendedSelect) {
        handleExtendedSelect(event, index, item);
      } else if (isMultiSelect) {
        handleMultiSelect(event, index, item);
      } else {
        handleSingleSelect(event, index, item);
      }
    },
    [
      handleExtendedSelect,
      handleMultiSelect,
      handleSingleSelect,
      isExtendedSelect,
      isMultiSelect,
      onSelect
    ]
  );
  const saveFocusedIndex = (index) => {
    setLastFocusedIndex(index);
    return index;
  };
  const keyDownHandlers = {
    ArrowUp: (event) => {
      event.preventDefault();
      setHighlightedIndex(
        (prevHighlightedIndex) => saveFocusedIndex(Math.max(0, (prevHighlightedIndex != null ? prevHighlightedIndex : itemCount) - 1))
      );
    },
    ArrowDown: (event) => {
      event.preventDefault();
      setHighlightedIndex(
        (prevHighlightedIndex) => saveFocusedIndex(
          Math.min(itemCount - 1, (prevHighlightedIndex != null ? prevHighlightedIndex : -1) + 1)
        )
      );
    },
    PageUp: (event) => {
      event.preventDefault();
      setHighlightedIndex(
        (prevHighlightedIndex) => saveFocusedIndex(
          Math.max(
            0,
            (prevHighlightedIndex != null ? prevHighlightedIndex : displayedItemCount) - displayedItemCount
          )
        )
      );
    },
    PageDown: (event) => {
      event.preventDefault();
      setHighlightedIndex(
        (prevHighlightedIndex) => saveFocusedIndex(
          Math.min(
            itemCount - 1,
            (prevHighlightedIndex != null ? prevHighlightedIndex : 0) + displayedItemCount
          )
        )
      );
    },
    Home: (event) => {
      event.preventDefault();
      setHighlightedIndex(saveFocusedIndex(0));
    },
    End: (event) => {
      event.preventDefault();
      setHighlightedIndex(saveFocusedIndex(itemCount - 1));
    },
    Enter: (event) => {
      event.preventDefault();
      handleSelect(
        event,
        highlightedIndex,
        highlightedIndex != null && highlightedIndex > -1 ? getItemAtIndex(highlightedIndex) : null
      );
    },
    " ": (event) => {
      event.preventDefault();
      handleSelect(
        event,
        highlightedIndex,
        highlightedIndex != null && highlightedIndex > -1 ? getItemAtIndex(highlightedIndex) : null
      );
    },
    Tab: (event) => {
      if (tabToSelect) {
        handleSelect(
          event,
          highlightedIndex,
          highlightedIndex != null && highlightedIndex > -1 ? getItemAtIndex(highlightedIndex) : null
        );
      } else {
        setHighlightedIndex(void 0);
      }
    }
  };
  const handleKeyDown = (event) => {
    if (isFocusVisibleRef.current) {
      setFocusVisible(true);
    }
    const handler = keyDownHandlers[event.key];
    if (handler) {
      handler(event);
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleFocus = (event) => {
    handleFocusVisible(event);
    if (isFocusVisibleRef.current) {
      setFocusVisible(true);
    }
    if (highlightedIndex === void 0) {
      const firstSelectedItem = isMultiSelect ? selectedItem[0] : selectedItem;
      setHighlightedIndex(
        Math.max(
          restoreLastFocus ? lastFocusedIndex : firstSelectedItem ? getItemIndex(firstSelectedItem) : -1,
          0
        )
      );
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  const handleBlur = (event) => {
    setHighlightedIndex(void 0);
    handleBlurVisible();
    if (!isFocusVisibleRef.current) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  };
  const handleMouseDown = (event) => {
    if (disableMouseDown) {
      event.preventDefault();
    } else if (onMouseDown) {
      onMouseDown(event);
    }
  };
  const handleMouseLeave = (event) => {
    if (focusVisible && id) {
      const rootNode = (rootRef.current || core.ownerDocument(event.currentTarget)).getRootNode();
      const listNode = rootNode.getElementById(id);
      if (listNode == null ? void 0 : listNode.contains(event.target)) {
        setHighlightedIndex(void 0);
      }
    } else {
      setHighlightedIndex(void 0);
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  };
  const eventHandlers = {
    onFocus: handleFocus,
    onBlur: handleBlur,
    onKeyDown: handleKeyDown,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave
  };
  const ariaProps = {
    role: "listbox",
    "aria-activedescendant": highlightedIndex !== void 0 && highlightedIndex >= 0 ? getItemId(highlightedIndex) : void 0
  };
  if (isMultiSelect) {
    ariaProps["aria-multiselectable"] = true;
  }
  return {
    focusedRef: core.useForkRef(rootRef, focusVisibleRef),
    state: {
      id,
      focusVisible,
      selectedItem,
      highlightedIndex,
      isDeselectable,
      isMultiSelect,
      isDisabled: disabled
    },
    helpers: {
      setFocusVisible,
      setSelectedItem,
      setHighlightedIndex,
      keyDownHandlers,
      handleSelect
    },
    listProps: {
      id,
      source,
      itemCount,
      disableMouseDown,
      displayedItemCount,
      getItemAtIndex,
      getItemIndex,
      getItemId,
      disabled,
      ...ariaProps,
      ...restProps,
      ...disabled ? {} : eventHandlers
    }
  };
}
const validateProps = (props) => {
  if (process.env.NODE_ENV !== "production") {
    const { source, itemCount, getItemIndex, getItemAtIndex } = props;
    const hasIndexer = typeof getItemIndex === "function" && typeof getItemAtIndex === "function";
    const hasNoIndexer = getItemIndex === void 0 && getItemAtIndex === void 0;
    const sourceNotArray = !Array.isArray(source);
    React.useEffect(() => {
      if (sourceNotArray) {
        console.error("`source` for useList must be an array.");
      }
    }, [sourceNotArray]);
    React.useEffect(() => {
      if (!hasNoIndexer && !hasIndexer) {
        console.error(
          "useList needs to have both `getItemIndex` and `getItemAtIndex`."
        );
      }
      if (!hasNoIndexer && itemCount === void 0) {
        console.error(
          "useList needs to have `itemCount` if an indexer is used."
        );
      }
    }, [hasIndexer, hasNoIndexer, itemCount]);
  }
};

exports.useList = useList;
//# sourceMappingURL=useList.js.map
