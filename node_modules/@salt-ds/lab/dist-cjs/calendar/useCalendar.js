'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var date = require('@internationalized/date');
var core = require('@salt-ds/core');
var React = require('react');
var useSelection = require('./useSelection.js');

const defaultIsDayUnselectable = () => false;
const defaultIsDayHighlighted = () => false;
const defaultIsDayDisabled = () => false;
function useCalendar(props) {
  const {
    selectedDate,
    defaultSelectedDate,
    visibleMonth: visibleMonthProp,
    hideYearDropdown,
    hideOutOfRangeDates,
    defaultVisibleMonth = date.today(date.getLocalTimeZone()),
    onSelectedDateChange,
    onVisibleMonthChange,
    isDayUnselectable = defaultIsDayUnselectable,
    isDayHighlighted = defaultIsDayHighlighted,
    isDayDisabled = defaultIsDayDisabled,
    minDate = hideYearDropdown ? date.startOfYear(date.today(date.getLocalTimeZone())) : void 0,
    maxDate = hideYearDropdown ? date.endOfYear(date.today(date.getLocalTimeZone())) : void 0,
    selectionVariant,
    onHoveredDateChange,
    hoveredDate
  } = props;
  const [visibleMonth, setVisibleMonthState] = core.useControlled({
    controlled: visibleMonthProp ? date.startOfMonth(visibleMonthProp) : void 0,
    default: date.startOfMonth(defaultVisibleMonth),
    name: "Calendar",
    state: "visibleMonth"
  });
  const isOutsideAllowedDates = React.useCallback(
    (date) => {
      return minDate != null && date.compare(minDate) < 0 || maxDate != null && date.compare(maxDate) > 0;
    },
    [maxDate, minDate]
  );
  const isOutsideAllowedMonths = (date$1) => {
    return minDate != null && date.endOfMonth(date$1).compare(minDate) < 0 || maxDate != null && date.startOfMonth(date$1).compare(maxDate) > 0;
  };
  const isOutsideAllowedYears = (date$1) => {
    return minDate != null && date.endOfYear(date$1).compare(minDate) < 0 || maxDate != null && date.startOfYear(date$1).compare(maxDate) > 0;
  };
  const isDaySelectable = React.useCallback(
    (date) => !(date && (isDayUnselectable(date) || isDayDisabled(date) || isOutsideAllowedDates(date))),
    [isDayUnselectable, isDayDisabled, isOutsideAllowedDates]
  );
  const selectionManager = useSelection.useSelectionCalendar({
    defaultSelectedDate,
    selectedDate,
    onSelectedDateChange,
    startDateOffset: props.selectionVariant === "offset" ? props.startDateOffset : (date) => date,
    endDateOffset: props.selectionVariant === "offset" ? props.endDateOffset : (date) => date,
    isDaySelectable,
    selectionVariant,
    onHoveredDateChange,
    hoveredDate
  });
  const [calendarFocused, setCalendarFocused] = React.useState(false);
  const [focusedDate, setFocusedDateState] = React.useState(
    date.startOfMonth(visibleMonth)
  );
  const isDayVisible = React.useCallback(
    (date$1) => {
      const startInsideDays = date.startOfMonth(visibleMonth);
      if (date$1.compare(startInsideDays) < 0)
        return false;
      const endInsideDays = date.endOfMonth(visibleMonth);
      return !(date$1.compare(endInsideDays) > 0);
    },
    [visibleMonth]
  );
  const setVisibleMonth = React.useCallback(
    (event, newVisibleMonth) => {
      setVisibleMonthState(newVisibleMonth);
      onVisibleMonthChange == null ? void 0 : onVisibleMonthChange(event, newVisibleMonth);
    },
    [onVisibleMonthChange, setVisibleMonthState]
  );
  const setFocusedDate = React.useCallback(
    (event, date$1) => {
      if (date.isSameDay(date$1, focusedDate) || isOutsideAllowedDates(date$1))
        return;
      setFocusedDateState(date$1);
      const shouldTransition = !isDayVisible(date$1) && isDaySelectable(date$1) && !isOutsideAllowedDates(date$1);
      if (shouldTransition) {
        setVisibleMonth(event, date.startOfMonth(date$1));
      }
    },
    [
      focusedDate,
      isDaySelectable,
      isDayVisible,
      isOutsideAllowedDates,
      setVisibleMonth
    ]
  );
  React.useEffect(() => {
    if (!isDayVisible(focusedDate)) {
      setFocusedDateState(date.startOfMonth(visibleMonth));
    }
  }, [isDayVisible, focusedDate, visibleMonth]);
  return {
    state: {
      visibleMonth,
      focusedDate,
      minDate,
      maxDate,
      selectionVariant,
      hideOutOfRangeDates,
      calendarFocused,
      ...selectionManager.state
    },
    helpers: {
      setVisibleMonth,
      setFocusedDate,
      setCalendarFocused,
      isDayUnselectable,
      isDayHighlighted,
      isDayDisabled,
      isDayVisible,
      isOutsideAllowedDates,
      isOutsideAllowedMonths,
      isOutsideAllowedYears,
      ...selectionManager.helpers
    }
  };
}

exports.useCalendar = useCalendar;
//# sourceMappingURL=useCalendar.js.map
