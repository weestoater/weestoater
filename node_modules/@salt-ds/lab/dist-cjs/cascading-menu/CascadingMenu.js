'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var core = require('@salt-ds/core');
var useEventCallback = require('../utils/useEventCallback.js');
var CascadingMenuList = require('./CascadingMenuList.js');
var CascadingMenuAction = require('./internal/CascadingMenuAction.js');
var menuPositioning = require('./internal/menuPositioning.js');
var stateUtils = require('./internal/stateUtils.js');
var useClickAway = require('./internal/useClickAway.js');
var useMenuTriggerHandlers = require('./internal/useMenuTriggerHandlers.js');
var useRefsManager = require('./internal/useRefsManager.js');
var useStateReducer = require('./internal/useStateReducer.js');
var stateChangeTypes = require('./stateChangeTypes.js');

const defaultItemToString = (item) => (item == null ? void 0 : item.title) || String(item);
const noop = () => void 0;
const CascadingMenu = React.forwardRef(
  function CascadingMenu2(props, ref) {
    const {
      children,
      className,
      initialSource: initialSourceProp,
      itemToString = defaultItemToString,
      onClose,
      onItemClick,
      onOpen,
      maxWidth = 544,
      minWidth = 200,
      delay = 300,
      rowHeight,
      tooltipEnterDelay = 1500,
      tooltipLeaveDelay = 0,
      height,
      rootPlacement,
      rootPlacementOffset,
      menuTriggerRef: anchorRefProp,
      open: openProp,
      getScreenBounds = menuPositioning.defaultGetScreenBounds,
      disableMouseOutInteractions,
      disableClickAway,
      containingDocument = globalThis.document,
      source: sourceProp
    } = props;
    const density = core.useDensity();
    const refsManager = useRefsManager.useRefsManager();
    const childrenRef = React.useRef(null);
    const getMenuTriggerRef = React.useCallback(
      () => anchorRefProp || childrenRef.current,
      [anchorRefProp]
    );
    const [menuSource] = core.useControlled({
      controlled: sourceProp,
      default: initialSourceProp,
      name: "CascadingMenu",
      state: "source"
    });
    const [isNavigatingWithKeyboard, setIsNavigatingWithKeyboard] = React.useState(false);
    const menusDataById = React.useMemo(
      () => menuSource ? stateUtils.deriveFlatStateFromTree(menuSource) : {},
      [menuSource]
    );
    const rootMenuId = React.useMemo(
      () => Object.keys(menusDataById).find((id) => menusDataById[id].level === 0),
      [menusDataById]
    );
    const stateReducer = useStateReducer.useStateReducer(
      menusDataById,
      isNavigatingWithKeyboard
    );
    const [state, dispatch] = React.useReducer(stateReducer, []);
    const rootMenuState = state[0];
    const prevState = core.usePrevious(state, void 0, []);
    const prevRootMenuState = prevState == null ? void 0 : prevState[0];
    React.useEffect(() => {
      if (!!rootMenuState !== !!prevRootMenuState) {
        if (!rootMenuState) {
          onClose == null ? void 0 : onClose();
        } else if (rootMenuState) {
          onOpen == null ? void 0 : onOpen();
        }
      }
    });
    const openCloseMenu = React.useCallback(
      (open) => dispatch({
        type: open ? CascadingMenuAction.CascadingMenuAction.OPEN_MENU : CascadingMenuAction.CascadingMenuAction.CLOSE_CASCADING_MENU,
        cause: stateChangeTypes.stateChangeTypes.MOUSE_TOGGLE,
        targetId: rootMenuId
      }),
      [rootMenuId]
    );
    React.useEffect(() => {
      if (openProp !== void 0 && openProp !== !!rootMenuState) {
        openCloseMenu(openProp);
      }
    });
    const clickAwayNodes = disableClickAway ? null : () => [getMenuTriggerRef(), ...refsManager.values()].filter(
      (node) => node !== null
    );
    useClickAway.useClickAway(
      clickAwayNodes,
      containingDocument,
      () => {
        dispatch({
          type: CascadingMenuAction.CascadingMenuAction.CLOSE_CASCADING_MENU,
          cause: stateChangeTypes.stateChangeTypes.CLICKED_AWAY,
          targetId: rootMenuId
        });
      },
      () => {
        setIsNavigatingWithKeyboard(false);
      }
    );
    const handleResize = useEventCallback.useEventCallback(() => {
      if (rootMenuState) {
        dispatch({
          type: CascadingMenuAction.CascadingMenuAction.CLOSE_CASCADING_MENU,
          cause: stateChangeTypes.stateChangeTypes.ON_RESIZE,
          targetId: rootMenuId
        });
      }
    });
    React.useEffect(() => {
      const win = core.ownerWindow(getMenuTriggerRef());
      win.addEventListener("resize", handleResize);
      return () => {
        win.removeEventListener("resize", handleResize);
      };
    }, [getMenuTriggerRef, handleResize]);
    const onItemClickCallback = React.useCallback(
      (sourceItem, event) => {
        onItemClick == null ? void 0 : onItemClick(sourceItem, event);
        if (!isNavigatingWithKeyboard) {
          dispatch({
            type: CascadingMenuAction.CascadingMenuAction.CLOSE_CASCADING_MENU,
            cause: stateChangeTypes.stateChangeTypes.ITEM_CLICKED,
            targetId: rootMenuId
          });
        }
      },
      [isNavigatingWithKeyboard, onItemClick, rootMenuId]
    );
    const setMenuTriggerRef = React.useCallback((node) => {
      childrenRef.current = node;
    }, []);
    const handleRef = core.useForkRef(
      React.isValidElement(children) ? children.ref : noop,
      setMenuTriggerRef
    );
    const [onMenuTriggerClick, onMenuTriggerKeydown] = useMenuTriggerHandlers.useMenuTriggerHandlers({
      dispatch,
      children,
      setIsNavigatingWithKeyboard,
      openCloseMenu,
      rootMenuState,
      rootMenuId,
      menusDataById
    });
    const cloneMenuChildren = (cloneChildren) => {
      if (React.isValidElement(cloneChildren)) {
        const childrenProps = {
          ...cloneChildren.props
        };
        if (openProp === void 0) {
          childrenProps.onClick = onMenuTriggerClick;
          childrenProps.onKeyDown = onMenuTriggerKeydown;
        }
        return React.cloneElement(cloneChildren, {
          ref: handleRef,
          ...childrenProps
        });
      }
      return null;
    };
    const clonedChildren = cloneMenuChildren(children);
    const commonMenuProps = {
      className,
      delay,
      itemToString,
      maxWidth,
      minWidth,
      onItemClick: onItemClickCallback,
      dispatch,
      isNavigatingWithKeyboard,
      setIsNavigatingWithKeyboard,
      menusDataById,
      tooltipEnterDelay,
      tooltipLeaveDelay,
      rootPlacement,
      rootPlacementOffset,
      getScreenBounds,
      disableMouseOutInteractions
    };
    React.useEffect(() => {
      if (!openProp) {
        setIsNavigatingWithKeyboard(false);
      }
    }, [openProp, rootPlacementOffset]);
    return Object.keys(menusDataById).length > 0 ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
      children: [
        clonedChildren || null,
        Object.values(state).map((menuState) => {
          const data = menusDataById[menuState.id];
          const isRoot = data.level === 0;
          const parentElement = isRoot ? getMenuTriggerRef() : refsManager.get(data.parentId);
          const isChildMenuOpen = !!state[data.level + 1];
          return /* @__PURE__ */ React.createElement(CascadingMenuList.CascadingMenuList, {
            ...commonMenuProps,
            data,
            height,
            highlightedItemIndex: menuState.highlightedItemIndex,
            isChildMenuOpen,
            isRoot,
            key: `${density}${menuState.id}`,
            menuId: menuState.id,
            menuTriggerRef: getMenuTriggerRef(),
            parentElement,
            ref: isRoot ? ref : null,
            refsManager,
            rowHeight
          });
        })
      ]
    }) : null;
  }
);

exports.CascadingMenu = CascadingMenu;
//# sourceMappingURL=CascadingMenu.js.map
