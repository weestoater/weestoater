'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var core = require('@salt-ds/core');
var clsx = require('clsx');
var React = require('react');
var Portal = require('../portal/Portal.js');
var List = require('../list-deprecated/List.js');
require('../list-deprecated/ListBase.js');
require('../list-deprecated/ListItemBase.js');
require('../list-deprecated/ListItem.js');
require('../list-deprecated/ListItemContext.js');
require('../list-deprecated/ListStateContext.js');
var CascadingMenuItem = require('./CascadingMenuItem.js');
var CascadingMenuAction = require('./internal/CascadingMenuAction.js');
var keydownHandlers = require('./internal/keydownHandlers.js');
var menuPositioning = require('./internal/menuPositioning.js');
var stateUtils = require('./internal/stateUtils.js');
var useMouseHandlers = require('./internal/useMouseHandlers.js');
var stateChangeTypes = require('./stateChangeTypes.js');
var WindowContext = require('../window/WindowContext.js');
require('../window/ElectronWindow.js');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var CascadingMenuList$1 = require('./CascadingMenuList.css.js');

const CascadingMenuList = React.forwardRef(function CascadingMenuList2(props, ref) {
  const {
    className,
    maxWidth,
    minWidth,
    itemToString,
    onItemClick,
    refsManager: refsManager2,
    dispatch,
    rowHeight: rowHeightProp,
    isNavigatingWithKeyboard,
    data,
    tooltipEnterDelay,
    tooltipLeaveDelay,
    height: heightProp,
    isChildMenuOpen,
    isRoot,
    highlightedItemIndex,
    menuId,
    parentElement = null,
    getScreenBounds,
    disableMouseOutInteractions,
    rootPlacementOffset,
    rootPlacement = "bottom-start"
  } = props;
  const targetWindow = window.useWindow();
  styles.useComponentCssInjection({
    testId: "salt-cascading-menu-list",
    css: CascadingMenuList$1,
    window: targetWindow
  });
  const baseClass = "saltCascadingMenuList";
  const [menuRef, setInternalMenuRef] = React.useState(null);
  const setMenuRef = React.useCallback(
    (node) => {
      refsManager2.set(menuId, node);
    },
    [refsManager2, menuId]
  );
  const sizeStackable = 36;
  const defaultRowHeight = sizeStackable;
  const spacing = 8;
  const isMenuActiveState = React.useState(true);
  const [isMenuActive, setIsMenuActive] = isMenuActiveState;
  const listRef = core.useForkRef(ref, setInternalMenuRef);
  const handleRef = core.useForkRef(setMenuRef, listRef);
  React.useEffect(() => {
    if (menuRef && menuRef.focus) {
      const id = setTimeout(() => {
        menuRef.focus();
      });
      return () => {
        clearTimeout(id);
      };
    }
  }, [menuRef, rootPlacementOffset]);
  const handleKeyDown = keydownHandlers.getKeyDownHandlers(props, setIsMenuActive);
  const onFocusHandler = React.useCallback(() => {
    setIsMenuActive(true);
    if (isNavigatingWithKeyboard) {
      if (!highlightedItemIndex) {
        dispatch({
          type: CascadingMenuAction.CascadingMenuAction.SET_CURRENT_INTERACTED_ITEM,
          cause: stateChangeTypes.stateChangeTypes.KEYBOARD_NAV_AUTO_FOCUS,
          targetId: menuId,
          highlightedItemIndex: 0
        });
      }
    }
  }, [
    setIsMenuActive,
    isNavigatingWithKeyboard,
    highlightedItemIndex,
    dispatch,
    menuId
  ]);
  const [handleMouseMove, handleMouseOut] = useMouseHandlers.useMouseHandlers(
    props,
    isMenuActiveState,
    menuRef
  );
  const hasEndAdornment = React.useMemo(
    () => data.menuItems.some(stateUtils.hasSubMenu),
    [data]
  );
  const hasStartAdornment = React.useMemo(() => data.menuItems.some(stateUtils.hasIcon), [data]);
  const rowHeight = rowHeightProp != null ? rowHeightProp : defaultRowHeight;
  const maxHeight = menuPositioning.getMaxHeight(heightProp, spacing, getScreenBounds);
  const calculatedMenuHeight = rowHeight * data.menuItems.length;
  const menuHeight = menuPositioning.getHeight(heightProp, calculatedMenuHeight, maxHeight);
  const hasScrollbar = menuHeight >= maxHeight;
  const menuContainerHeight = menuHeight + 2;
  const Window = WindowContext.useWindow();
  const { reference, floating, x, y, strategy } = core.useFloatingUI({
    placement: isRoot ? rootPlacement : "right-start"
  });
  core.useIsomorphicLayoutEffect(() => {
    if (parentElement) {
      reference(
        isRoot ? parentElement : parentElement.querySelector(
          `#${parentElement.getAttribute("aria-activedescendant")}`
        )
      );
    }
  }, [reference, isRoot, parentElement]);
  if (parentElement === null) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntime.jsx(Portal.Portal, {
    children: /* @__PURE__ */ jsxRuntime.jsx(Window, {
      className: `${baseClass}-popper`,
      id: menuId,
      style: {
        top: y != null ? y : 0,
        left: x != null ? x : 0,
        position: strategy
      },
      ref: floating,
      children: /* @__PURE__ */ jsxRuntime.jsx(List.List, {
        className: clsx.clsx(baseClass, className),
        height: menuContainerHeight,
        highlightedIndex: highlightedItemIndex === null ? -1 : highlightedItemIndex,
        id: menuId,
        itemHeight: rowHeight,
        itemToString,
        listRef: handleRef,
        maxWidth,
        minWidth,
        onFocus: onFocusHandler,
        onKeyDown: handleKeyDown,
        onMouseOut: disableMouseOutInteractions ? void 0 : handleMouseOut,
        role: "menu",
        width: "auto",
        children: data.menuItems.map((menuItem, idx) => {
          const isInteracted = highlightedItemIndex === idx;
          return /* @__PURE__ */ jsxRuntime.jsx(CascadingMenuItem.DefaultMenuItem, {
            blurSelected: !isMenuActive && isInteracted,
            hasEndAdornment,
            hasScrollbar,
            hasStartAdornment,
            hasSubMenu: stateUtils.hasSubMenu(menuItem),
            isChildMenuOpen,
            isInteracted,
            isNavigatingWithKeyboard,
            itemToString,
            onItemClick,
            onMouseMove: () => handleMouseMove(idx),
            sourceItem: menuItem,
            tooltipEnterDelay,
            tooltipLeaveDelay
          }, idx);
        })
      }, menuId)
    })
  });
});

exports.CascadingMenuList = CascadingMenuList;
//# sourceMappingURL=CascadingMenuList.js.map
